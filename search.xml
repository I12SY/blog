<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>资源整理</title>
    <url>/blog/2020/04/25/%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>这里整理了本博客的一些资源文件，提供下载：<br>链接：<a href="https://pan.baidu.com/s/1AO1Cj3j-lxjz9XmED7c-eQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1AO1Cj3j-lxjz9XmED7c-eQ</a><br>提取码：lgzo </p>
<p>如果链接失效，请加我QQ或微信<br>QQ:2783251472<br>微信：happy_wei_wei</p>
]]></content>
  </entry>
  <entry>
    <title>Spring面试题</title>
    <url>/blog/2020/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.kanzhun.com/news/zc_k-mianshitimuspringmianshiti/" target="_blank" rel="noopener">https://www.kanzhun.com/news/zc_k-mianshitimuspringmianshiti/</a>  </p>
<p>Spring事务面试考点整理：<br><a href="http://www.zhiliaotang.net/jishujiaoliu/Java/1012.html" target="_blank" rel="noopener">http://www.zhiliaotang.net/jishujiaoliu/Java/1012.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>spring是什么?spring主要包含哪些核心组件?</title>
    <url>/blog/2020/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/spring%E6%98%AF%E4%BB%80%E4%B9%88-spring%E4%B8%BB%E8%A6%81%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>Spring是一个开源框架，它由Rod Johnson创建。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器的开发。从简单性、可测试性和松耦合的角度而言，任何java应用都可以从Spring中收益。  </p>
<a id="more"></a>  
<h3 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1.Spring简介"></a>1.Spring简介</h3><p>Spring是一个轻量级的控制反转(Ioc)和面向切面(AOP)的容器框架。</p>
<p>轻量——从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型的，Soring应用中的对象不依赖于Spring的特定类。  </p>
<p>控制反转——Spring通过一种称作控制反转(Ioc)的技术促进了松耦合。当应用了Ioc，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为Ioc与JNDI(数据源配置服务)相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。(也就是依赖注入)  </p>
<p>面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务(例如审计(auditing)和事务(transaction)管理)进行内聚性开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责(甚至是意识)其它的系统级关注点，例如日志和事务支持。  </p>
<p>容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型(prototype),你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。  </p>
<p>框架——Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声名式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能(事务管理、持久化框架集成等等)，将应用逻辑的开发留给了你。  </p>
<h3 id="2-spring核心框架体系："><a href="#2-spring核心框架体系：" class="headerlink" title="2.spring核心框架体系："></a>2.spring核心框架体系：</h3><p><a href="https://www.cnblogs.com/wzk-0000/p/9306170.html" target="_blank" rel="noopener">https://www.cnblogs.com/wzk-0000/p/9306170.html</a></p>
<h3 id="3-解释一下什么是MVC，IOC，AOP，ORM，JNDI-，Hibernate，SSO、Portal？"><a href="#3-解释一下什么是MVC，IOC，AOP，ORM，JNDI-，Hibernate，SSO、Portal？" class="headerlink" title="3.解释一下什么是MVC，IOC，AOP，ORM，JNDI,，Hibernate，SSO、Portal？"></a>3.解释一下什么是MVC，IOC，AOP，ORM，JNDI,，Hibernate，SSO、Portal？</h3><p>MVC: 项目分层设计模型:包括Model层，View层和Control层。<br>IOC:  控制反转,spring中的一个核心概念,通过xml配置文件来降低代码之间的耦合度，其中主要方法为依赖注入，通过setter方法获取构造函数方法实现.<br>AOP: 面向切面编程。将模块作为关注点实现，security，持久化层，日志层，等都可以单独作为一个关注点来实现.<br>ORM: 对象关系映射模型,主要运行用在持久层里面，将java的对象概念和mysql的关系型数据库相互映射.主要实现有mybatis/hibernate<br>JNDI:　数据源配置服务，直接配置在java web服务器中的配置shuju库连接信息<br>Hibernate: 著名的java　持久层框架，基于db2,mybatis之上的又一层高度封装开源ORM框架.<br>SSO: 单点登陆,在大型系统中，用户只需登录一次就能访问所有关联的应用系统,在Shiro框架中可以通过xml配置.<br>Portal:　整合服务的表示层，负责多系统，不同界面信息的整合，已作为java规范被写入标准,企业和网站可以很容易的将自己的服务进行标准封装，插入Portal系统，提供跟用户使用  </p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>sleep与wait</title>
    <url>/blog/2020/03/30/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/sleep%E4%B8%8Ewait/</url>
    <content><![CDATA[<p><strong>共同点：</strong>     </p>
<a id="more"></a>  
<ol>
<li>他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。    </li>
<li>wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。<br>如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep/join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。<br>需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。  </li>
</ol>
<p><strong>不同点 ：</strong><br>1.每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。<br>sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。<br>2.wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用<br>3.sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常<br>4.sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。<br>5.wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。   </p>
]]></content>
  </entry>
  <entry>
    <title>Math类</title>
    <url>/blog/2020/03/30/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/Math%E7%B1%BB/</url>
    <content><![CDATA[<p>java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。  </p>
<a id="more"></a>  

<h2 id="1-public-static-double-abs-double-a-：返回-double-值的绝对值"><a href="#1-public-static-double-abs-double-a-：返回-double-值的绝对值" class="headerlink" title="1.public static double abs(double a) ：返回 double 值的绝对值"></a>1.public static double abs(double a) ：返回 double 值的绝对值</h2><pre><code>double d1 = Math.abs(‐5); //d1的值为5
double d2 = Math.abs(5); //d2的值为5</code></pre><h2 id="2-public-static-double-ceil-double-a-：返回大于等于参数的最小的整数。"><a href="#2-public-static-double-ceil-double-a-：返回大于等于参数的最小的整数。" class="headerlink" title="2.public static double ceil(double a) ：返回大于等于参数的最小的整数。"></a>2.public static double ceil(double a) ：返回大于等于参数的最小的整数。</h2><p><strong>ceil:有天花板的意思(也就是向上取整)</strong>  </p>
<pre><code>double d1 = Math.ceil(3.3); //d1的值为 4.0
double d2 = Math.ceil(‐3.3); //d2的值为 ‐3.0
double d3 = Math.ceil(5.1); //d3的值为 6.0</code></pre><h2 id="3-public-static-double-floor-double-a-：返回小于等于参数最大的整数。"><a href="#3-public-static-double-floor-double-a-：返回小于等于参数最大的整数。" class="headerlink" title="3.public static double floor(double a) ：返回小于等于参数最大的整数。"></a>3.public static double floor(double a) ：返回小于等于参数最大的整数。</h2><p><strong>ceil:有天地板的意思(也就是向下取整)</strong>  </p>
<pre><code>double d1 = Math.floor(3.3); //d1的值为3.0
double d2 = Math.floor(‐3.3); //d2的值为‐4.0
double d3 = Math.floor(5.1); //d3的值为 5.0</code></pre><h2 id="4-public-static-long-round-double-a-：返回最接近参数的-long。-相当于四舍五入方法"><a href="#4-public-static-long-round-double-a-：返回最接近参数的-long。-相当于四舍五入方法" class="headerlink" title="4.public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法)"></a>4.public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法)</h2><pre><code>long d1 = Math.round(8.1);//8
long d2 = Math.round(8.5);//9
long d3 = Math.round(8.6);//9
long d4 = Math.round(-8.1);//-8
long d5 = Math.round(-8.5);//-8
long d6 = Math.round(-8.6);//-9</code></pre>]]></content>
  </entry>
  <entry>
    <title>Redis面试题集</title>
    <url>/blog/2020/03/30/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_36096051/article/details/100879154?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158450065919724839243580%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&amp;request_id=158450065919724839243580&amp;biz_id=0&amp;utm_source=distribute.pc_search_result.none-task" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36096051/article/details/100879154?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158450065919724839243580%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&amp;request_id=158450065919724839243580&amp;biz_id=0&amp;utm_source=distribute.pc_search_result.none-task</a></p>
]]></content>
  </entry>
  <entry>
    <title>一道关于字符串创建对象的问题</title>
    <url>/blog/2020/03/30/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/%E4%B8%80%E9%81%93%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>String s=new String(“xyz”);创建了几个String Object？二者之前的区别是什么？</p>
<a id="more"></a>  

<p>第一个是字符串常量”xyz”，第二个对象是new String(“xyz”)的时候产生的，在堆中分配内存给这个对象，只不过这个对象的内容是指向字符串常量”xyz”，另外还有一个引用s，指向第二个对象。这算是一个变量，在栈中分配内存。  </p>
<p>参考文章<br><a href="https://blog.csdn.net/qq_43573190/article/details/88959649" target="_blank" rel="noopener">https://blog.csdn.net/qq_43573190/article/details/88959649</a><br><a href="https://blog.csdn.net/linzhiji/article/details/5926737?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/linzhiji/article/details/5926737?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>一道关于Integer的面试题</title>
    <url>/blog/2020/03/30/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/%E4%B8%80%E9%81%93%E5%85%B3%E4%BA%8EInteger%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>下面给出题目，想想分别输出什么？  </p>
<a id="more"></a>  

<pre><code>public class Test {
    public static void main(String[] args) {
        Integer a = 100;
        Integer b = 100;
        int c=100;
        System.out.println(a==b);//1
        System.out.println(a==c);//2

        Integer a2 = 200;
        Integer b2 = 200;
        int d=200;
        System.out.println(a2==b2);//3
        System.out.println(a2==d);//4

        Integer a3 = new Integer(100);
        Integer b3 = new Integer(100);
        System.out.println(a3==b3);//5
        System.out.println(a==a3);//6
        System.out.println(c==a3);//7

        Integer a4 = new Integer(200);
        Integer b4 = new Integer(200);
        System.out.println(a4==b4);//8
        System.out.println(a2==a4);//9
        System.out.println(d==a4);//10
    }
}</code></pre><p>运行结果  </p>
<pre><code>true --------1
true --------2
false --------3
true --------4
false --------5
false --------6
true --------7
false --------8
false --------9
true --------10</code></pre><h3 id="1-为什么1输出true-而3输出false？"><a href="#1-为什么1输出true-而3输出false？" class="headerlink" title="1.为什么1输出true,而3输出false？"></a>1.为什么1输出true,而3输出false？</h3><p>我们知道==比较的是两个对象的引用，这里的a b a2 b2都是新建出来的对象，按理说都应该输入false才对。这就是这道题的有趣之处，无论是面试题还是论坛讨论区，这道题的出场率都很高。原理其实很简单，我们去看下Integer.java这个类就了然了。    </p>
<pre><code>public static Integer valueOf(int i) {
   return i &gt;= 128 || i &lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128];
 }

 /**
  * A cache of instances used by {@link Integer#valueOf(int)} and auto-boxing
  */
 private static final Integer[] SMALL_VALUES = new Integer[256];

 static {
   for (int i = -128; i &lt; 128; i++) {
     SMALL_VALUES[i + 128] = new Integer(i);
   }
 }</code></pre><p><strong>当我们声明一个Integer c = 100;的时候。此时会进行自动装箱操作，简单点说，也就是把基本数据类型转换成Integer对象，而转换成Integer对象正是调用的valueOf方法，可以看到，Integer中把-128~127 缓存了下来。</strong>官方解释是小的数字使用的频率比较高，所以为了优化性能，把这之间的数缓存了下来。这就是为什么这道题的答案回事false和ture了。当声明的Integer对象的值在-128-127之间的时候，引用的是同一个对象，所以结果是true。  </p>
<h3 id="2-Integer与int比较"><a href="#2-Integer与int比较" class="headerlink" title="2.Integer与int比较"></a>2.Integer与int比较</h3><p>上面的例子中2、4、7、10输出的结果为true，而5、6、8、9的输出结果为false，又是什么情况呢？  </p>
<p>首先我们来看5这个例子，按上一题来说Integer不是把-128~127缓存起来了吗？这不是应该为true吗，但是你仔细看，这里的Integer是我们自己new出来的，并不是用的缓存，所以结果是false，6、8、9的输出结果同理。  </p>
<p>我们再来看看10这个输出结果为什么是true呢？首先这里的值为200，肯定和我们所知的Integer缓存没有关系。既然和缓存没有关系，a4是新new出来的对象，按理说输出应该是false才对。但是你要注意了d这里是int类型。当int和Integer进行==比较的时候，Java会把Integer进行自动拆箱，也就是把Integer转成int类型，所以这里进行比较的是int类型的值，所以结果即为true。2、4、7输出结果同理。  </p>
<p><strong>总结一下：</strong>  </p>
<ul>
<li>（1）int与int比较由于比较的字面量，始终是true</li>
<li>(2) int与Integer比较，由于integer会发生自动拆箱，始终是ture</li>
<li>（3）Integer与Integer比较：<ul>
<li>a.若两个都是new，始终都是false</li>
<li>b.若一个new，一个非new(包括字面量和Integer.valueOf()等)，那么一个是自动装箱的对象，一个是new的对象，始终是false</li>
<li>c.两个都不是new，都会发生自动装箱（调用 Integer.valueOf()自动装箱），就要看值的范围了，在-128-127之间，会取IntegerCache里的对象，这样就是true了，不在范围之间，就是false了</li>
</ul>
</li>
</ul>
<p><strong>参考文章</strong><br><a href="https://blog.csdn.net/jonesAriven/article/details/98513132" target="_blank" rel="noopener">https://blog.csdn.net/jonesAriven/article/details/98513132</a></p>
]]></content>
  </entry>
  <entry>
    <title>面试汇总</title>
    <url>/blog/2020/03/30/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="一、技术方面的问题"><a href="#一、技术方面的问题" class="headerlink" title="一、技术方面的问题"></a>一、技术方面的问题</h2><a id="more"></a>  

<h2 id="1-八大基本数据类型有哪些，各占多少个字节。"><a href="#1-八大基本数据类型有哪些，各占多少个字节。" class="headerlink" title="1.八大基本数据类型有哪些，各占多少个字节。"></a>1.八大基本数据类型有哪些，各占多少个字节。</h2><blockquote>
<p>八大基本数据类型：Byte，short，int，long，double，folat，boolean，char，其中占一个字节的是byte，short和char占两个字节，int，float占四个字节，double和long占8个字节，boolean只有true和false，这八种数据变量中直接存储值  </p>
</blockquote>
<h2 id="2-int与Integer"><a href="#2-int与Integer" class="headerlink" title="2.int与Integer"></a>2.int与Integer</h2><blockquote>
<p><a href="/blog/2020/03/30/面试题整理/一道关于Integer的面试题/" target="_blank">一道关于Integer的面试题</a>  </p>
</blockquote>
<h2 id="3-String-s-new-String-“xyz”-创建了几个String-Object？二者之前的区别是什么？"><a href="#3-String-s-new-String-“xyz”-创建了几个String-Object？二者之前的区别是什么？" class="headerlink" title="3.String s=new String(“xyz”);创建了几个String Object？二者之前的区别是什么？"></a>3.String s=new String(“xyz”);创建了几个String Object？二者之前的区别是什么？</h2><blockquote>
<p><a href="/blog/2020/03/30/面试题整理/一道关于字符串创建对象的问题/" target="_blank">一道关于字符串创建对象的问题</a>  </p>
</blockquote>
<h2 id="4-Math-round-11-5-与Math-round-11-5"><a href="#4-Math-round-11-5-与Math-round-11-5" class="headerlink" title="4.Math.round(11.5)与Math.round(-11.5)"></a>4.Math.round(11.5)与Math.round(-11.5)</h2><blockquote>
<p><a href="/blog/2020/03/30/面试题整理/Math类/" target="_blank">Math类</a>  </p>
</blockquote>
<h2 id="5-Thread的sleep方法与Object的wait方法。"><a href="#5-Thread的sleep方法与Object的wait方法。" class="headerlink" title="5.Thread的sleep方法与Object的wait方法。"></a>5.Thread的sleep方法与Object的wait方法。</h2><blockquote>
<p><a href="/blog/2020/03/30/面试题整理/sleep与wait/" target="_blank">sleep与wait</a>  </p>
</blockquote>
<h2 id="6-什么是接口，接口的概念"><a href="#6-什么是接口，接口的概念" class="headerlink" title="6.什么是接口，接口的概念"></a>6.什么是接口，接口的概念</h2><blockquote>
<p>所以Interface这个词可以表达一个很泛的概念，可以这么理解：不需要关注具体实现，对外提供给用户如何调用的方式(即规范)。只要满足这两个条件可以认为就是Interface。<br><a href="https://segmentfault.com/q/1010000005026205" target="_blank" rel="noopener">https://segmentfault.com/q/1010000005026205</a>  </p>
</blockquote>
<h2 id="7-写出你认为你最熟悉的一种设计模式。"><a href="#7-写出你认为你最熟悉的一种设计模式。" class="headerlink" title="7.写出你认为你最熟悉的一种设计模式。"></a>7.写出你认为你最熟悉的一种设计模式。</h2><p>以单例模式的双重校验锁为例：  </p>
<pre><code>public class Singleton {

    private volatile static Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(instance==null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}</code></pre><h2 id="8-斐波那契数列，给定一个n值，返回第那个数列的值，1-1-2-3-5-8-13…"><a href="#8-斐波那契数列，给定一个n值，返回第那个数列的值，1-1-2-3-5-8-13…" class="headerlink" title="8.斐波那契数列，给定一个n值，返回第那个数列的值，1,1,2,3,5,8,13….."></a>8.斐波那契数列，给定一个n值，返回第那个数列的值，1,1,2,3,5,8,13…..</h2><pre><code>public class Test {

    public static int fibonacci(int n){
        if(n==0) return 0;
        if(n==1) return 1;
        return fibonacci(n-1)+fibonacci(n-2);
    } 

    public static void main(String[] args) {
        for (int n = 1; n &lt;= 10; n++) {
            System.out.print(fibonacci(n)+&quot; &quot;);
        }
    }
}</code></pre>]]></content>
  </entry>
  <entry>
    <title>volatile关键字的作用</title>
    <url>/blog/2020/03/28/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>volatile在java并发编程中常用于保持内存可见性(但不保证原子性)和防止指令重排。  </p>
<a id="more"></a>  
<p>在 Java 多线程中如何保证线程的安全性？那我们可以使用 Synchronized 同步锁来给需要多个线程访问的代码块加锁以保证线程安全性。使用 synchronized 虽然可以解决多线程安全问题，但弊端也很明显：加锁后多个线程需要判断锁，较为消耗资源。所以就引出我们今天的主角——volatile 关键字，一种轻量级的解决方案。  </p>
<p>在了解volatile之前，首先我们得先了解：多线程和JMM（Java内存模型）以及并发编程的3个概念。  </p>
<h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h2><h3 id="（1）进程和线程"><a href="#（1）进程和线程" class="headerlink" title="（1）进程和线程"></a>（1）进程和线程</h3><p>进程：一个正在执行中的程序，动态的，是系统进行资源分配和调度的独立单位。<br>线程：进程中一个独立的控制单元，线程控制着进程的执行。一个进程中至少有一个线程。  </p>
<h3 id="（2）创建线程的两种基本方式"><a href="#（2）创建线程的两种基本方式" class="headerlink" title="（2）创建线程的两种基本方式"></a>（2）创建线程的两种基本方式</h3><p>继承Thread类或者实现Runnable接口，然后重写run方法，调用线程的start方法。  </p>
<h3 id="（3）线程的生命周期"><a href="#（3）线程的生命周期" class="headerlink" title="（3）线程的生命周期"></a>（3）线程的生命周期</h3><p>就绪状态（线程 new 后）、可执行状态（start 方法启动线程，调用 run 方法）、阻塞状态（sleep 方法 和 wait 方法）、死亡状态（stop 方法）  </p>
<h2 id="2-Java-内存模型"><a href="#2-Java-内存模型" class="headerlink" title="2.Java 内存模型"></a>2.Java 内存模型</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。  </p>
<h3 id="（2）组成结构（类比-CPU、高速缓存-、内存-间的关系）"><a href="#（2）组成结构（类比-CPU、高速缓存-、内存-间的关系）" class="headerlink" title="（2）组成结构（类比 CPU、高速缓存 、内存 间的关系）"></a>（2）组成结构（类比 CPU、高速缓存 、内存 间的关系）</h3><p><img src="/blog/img/2020/03/28/java内存模型结构图.png"><br><br>主内存：所有线程共享；共享变量在主内存中存储的是其“<strong>本身</strong>”；<br>工作内存：每个线程有自己的工作空间；共享变量在主内存中存储的是其“<strong>副本</strong>”；<br>线程对共享变量的所有操作全在工作内存中进行；每个线程只能访问自己的工作内存；变量值的传递只能通过主内存完成。  </p>
<h2 id="3-并发编程的3个基本概念"><a href="#3-并发编程的3个基本概念" class="headerlink" title="3.并发编程的3个基本概念"></a>3.并发编程的3个基本概念</h2><h3 id="（1）原子性"><a href="#（1）原子性" class="headerlink" title="（1）原子性"></a>（1）原子性</h3><p>定义： <strong>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</strong><br>原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。例如 a=1是原子性操作，但是a++和a +=1就不是原子性操作。Java中的原子性操作包括：<br>a. 基本类型的读取和赋值操作，且赋值必须是数字赋值给变量，变量之间的相互赋值不是原子性操作。<br>b.所有引用reference的赋值操作<br>c.java.concurrent.Atomic.* 包中所有类的一切操作    </p>
<h3 id="（2）可见性"><a href="#（2）可见性" class="headerlink" title="（2）可见性"></a>（2）可见性</h3><p>定义：<strong>指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</strong><br>在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。  </p>
<h3 id="（3）有序性"><a href="#（3）有序性" class="headerlink" title="（3）有序性"></a>（3）有序性</h3><p>定义：<strong>即程序执行的顺序按照代码的先后顺序执行。</strong><br>Java内存模型中的有序性可以总结为：<strong>如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。</strong>前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p>
<p>在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。  </p>
<h2 id="4-volatile关键字-用来修饰被不同线程访问和修改的变量"><a href="#4-volatile关键字-用来修饰被不同线程访问和修改的变量" class="headerlink" title="4.volatile关键字(用来修饰被不同线程访问和修改的变量)"></a>4.volatile关键字(用来修饰被不同线程访问和修改的变量)</h2><h3 id="（1）内存可见性"><a href="#（1）内存可见性" class="headerlink" title="（1）内存可见性"></a>（1）内存可见性</h3><p>请看代码：  </p>
<pre><code>public class VolatileTest extends Thread {

    boolean flag = false;
    int i = 0;

    public void run() {
        while (!flag) {
            i++;
        }
        System.out.println(&quot;end......&quot;);
    }

    @Override
    public String toString() {
        return &quot;VolatileTest [flag=&quot; + flag + &quot;, i=&quot; + i + &quot;]&quot;;
    }



    public static void main(String[] args) throws Exception {
        VolatileTest vt = new VolatileTest();
        vt.start();
        Thread.sleep(2000);
        vt.flag = true;
        System.out.println(&quot;stop  &quot; + vt.i);
    }
}</code></pre><p>输出结果  </p>
<pre><code>stop  1070955768</code></pre><p>上面的代码是通过标记flag来控制VolatileTest线程while循环退出的例子!  
下面让我用伪代码来描述一下我们的程序：  </p>
<ul>
<li>首先创建 VolatileTest vt = new VolatileTest();</li>
<li>然后启动线程 vt.start();</li>
<li>暂停主线程2秒（Main） Thread.sleep(2000);</li>
<li>这时的vt线程已经开始执行，进行i++;</li>
<li>主线程暂停2秒结束以后将 vt.flag = true;</li>
<li>打印语句 System.out.println(“stop “ + vt.i); 在此同时由于vt.flag被设置为true,所以vt线程在进行下一次while判断 while (!flag) 返回假 结束循环 vt线程方法结束退出；然后打印语句System.out.println(“end……”)！  </li>
<li>主线程结束</li>
</ul>
<p>上面的叙述看似并没有什么问题，“似乎”完全正确。那就让我们把程序运行起来看看效果吧，执行mian方法。2秒钟以后控制台打印stop  202753974。<br>可是奇怪的事情发生了 程序并没有退出。vt线程仍然在运行，控制台也没有打印end……，也就是说我们在主线程设置的 vt.flag = true;没有起作用。  </p>
<p><strong>问题出现了，为什么我在主线程（main）中设置了vt.flag = true; 而vt线程在进行判断flag的时候拿到的仍然是false?</strong><br>那么按照我们上面所讲的 “JVM在运行时候的内存分配过程” 就很好解释上面的问题了。  </p>
<p>首先 vt线程在运行的时候会把 变量 flag 与 i (代码3,4行)从“主内存”  拷贝到 线程栈内存（上图的线程工作内存）  </p>
<p>然后 vt线程开始执行while循环   </p>
<pre><code>while (!flag) {
  i++;
}</code></pre><p>while (!flag)进行判断的flag 是在线程工作内存当中获取，而不是从 “主内存”中获取。<br>i++; 将线程内存中的i++; 加完以后将结果写回至 “主内存”，如此重复。  </p>
<p>然后再说说主线程的执行过程。 我只说明关键的地方<br>vt.flag = true;<br>主线程将vt.flag的值同样 从主内存中拷贝到自己的线程工作内存 然后修改flag=true. 然后再将新值回到主内存。  </p>
<p>这就解释了为什么在主线程（main）中设置了vt.flag = true; 而vt线程在进行判断flag的时候拿到的仍然是false。那就是因为vt线程每次判断flag标记的时候是从它自己的“工作内存中”取值，而并非从主内存中取值！  </p>
<p>这也是JVM为了提供性能而做的优化。那我们如何能让vt线程每次判断flag的时候都强制它去主内存中取值呢。这就是volatile关键字的作用。  </p>
<p>再次修改我们的代码:  </p>
<pre><code>public class VolatileTest extends Thread {

    volatile boolean flag = false;
    int i = 0;

    public void run() {
        while (!flag) {
            i++;
        }
        System.out.println(&quot;end......&quot;);
    }

    @Override
    public String toString() {
        return &quot;VolatileTest [flag=&quot; + flag + &quot;, i=&quot; + i + &quot;]&quot;;
    }



    public static void main(String[] args) throws Exception {
        VolatileTest vt = new VolatileTest();
        vt.start();
        Thread.sleep(2000);
        vt.flag = true;
        System.out.println(&quot;stop  &quot; + vt.i);
    }
}</code></pre><p>输出结果  </p>
<pre><code>stop  973794258
end......</code></pre><p>在flag前面加上volatile关键字，强制线程每次读取该值的时候都去“主内存”中取值(也就是让缓存失效了)。在试试我们的程序吧，已经正常退出了,并且控制台打印出了end……。  </p>
<h3 id="（2）禁止指令重排"><a href="#（2）禁止指令重排" class="headerlink" title="（2）禁止指令重排"></a>（2）禁止指令重排</h3><p>指令重排：JVM 在编译 Java 代码时或 CPU 在执行 JVM 字节码时，对现有指令顺序进行重新排序，优化程序的运行效率。（在不改变程序执行结果的前提下）   </p>
<p>指令重排虽说可以优化程序的执行效率，但在多线程问题上会影响结果。那么有什么解决办法呢？答案是<strong>内存屏障。</strong> 内存屏障是一种屏障指令，使 CPU 或编译器对屏障指令之前和之后发出的内存操作执行一个排序的约束。  </p>
<p>四种类型：<strong>LoadLoad 屏障、StoreStore 屏障、LoadStore 屏障、StoreLoad 屏障。（Load 代表读取指令、Store 代表写入操作）</strong>   </p>
<p><strong>在 volatile 变量上的体现：（JVM 执行操作）</strong>  </p>
<ul>
<li>在每个 volatile 写入操作前插入 StoreStore 屏障；</li>
<li>在写操作后插入 StoreLoad 屏障；</li>
<li>在读操作前插入 LoadLoad 屏障；</li>
<li>在读操作后插入 LoadStore 屏障；</li>
</ul>
<p>具体请看例子<br><strong>单例模式的双重锁为什么要加volatile</strong>    </p>
<pre><code>public class Singleton {

    private volatile static Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){//1
        if(instance==null){//2
            synchronized(Singleton.class){//3
                if(instance==null){//4
                    instance = new Singleton();//5
                }
            }
        }
        return instance;//6
    }
}</code></pre><p>需要关键字的原因是，在并发情况下，如果没有volatile关键字，在第5行会出现问题。<br>instance = new Singleton();可以分解为3行伪代码  </p>
<p>a.memory = allocate()//分配内存  </p>
<p>b.ctorlnstanc(memory)//初始化对象  </p>
<p>c.instance = memory//设置instance指向刚分配的地址  </p>
<p>上面的代码在编译运行时，可能会出现重排序从a-b-c排序为a-c-b。在多线程的情况下会出现以下问题。当线程A在执行第5行代码时，B线程进来执行到第2行代码。假设此时A执行的过程中发生了指令重排序，即先执行了a和c，没有执行b。那么由于A线程执行了c导致instance指向了一段地址，所以B线程判断instance不为null，会直接调到第6行并返回一个未初始化的对象。  </p>
<h3 id="（3）不保证原子性"><a href="#（3）不保证原子性" class="headerlink" title="（3）不保证原子性"></a>（3）不保证原子性</h3><p>需要重点说明的一点是，<strong>尽管volatile关键字可以保证内存可见性和有序性，但不能保证原子性。</strong>也就是说，对volatile修饰的变量进行的操作，不保证多线程安全。请看以下的例子：    </p>
<pre><code>public class Test {
    /** 处理main线程阻塞（等待所有子线程） */
    private static CountDownLatch countDownLatch = new CountDownLatch(1000);
    private volatile static int num = 0;

    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) {
            executor.execute(()-&gt;{
                try {
                    num++;
                } catch (Exception e) {
                    e.printStackTrace();
                }finally{
                    // 每个独立子线程执行完后,countDownLatch值减1
                    countDownLatch.countDown();
                }
            });
        }
        try {
            //使得主线程（main）阻塞直到countDownLatch.countDown()为零才继续执行
            //也就是保证前面的线程都执行完成
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        executor.shutdown();
        System.out.println(num);
    }
}</code></pre><p>静态变量num被volatile所修饰，并且同时开启1000个线程对其进行累加的操作，按道理来说，其结果应该为1000，但实际的情况是，每次运行结果都是一个小于1000的数字，并且不固定。那么这是为什么呢？原因是因为“num++;”这行代码并不是原子操作，尽管它被volatile所修饰了也依然如此。++操作的执行过程如下面所示：  </p>
<ul>
<li>首先获取变量num的值</li>
<li>将该变量的值+1</li>
<li>将该变量的值写回到对应的主内存中</li>
</ul>
<p>虽然每次获取num值的时候，也就是执行上述第一步的时候，都拿到的是主内存的最新变量值，但是在进行第二步num+1的时候，可能其他线程在此期间已经对num做了多次修改，这时再进行第二三步操作之后就会覆盖了一个旧值，发生了错误。比如说：线程A在执行第一步的时候读取到此时num的值为3，然后在执行第二步之前，其他多个线程已经对该值进行了多次修改，使得num值变为了10。而线程A此时执行第二步，将原先的num值为3的结果+1变为了4，最后再将4写回到主内存中（实际此时num应该为11）。所以这也就是最后的执行结果为什么都会是一个小于1000的值的原因，内存可见性只能保证在第一步操作上的内存可见性而已。  </p>
<p>所以如果要解决上面代码的多线程安全问题，可以采取加锁synchronized的方式，或者采用lock，也可以使用JUC包下的原子类AtomicInteger，原子操作类是通过CAS循环的方式来保证其原子性的，以下的代码演示了使用AtomicInteger来包装num变量的方式：  </p>
<pre><code>import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

public class Test {
    /** 处理main线程阻塞（等待所有子线程） */
    private static CountDownLatch countDownLatch = new CountDownLatch(1000);
    private static AtomicInteger num = new AtomicInteger();

    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) {
            executor.execute(()-&gt;{
                try {
                    num.getAndIncrement();
                } catch (Exception e) {
                    e.printStackTrace();
                }finally{
                    // 每个独立子线程执行完后,countDownLatch值减1
                    countDownLatch.countDown();
                }
            });
        }
        try {
            //使得主线程（main）阻塞直到countDownLatch.countDown()为零才继续执行
            //也就是保证前面的线程都执行完成
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        executor.shutdown();
        System.out.println(num);
    }
}</code></pre><p>多次运行上面的代码，结果都为1000。  </p>
<h2 id="5-volatile不适用的场景"><a href="#5-volatile不适用的场景" class="headerlink" title="5.volatile不适用的场景"></a>5.volatile不适用的场景</h2><p><strong>volatile不适合复合操作</strong><br>比如上面那个例子中的num++<br>解决方案除了上面那种之外，还有其他两种方式，这里展示一下代码。<br>（1）采用synchronized  </p>
<pre><code>public class Test2 {
    /** 处理main线程阻塞（等待所有子线程） */
    private static CountDownLatch countDownLatch = new CountDownLatch(1000);
    private static int num = 0;

    public synchronized void increase(){
        num++;
    }

    public static void main(String[] args) {
        final  Test2 test = new Test2();
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) {
            executor.execute(()-&gt;{
                try {
                    test.increase();
                } catch (Exception e) {
                    e.printStackTrace();
                }finally{
                    // 每个独立子线程执行完后,countDownLatch值减1
                    countDownLatch.countDown();
                }
            });
        }
        try {
            //使得主线程（main）阻塞直到countDownLatch.countDown()为零才继续执行
            //也就是保证前面的线程都执行完成
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        executor.shutdown();
        System.out.println(num);
    }
}</code></pre><p>(2) 采用Lock  </p>
<pre><code>public class Test2 {
    /** 处理main线程阻塞（等待所有子线程） */
    private static CountDownLatch countDownLatch = new CountDownLatch(1000);
    private static int num = 0;
    private Lock lock = new ReentrantLock();

    public void increase(){
        lock.lock();
        try {
            num++;
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }

    }

    public static void main(String[] args) {
        final  Test2 test = new Test2();
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) {
            executor.execute(()-&gt;{
                try {
                    test.increase();
                } catch (Exception e) {
                    e.printStackTrace();
                }finally{
                    // 每个独立子线程执行完后,countDownLatch值减1
                    countDownLatch.countDown();
                }
            });
        }
        try {
            //使得主线程（main）阻塞直到countDownLatch.countDown()为零才继续执行
            //也就是保证前面的线程都执行完成
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        executor.shutdown();
        System.out.println(num);
    }
}</code></pre><h2 id="6-参考文章"><a href="#6-参考文章" class="headerlink" title="6.参考文章"></a>6.参考文章</h2><p><a href="https://blog.csdn.net/qq_38190057/article/details/80813516" target="_blank" rel="noopener">https://blog.csdn.net/qq_38190057/article/details/80813516</a><br><a href="https://blog.csdn.net/u012723673/article/details/80682208" target="_blank" rel="noopener">https://blog.csdn.net/u012723673/article/details/80682208</a><br><a href="https://www.cnblogs.com/xd502djj/p/9873067.html" target="_blank" rel="noopener">https://www.cnblogs.com/xd502djj/p/9873067.html</a><br><a href="https://www.cnblogs.com/moxiaotao/p/10857139.html" target="_blank" rel="noopener">https://www.cnblogs.com/moxiaotao/p/10857139.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>JAVA死锁的原因例子及解决方法</title>
    <url>/blog/2020/03/26/JAVA%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BE%8B%E5%AD%90%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。即线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。  </p>
<a id="more"></a>  
<p><strong>死锁发生的例子1：</strong>  </p>
<pre><code>public class DeadLockA extends Thread {

    @Override
    public void run() {
        try {
            System.out.println(&quot;LockA running&quot;);
            while(true){
                synchronized(Client.obj1){
                    System.out.println(&quot;LockA locked obj1&quot;);
                    //获取obj1后先等一会儿，让LockB有足够的时间锁住obj2
                    Thread.sleep(100);
                    System.out.println(&quot;LockA trying to lock obj2...&quot;);
                    synchronized(Client.obj2){
                        System.out.println(&quot;LockA locked obj2&quot;);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

class DeadLockB extends Thread {

    @Override
    public void run() {
        try {
            System.out.println(&quot;LockB running&quot;);
            while(true){
                synchronized(Client.obj2){
                    System.out.println(&quot;LockB locked obj2&quot;);
                    System.out.println(&quot;LockB trying to lock obj1...&quot;);
                    synchronized(Client.obj1){
                        System.out.println(&quot;LockB locked obj1&quot;);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}</code></pre><br>

<pre><code>public class Client {
     public static final String obj1 = &quot;obj1&quot;;
        public static final String obj2 = &quot;obj2&quot;;

        public static void main(String[] ars) {
            new DeadLockA().start();
            new DeadLockB().start();
        }
}</code></pre><p>运行结果  </p>
<pre><code>LockA running
LockA locked obj1
LockB running
LockB locked obj2
LockB trying to lock obj1...
LockA trying to lock obj2...</code></pre><p>结果显示两个线程最后都在等待对方释放锁，最终进入了死锁状态。<br><strong>死锁发生的例子2：</strong>  </p>
<p>public class TestClass {</p>
<pre><code>public synchronized void method(TestClass clazz) {
    System.out.println(&quot;TestClass method in&quot;);
    clazz.method2();
    System.out.println(&quot;TestClass method out&quot;);
}

public synchronized void method2() {
    System.out.println(&quot;TestClass method2&quot;);
}</code></pre><p>}
<br>  </p>
<p>public class TestLock extends Thread {<br>    private TestClass class1;<br>    private TestClass class2;</p>
<pre><code>public TestLock(TestClass class1, TestClass class2) {
    this.class1 = class1;
    this.class2 = class2;
}

@Override
public void run() {
    class1.method(class2);
}</code></pre><p>}
<br></p>
<pre><code>public class Client {
    public static void main(String[] ars) {
        TestClass classA = new TestClass();
        TestClass classB = new TestClass();
        new TestLock(classA, classB).start();
        new TestLock(classB, classA).start();
    }
}</code></pre><p>运行结果  </p>
<pre><code>TestClass method in
TestClass method in</code></pre><p>结果显示进入两次方法，但是并没有走完，发生死锁。<br>一旦出现死锁，整个程序既不会发生任何错误，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。java虚拟机没有提供检测，也没有采取任何措施来处理死锁的情况，所以多线程编程中，必须手动应该采取措施避免死锁。  </p>
<p><strong>解决方法</strong><br><strong>1.调整申请锁的范围</strong>  </p>
<pre><code>public class TestClass {

    public void method(TestClass clazz) {
        System.out.println(&quot;TestClass method in&quot;);
        synchronized(this){
            //do something
        }
        clazz.method2();
        System.out.println(&quot;TestClass method out&quot;);
    }

    public synchronized void method2() {
        System.out.println(&quot;TestClass method2&quot;);
    }
}  </code></pre><p>上面代码原来锁是加在方法上的，现在改为在方法内的一部分，这样在使用第二个锁时本身的锁已经释放了。如果减小锁的申请范围可以避免锁的申请发生闭环的话，那么就可以避免死锁。  </p>
<p><strong>2.调整申请锁的顺序</strong><br>在有些情况下是不允许我们调整锁的范围的，比如银行转账的场景下，我们必须同时获得两个账户上的锁，才能进行操作，两个锁的申请必须发生交叉。这时要想打破死锁闭环，必须调整锁的申请顺序，总是以相同的顺序来申请锁，比如总是先申请 id 大的账户上的锁 ，然后再申请 id 小的账户上的锁，这样就无法形成导致死锁的那个闭环。</p>
<pre><code>public class Account {
    private int id;    // 主键
    private String name;
    private double balance;

    public void transfer(Account from, Account to, double money){
        if(from.getId() &gt; to.getId()){
            synchronized(from){
                synchronized(to){
                    // transfer
                }
            }
        }else{
            synchronized(to){
                synchronized(from){
                    // transfer
                }
            }
        }
    }

    public int getId() {
        return id;
    }
}</code></pre><p>这样的话，即使发生了两个账户比如 id=1的和id=100的两个账户相互转账，因为不管是哪个线程先获得了id=100上的锁，另外一个线程都不会去获得id=1上的锁(因为他没有获得id=100上的锁)，只能是哪个线程先获得id=100上的锁，哪个线程就先进行转账。这里除了使用id之外，如果没有类似id这样的属性可以比较，那么也可以使用对象的hashCode()的值来进行比较。  </p>
<p><strong>避免死锁的发生</strong><br>很多时候实际锁的交叉可能涉及很多个，要想很好的避免只能人工仔细检查，一旦我们在一个同步方法中，或者说在一个锁的保护的范围中，调用了其它对象的方法时，就要十分的小心：  </p>
<ol>
<li>如果其它对象的这个方法会消耗比较长的时间，那么就会导致锁被我们持有了很长的时间；   </li>
<li>如果其它对象的这个方法是一个同步方法，那么就要注意避免发生死锁的可能性了；  </li>
</ol>
<p>总之是尽量避免在一个同步方法中调用其它对象的延时方法和同步方法。  </p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/lyabc123456/article/details/81060477" target="_blank" rel="noopener">https://blog.csdn.net/lyabc123456/article/details/81060477</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>JVM面试知识点</title>
    <url>/blog/2020/03/26/JVM%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_39037047/article/details/80532908" target="_blank" rel="noopener">https://blog.csdn.net/qq_39037047/article/details/80532908</a>  </p>
<h2 id="1-内存模型以及分区，需要详细到每个区放什么。"><a href="#1-内存模型以及分区，需要详细到每个区放什么。" class="headerlink" title="1.内存模型以及分区，需要详细到每个区放什么。"></a>1.内存模型以及分区，需要详细到每个区放什么。</h2><a id="more"></a>  
<blockquote>
<p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念。java内存模型中分为主内存和工作内存。主内存里面存储着所有变量，主内存是共享内存区域，所有线程都可以访问。每一个线程都私有一个工作内存，工作内存里面保存着主内存里面变量值的副本，线程对变量的操作都是在工作内存中完成，操作结束后再放回主内存。主内存可粗略认为是堆，工作内存认为是栈。<br><strong>方法区：</strong>主要是存储类信息，常量池（static常量和static变量），编译后的代码（字节码）等数据。<br><strong>堆：</strong>初始化的对象，成员变量 （那种非static的变量），所有的对象实例和数组都要在堆上分配。<br><strong>栈：</strong>又分为java虚拟机栈和本地方法栈。其中Java虚拟机栈，它是线程私有的，生命周期与线程相同。每个方法执行都会创建一个栈帧，用于存放局部变量表，操作栈，动态链接，方法出口等。每个方法从被调用，直到被执行完。对应着一个栈帧在虚拟机中从入栈到出栈的过程。<br><strong>本地方法栈：</strong>主要为Native方法服务。<br><strong>程序计数器：</strong>记录当前线程执行的行号。<br><a href="https://blog.csdn.net/qiuchaoxi/article/details/79889097" target="_blank" rel="noopener">https://blog.csdn.net/qiuchaoxi/article/details/79889097</a><br><a href="https://www.cnblogs.com/feicheninfo/p/9684658.html" target="_blank" rel="noopener">https://www.cnblogs.com/feicheninfo/p/9684658.html</a>  </p>
</blockquote>
<h2 id="2-堆里面的分区：Eden，survival-from-to，老年代，各自的特点"><a href="#2-堆里面的分区：Eden，survival-from-to，老年代，各自的特点" class="headerlink" title="2.堆里面的分区：Eden，survival from to，老年代，各自的特点"></a>2.堆里面的分区：Eden，survival from to，老年代，各自的特点</h2><blockquote>
<p><a href="https://blog.csdn.net/qiuchaoxi/article/details/79891761" target="_blank" rel="noopener">https://blog.csdn.net/qiuchaoxi/article/details/79891761</a>  </p>
</blockquote>
<h2 id="3-对象创建方法，对象的内存分配，对象的访问定位"><a href="#3-对象创建方法，对象的内存分配，对象的访问定位" class="headerlink" title="3.对象创建方法，对象的内存分配，对象的访问定位"></a>3.对象创建方法，对象的内存分配，对象的访问定位</h2><blockquote>
<p><a href="https://www.jianshu.com/p/73bc18bab332" target="_blank" rel="noopener">https://www.jianshu.com/p/73bc18bab332</a>  </p>
</blockquote>
<h2 id="4-GC的两种判定方法：引用计数与引用链。"><a href="#4-GC的两种判定方法：引用计数与引用链。" class="headerlink" title="4.GC的两种判定方法：引用计数与引用链。"></a>4.GC的两种判定方法：引用计数与引用链。</h2><h2 id="5-GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"><a href="#5-GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？" class="headerlink" title="5.GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"></a>5.GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</h2><h2 id="6-GC收集器有哪些？CMS收集器与G1收集器的特点。"><a href="#6-GC收集器有哪些？CMS收集器与G1收集器的特点。" class="headerlink" title="6.GC收集器有哪些？CMS收集器与G1收集器的特点。"></a>6.GC收集器有哪些？CMS收集器与G1收集器的特点。</h2><h2 id="7-Minor-GC与Full-GC分别在什么时候发生？"><a href="#7-Minor-GC与Full-GC分别在什么时候发生？" class="headerlink" title="7.Minor GC与Full GC分别在什么时候发生？"></a>7.Minor GC与Full GC分别在什么时候发生？</h2><h2 id="8-几种常用的内存调试工具：jmap、jstack、jconsole。"><a href="#8-几种常用的内存调试工具：jmap、jstack、jconsole。" class="headerlink" title="8.几种常用的内存调试工具：jmap、jstack、jconsole。"></a>8.几种常用的内存调试工具：jmap、jstack、jconsole。</h2><h2 id="9-类加载的五个过程：加载、验证、准备、解析、初始化"><a href="#9-类加载的五个过程：加载、验证、准备、解析、初始化" class="headerlink" title="9.类加载的五个过程：加载、验证、准备、解析、初始化."></a>9.类加载的五个过程：加载、验证、准备、解析、初始化.</h2><blockquote>
<p><strong>加载：</strong>通过一个类名的全限定名来获取定义此类的二进制字节流；将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。<br><strong>验证：</strong>确保Class文件的字节流中包含的信息符合当前虚拟机的要求。<br><strong>准备：</strong>正式为类变量分配内存并设置类变量初始值（通常情况下是数据类型的零值）的阶段。<br><strong>解析：</strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。<br><strong>初始化：</strong>类初始化阶段是类加载过程的最后一步，到了这个阶段才真正开始执行类中定义的Java程序代码（或者说是字节码）。<br><a href="https://blog.csdn.net/chenge_j/article/details/72677766" target="_blank" rel="noopener">https://blog.csdn.net/chenge_j/article/details/72677766</a></p>
</blockquote>
<h2 id="10-双亲委派模型：Bootstrap-ClassLoader、Extension-ClassLoader、ApplicationClassLoader。"><a href="#10-双亲委派模型：Bootstrap-ClassLoader、Extension-ClassLoader、ApplicationClassLoader。" class="headerlink" title="10.双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。"></a>10.双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。</h2><h2 id="11-分派：静态分派与动态分派。"><a href="#11-分派：静态分派与动态分派。" class="headerlink" title="11.分派：静态分派与动态分派。"></a>11.分派：静态分派与动态分派。</h2>]]></content>
  </entry>
  <entry>
    <title>JAVA7与JAVA8的新特性</title>
    <url>/blog/2020/03/26/JAVA7%E4%B8%8EJAVA8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="一、jdk1-7新特性"><a href="#一、jdk1-7新特性" class="headerlink" title="一、jdk1.7新特性"></a>一、jdk1.7新特性</h2><a id="more"></a>  
<h3 id="1-泛型实例的创建可以通过类型推断来简化，可以去掉后面new部分的泛型类型，只用-lt-gt-就可以了。"><a href="#1-泛型实例的创建可以通过类型推断来简化，可以去掉后面new部分的泛型类型，只用-lt-gt-就可以了。" class="headerlink" title="1.泛型实例的创建可以通过类型推断来简化，可以去掉后面new部分的泛型类型，只用&lt;&gt;就可以了。"></a>1.泛型实例的创建可以通过类型推断来简化，可以去掉后面new部分的泛型类型，只用&lt;&gt;就可以了。</h3><pre><code>//在 Java7 以前，实例化一个 HashMap 对象的写法如下：
Map&lt;String, String&gt; map1=new HashMap&lt;String, String&gt;();
//而 Java7 引进了类型推断机制，因此，可以采用更加简洁的写法，如下所示：
Map&lt;String, String&gt; map2=new HashMap&lt;&gt;();</code></pre><h3 id="2-并发工具增强：-fork-join框架最大的增强，充分利用多核特性，将大问题分解成各个子问题，由多个cpu-可以同时-解决多个子问题，最后合并结果，继承RecursiveTask，实现compute方法，然后调用fork计算，最后用join合并结果。"><a href="#2-并发工具增强：-fork-join框架最大的增强，充分利用多核特性，将大问题分解成各个子问题，由多个cpu-可以同时-解决多个子问题，最后合并结果，继承RecursiveTask，实现compute方法，然后调用fork计算，最后用join合并结果。" class="headerlink" title="2.并发工具增强： fork-join框架最大的增强，充分利用多核特性，将大问题分解成各个子问题，由多个cpu 可以同时 解决多个子问题，最后合并结果，继承RecursiveTask，实现compute方法，然后调用fork计算，最后用join合并结果。"></a>2.并发工具增强： fork-join框架最大的增强，充分利用多核特性，将大问题分解成各个子问题，由多个cpu 可以同时 解决多个子问题，最后合并结果，继承RecursiveTask，实现compute方法，然后调用fork计算，最后用join合并结果。</h3><h3 id="3-try-with-resources-语句是一个声明了一个或多个资源的try-语句。这里的一个资源指的是在使用完成后，必须关闭释放的对象。try-with-resources-语句可以确保在该语句执行之后关闭每个资源，确保了每个资源都在生命周期结束后被关闭，因此，在读取文件结束后，不需要显式地调用-close-方法。"><a href="#3-try-with-resources-语句是一个声明了一个或多个资源的try-语句。这里的一个资源指的是在使用完成后，必须关闭释放的对象。try-with-resources-语句可以确保在该语句执行之后关闭每个资源，确保了每个资源都在生命周期结束后被关闭，因此，在读取文件结束后，不需要显式地调用-close-方法。" class="headerlink" title="3.try-with-resources 语句是一个声明了一个或多个资源的try 语句。这里的一个资源指的是在使用完成后，必须关闭释放的对象。try-with-resources 语句可以确保在该语句执行之后关闭每个资源，确保了每个资源都在生命周期结束后被关闭，因此，在读取文件结束后，不需要显式地调用 close 方法。"></a>3.try-with-resources 语句是一个声明了一个或多个资源的try 语句。这里的一个资源指的是在使用完成后，必须关闭释放的对象。try-with-resources 语句可以确保在该语句执行之后关闭每个资源，确保了每个资源都在生命周期结束后被关闭，因此，在读取文件结束后，不需要显式地调用 close 方法。</h3><pre><code>public class TryWithResources {
    public static void main(String[] args) {
        try(InputStream is = new FileInputStream(&quot;input.txt&quot;);) {
            while(is.read() != -1){
                System.out.println(is.read());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre><h3 id="4-Catch多个异常：在Java-7中，catch代码块得到了升级，用以在单个catch块中处理多个异常。如果你要捕获多个异常并且它们包含相似的代码，使用这一特性将会减少代码重复度。"><a href="#4-Catch多个异常：在Java-7中，catch代码块得到了升级，用以在单个catch块中处理多个异常。如果你要捕获多个异常并且它们包含相似的代码，使用这一特性将会减少代码重复度。" class="headerlink" title="4.Catch多个异常：在Java 7中，catch代码块得到了升级，用以在单个catch块中处理多个异常。如果你要捕获多个异常并且它们包含相似的代码，使用这一特性将会减少代码重复度。"></a>4.Catch多个异常：在Java 7中，catch代码块得到了升级，用以在单个catch块中处理多个异常。如果你要捕获多个异常并且它们包含相似的代码，使用这一特性将会减少代码重复度。</h3><pre><code>class Exception1 extends RuntimeException {

}

class Exception2 extends RuntimeException {

}

public class Test{
    public static void main(String[] args) {
        try {

        } catch (Exception1 | Exception2 e) {
            // TODO: handle exception
        }
    }
}</code></pre><h3 id="5-switch-可以接受-String-类型。随着-Java-语言的发展，在-Java7-中，switch-开始支持-String类型。"><a href="#5-switch-可以接受-String-类型。随着-Java-语言的发展，在-Java7-中，switch-开始支持-String类型。" class="headerlink" title="5.switch 可以接受 String 类型。随着 Java 语言的发展，在 Java7 中，switch 开始支持 String类型。"></a>5.switch 可以接受 String 类型。随着 Java 语言的发展，在 Java7 中，switch 开始支持 String类型。</h3><pre><code>public class Switch {
    public void test(String str){
        switch(str){
            case &quot;computer&quot;:
                System.out.println(&quot;computer&quot;);
                break;
            case &quot;book&quot;:
                System.out.println(&quot;book&quot;);
                break;
            case &quot;iphone&quot;:
                System.out.println(&quot;iphone&quot;);
                break;
            default:
                System.out.println(&quot;default&quot;);
        }
    }

    public static void main(String[] args) {
        Switch switch1=new Switch();
        switch1.test(&quot;computer&quot;);
    }
}</code></pre><p>其实，jdk1.7并没有新的指令来处理switch string，而是通过调用switch中string.hashCode,将string转换为int从而进行判断。  </p>
<h3 id="6-数值字面量进行了改进-。"><a href="#6-数值字面量进行了改进-。" class="headerlink" title="6.数值字面量进行了改进 。"></a>6.数值字面量进行了改进 。</h3><p>① 可以用二进制来表示整数，用0b开头。增加了二进制字面量的表示（0B001、0b111）。整数类型（例如 byte、short、int 与 long等）也可以使用二进制数来表示。要指定一个二进制字面量，可以给二进制数字添加前缀 0b 或者 0B。相比于十六进制或者八进制，二进制字面量可以使数据之间的关系更加清晰。<br>② 在数字中可以添加分隔符，例如 123_456，下划线只能被用在数字中间，编译的时候这些下划线会被编译器去掉。这样做的好处是避免了一些难以通过观察代码来发现的细微错误。例如数字 10000000000 和数字 1000000000，不仔细看很难发现两个数字中谁少了一个 0 或多了一个 0，但对于 10_000_000_000 和 1_000_000_000 却不然。  </p>
<pre><code>public class Vaule {
    public static void main(String[] args) {
        int a1=0B001;
        int a2=0b01111111;
        long a3= 10_000_000_000L;
        long a4= 1_000_000_000L;
        System.out.println(a1+&quot; &quot;+a2);
        System.out.println(a3+&quot; &quot;+a4);
    }
}</code></pre><p>输出结果  </p>
<pre><code>1 127
10000000000 1000000000</code></pre><h2 id="二、jdk1-8新特性"><a href="#二、jdk1-8新特性" class="headerlink" title="二、jdk1.8新特性"></a>二、jdk1.8新特性</h2><h3 id="1-接口的默认方法与静态方法"><a href="#1-接口的默认方法与静态方法" class="headerlink" title="1.接口的默认方法与静态方法"></a>1.接口的默认方法与静态方法</h3><p>Java1.8以前，接口里的方法要求全部是抽象方法，java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可。  </p>
<pre><code>interface Inter8 {
    void f();
    default void g(){
        System.out.println(&quot;this is default method in interface&quot;);
    }
    static void h(){
        System.out.println(&quot;this is static method in interface&quot;);
    }
}</code></pre><p>这样做的最重要的一个目的就是为了实现接口升级。在原有的设计中，如果想要升级接口，例如给接口中添加一个新的方法，会导致所有实现这个接口的类都需要被修改，这给Java 语言已有的一些框架进行升级带来了很大的麻烦。如果接口能支持默认方法的实现，那么可以给这些类库的升级带来许多便利。例如，为了支持 Lambda 表达式，Collection 中引入了 foreach 方法，可以通过这个语法增加默认的实现，从而降低了对这个接口进行升级的代价，不需要对所有实现这个接口的类进行修改。  </p>
<h3 id="2-增加了对-Lambda-表达式的支持。"><a href="#2-增加了对-Lambda-表达式的支持。" class="headerlink" title="2.增加了对 Lambda 表达式的支持。"></a>2.增加了对 Lambda 表达式的支持。</h3><p>Lambda 表达式是一个匿名函数（指的是没有函数名的函数），它基于数学中的 λ 演算得名，直接对应于其中的 Lambda 抽象。Lambda 表达式可以表示闭包（注意和数学传统意义上的不同）。<br>Lambda 表达式允许把函数作为一个方法的参数。<br>Lambda 表达式的基本语法如下：<br>(parameters) -&gt; expression<br>或者<br> (parameters) -&gt;{ statements;}  </p>
<p>显然，采用 Lambda 表达式后，代码会变得更加简洁。  </p>
<pre><code>public class Lambda{
    public static void main(String[] args) {
        Arrays.asList(1,2,3).forEach(i -&gt; System.out.print(i+&quot; &quot;));
        System.out.println();
        Arrays.asList(1,2,3).forEach((Integer i) -&gt; System.out.print(i+&quot; &quot;));
        System.out.println();
        Person[] people={new Person(&quot;James&quot;, 25),new Person(&quot;Jack&quot;, 21)};
        Arrays.sort(people,new Comparator&lt;Person&gt;() {

            @Override
            public int compare(Person o1, Person o2) {
                return o1.getAge()-o2.getAge();
            }

        });
        //采用 Lambda 表达式后，写法如下：
        Arrays.sort(people,(Person a,Person b) -&gt; a.getAge()-b.getAge());
        //或
        Arrays.sort(people,(a,b) -&gt; a.getAge()-b.getAge());
        for (Person person : people) {
            System.out.print(person+&quot; &quot;);
        }
    }
}
/**
在 Java8 以前，Java 语言通过匿名函数的方法来代替 Lambda 表达式。
对于列表的排序，如果列表里面存放的是自定义的类，通常需要指定自定义的排序方法，传
统的写法如下：
 */
class Person{
    private String name;
    private int age;
    public Person(String name,int age){
        this.name=name;
        this.age=age;
    }
    public int getAge(){
        return age;
    }
    public String getName(){
        return name;
    }
    @Override
    public String toString() {
        return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
    }

}</code></pre><h3 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3.函数式接口"></a>3.函数式接口</h3><p>Lambda 表达式是通过函数式接口（只有一个方法的普通接口）来实现的。函数式接口可以被隐式地转换为 Lambda 表达式。为了与普通的接口区分开（普通接口中可能会有多个方法），JDK1.8 新增加了一种特殊的注解@FunctionalInterface。下面给出一个函数式接口的定义：   </p>
<pre><code>@FunctionalInterface
interface fun {
    void f();
}  </code></pre><h3 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4.方法引用"></a>4.方法引用</h3><p>方法引用指的是可以直接引用 Java 类或对象的方法。它可以被看成是一种更加简洁易懂的 Lambda 表达式，使用方法引用后，上例中的排序代码就可以使用下面更加简洁的方式来编写：<br>Arrays.sort(people, Comparator.comparing(Person::getAge));<br>方法引用共有下面 4 种形式：<br>① 引用构造方法：ClassName::new。<br>② 引用类静态方法：ClassName::methodName。<br>③ 引用特定类的任意对象方法：ClassName::methodName。<br>④ 引用某个对象的方法：instanceName::methodName。  </p>
<pre><code>class Person2{
    private String name;
    private int age;
    public Person2(){}
    public Person2(String name,int age){
        this.name=name;
        this.age=age;
    }
    public static Person2 getInstance(final Supplier&lt;Person2&gt; supplier){
        return supplier.get();
    }
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public static int compareByAge(Person2 a,Person2 b)
    {
        return b.age-a.age;
    }
    @Override
    public String toString() {
        return &quot;Person2 [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
    }
}
class CompareProvider{
    public int compareByAge(Person2 a,Person2 b){
        return a.getAge()-b.getAge();
    }
}
public class MethodReference {
    public static void main(String[] args) {
        //引用是构造方法
        Person2 p1=Person2.getInstance(Person2 :: new);
        p1.setAge(19);
        System.out.println(&quot;测试引用构造方法：&quot;+p1.getAge());
        Person2[] people ={new Person2(&quot;James&quot;, 25), new Person2(&quot;Jack&quot;, 21)};
        //引用特定类的任意对象方法
        Arrays.sort(people,Comparator.comparing(Person2::getAge));
        System.out.println(&quot;测试引用特定类的任意对象方法：&quot;);
        for (Person2 p : people) {
            System.out.println(p);
        }
        //引用类静态方法
        Arrays.sort(people,Person2::compareByAge);
        System.out.println(&quot;测试引用类静态方法：&quot;);
        for (Person2 p : people) {
            System.out.println(p);
        }
        //引用某个对象的方法
        Arrays.sort(people,new CompareProvider()::compareByAge);
        System.out.println(&quot;测试引用某个对象的方法：&quot;);
        for (Person2 p : people) {
            System.out.println(p);
        }
    }
}</code></pre><h2 id="5-类型注解和重复注解"><a href="#5-类型注解和重复注解" class="headerlink" title="5.类型注解和重复注解"></a>5.类型注解和重复注解</h2><p>① JDK1.5 中引入了注解机制，但是有一个限制：相同的注解在同一位置只能声明一次。<br>JDK1.8 引入了重复注解机制后，相同的注解在同一个地方可以声明多次。  </p>
<pre><code>public class Annotation {
    /**
     * 对于注解（也被称做元数据），Java 8 主要有两点改进：类型注解和重复注解。
        1.类型注解
        1）Java 8 的类型注解扩展了注解使用的范围。
        在java 8之前，注解只能是在声明的地方所使用，java8开始，注解可以应用在任何地方。
     * 在 Java 8 版本中，Annotation 可以被用在任何使用 Type 的地方，例如：初始化对象时 (new)，对象类型转化时，使用 implements 表达式时，
     * 或者使用 throws 表达式时。
     */
    //初始化对象时
    String myString =new @NotNull String();
    //对象类型转化时
    myString = (@NonNull String) str;
    //使用 implements 表达式时
    class MyList&lt;T&gt; implements @ReadOnly List&lt;@ReadOnly T&gt;{}
    //使用 throws 表达式时
    public void validateValues() throws @Critical ValidationFailedException{}
}
/**
 2）新增ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER（在Target上）
新增的两个注释的程序元素类型 ElementType.TYPE_USE 和 ElementType.TYPE_PARAMETER用来描述注解的新场合。
ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中。
ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中（eg：声明语句、泛型和强制转换语句中的类型）。
 */
@Target({ElementType.TYPE_USE,ElementType.TYPE_PARAMETER})
@interface MyAnnotation{}
/**
 * 3)类型注解的作用
    类型注解被用来支持在Java的程序中做强类型检查。配合第三方插件工具Checker Framework（注：此插件so easy,这里不介绍了），
    可以在编译的时候检测出runtime error（eg：UnsupportedOperationException； NumberFormatException；NullPointerException
    异常等都是runtime error），以提高代码质量。这就是类型注解的作用。
    Note：
    使用Checker Framework可以找到类型注解出现的地方并检查。
    eg:
    public class TestDemo{  
    void sample() {  
        @NonNull Object my = new Object();  
        }  
    } 
 */</code></pre><p>② JDK1.8 对注解进行了扩展。使得注解被使用的范围更广，例如可以给局部变量、泛型和方法异常等提供注解。  </p>
<pre><code>@interface MyHints{
    Hint[] value();
}

@Repeatable(MyHints.class)
@interface Hint{
    String value();
}
//使用包装类当容器来存多个注解（旧版本方法）
@MyHints({@Hint(&quot;hint1&quot;),@Hint(&quot;hint2&quot;)})
class Person22{}
//使用多重注解（新方法）
@Hint(&quot;hint1&quot;)
@Hint(&quot;hint2&quot;)
class Person33{}</code></pre><h3 id="6-把-Base64-编码添加到了标准类库中"><a href="#6-把-Base64-编码添加到了标准类库中" class="headerlink" title="6.把 Base64 编码添加到了标准类库中"></a>6.把 Base64 编码添加到了标准类库中</h3><p>Base64 编码是一种常见的字符编码，可用来作为电子邮件或 Web Service 附件的传输编码。JDK1.8 把 Base64 编码添加到了标准类库中.  </p>
<pre><code>public class Base64s {
    public static void main(String[] args) {
        String str = &quot;Hello world&quot;;
        String encodStr = Base64.getEncoder().encodeToString(str.getBytes(StandardCharsets.UTF_8));
        System.out.println(encodStr);
        String decodStr = new String(Base64.getDecoder().decode(encodStr));
        System.out.println(decodStr);
    }
}</code></pre><h3 id="7-日期新特性，新时间日期API"><a href="#7-日期新特性，新时间日期API" class="headerlink" title="7.日期新特性，新时间日期API"></a>7.日期新特性，新时间日期API</h3><p>在 JDK1.8 以前，处理日期相关的类主要有如下三个：<br>① Calendar：实现日期和时间字段之间转换，它的属性是可变的。因此，它不是线程安全的。<br>② DateFormat：格式化和分析日期字符串。<br>③ Date：用来承载日期和时间信息，它的属性是可变的。因此，它不是线程安全的。<br>这些 API 使用起来很不方便，而且有很多缺点，以如下代码为例：<br>Date date = new Date(2015,10,1);<br>System.out.println(date);<br>在 Date 类传入参数中，月份为 10 月，但输出却为 Mon Nov 01 00:00:00 CST 3915。<br>JDK1.8 对日期相关的 API 进行了改进，提供了更加强大的 API。新的 java.time 主要包含了处<br>理日期、时间、日期/时间、时区、时刻（Instants）和时钟（Clock）等操作。下面给出一个<br>使用示例：    </p>
<pre><code>public class DateDemo {
    public static void main(String[] args){
        //Clock 类通过指定一个时区，可以获取到当前的时刻、日期与时间
        Clock c = Clock.system(ZoneId.of(&quot;Asia/Shanghai&quot;));//上海时区
        System.out.println(&quot;测试Clock: &quot;);
        System.out.println(c.millis());
        System.out.println(c.instant());

        //Instant 使用方法
        System.out.println(&quot;测试 Instant:&quot;);
        Instant ist = Instant.now();
        System.out.println(ist.getEpochSecond());//精确到秒
        System.out.println(ist.toEpochMilli());//精确到毫秒

        //LocalDate 以ISO-8601格式显示的日期类型，无时区信息
        LocalDate date = LocalDate.now();
        LocalDate dateFromClock = LocalDate.now(c);
        System.out.println(&quot;测试LocalDate:&quot;);
        System.out.println(date);
        System.out.println(dateFromClock);

        //LocalTime 是以ISO-8601 格式显示时间类型，无时区信息
        final LocalTime time = LocalTime.now();
        final LocalTime timeFromClock = LocalTime.now(c);
        System.out.println(&quot;测试LocalTime:&quot;);
        System.out.println(time);
        System.out.println(timeFromClock);

        //LocalDateTime 以ISO-8601 格式显示日期和时间
        final LocalDateTime dateTime = LocalDateTime.now();
        final LocalDateTime dateTimeFromClock = LocalDateTime.now(c);
        System.out.println(&quot;测试LocalDateTime:&quot;);
        System.out.println(dateTime);
        System.out.println(dateTimeFromClock);

        //新旧日期转换 
        Instant instant = new Date().toInstant();  
        Date date2 = Date.from(instant);  
        System.out.println(instant);  
        System.out.println(date2); 

        //提供对java.util.Calendar的替换，提供对年历系统的支持 
        Chronology c1 = HijrahChronology.INSTANCE;  
        ChronoLocalDateTime d = c1.localDateTime(LocalDateTime.now());  
        System.out.println(d.toLocalTime()); 
    }
}</code></pre><h3 id="8-增加了调用-JavaScript-的引擎Nashorn。JDK1-8-增加-API-使得可以通过-Java-程序来调用JavaScript-代码"><a href="#8-增加了调用-JavaScript-的引擎Nashorn。JDK1-8-增加-API-使得可以通过-Java-程序来调用JavaScript-代码" class="headerlink" title="8.增加了调用 JavaScript 的引擎Nashorn。JDK1.8 增加 API 使得可以通过 Java 程序来调用JavaScript 代码"></a>8.增加了调用 JavaScript 的引擎Nashorn。JDK1.8 增加 API 使得可以通过 Java 程序来调用JavaScript 代码</h3><p>从JDK 6开始，Java就已经捆绑了JavaScript引擎，该引擎基于Mozilla的Rhino。该特性允许开发人员将JavaScript代码嵌入到Java中，甚至从嵌入的JavaScript中调用Java。此外，它还提供了使用jrunscript从命令行运行JavaScript的能力。如果不需要非常好的性能，并且可以接受ECMAScript 3有限的功能集的话，那它相当不错了。<br>从JDK 8开始，Nashorn取代Rhino成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入invokedynamic，将JavaScript编译成Java字节码。<br>与先前的Rhino实现相比，这带来了2到10倍的性能提升，虽然它仍然比Chrome和Node.js中的V8引擎要差一些。  </p>
<pre><code>public class JavaScriptDemo {
    public static void main(String[] args) throws ScriptException, NoSuchMethodException, IOException{
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(&quot;JavaScript&quot;);
        System.out.println(engine.getClass().getName());
        System.out.println(engine.eval(&quot;function f(){return &apos;Hello&apos;;}; f()+&apos; world!&apos;;&quot;));

        //-------------------------------------------------------------JDK 6---------------------------------------------------------------------------
        //在Java中直接调用js代码
        //不能调用浏览器中定义的js函数，会抛出异常提示ReferenceError: “alert” is not defined。
        engine.eval(&quot;var a=3; var b=4;print (a+b);&quot;);

        //engine.eval(&quot;alert(\&quot;js alert\&quot;);&quot;);    // 不能调用浏览器中定义的js函数 // 错误，会抛出alert引用不存在的异常

        //在Java中绑定js变量
        //在调用engine.get(key);时，如果key没有定义，则返回null
        engine.put(&quot;a&quot;, 3);
        engine.put(&quot;b&quot;, 4);
        Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE);
        // 只能为Double，使用Float和Integer会抛出异常 
        Double result = (Double)engine.eval(&quot;a+b&quot;);
        System.out.println(&quot;result------&gt;&quot;+result);
        engine.eval(&quot;c=a+b&quot;);
        Double c = (Double)engine.get(&quot;c&quot;);
        System.out.println(&quot;c-----&gt;&quot;+c);

        //在Java中调用js文件中的function，传入调用参数，并获取返回值
        //js文件中的merge函数将两个参数a，b相加，并返回c。
        //在Java代码中读取js文件，并参数两个参数，然后回去返回值。
        String jsFileName = &quot;E:\\workspace_sts\\JAVA\\JAVA面试知识点\\src\\java8特性\\expression.js&quot;;  // 读取js文件
        FileReader reader = new FileReader(jsFileName);  // 执行指定脚本
        engine.eval(reader);
        if(engine instanceof Invocable){
            Invocable invoke = (Invocable)engine; // 调用merge方法，并传入两个参数
            // c = merge(2, 3); 
            Double cc = (Double)invoke.invokeFunction(&quot;merge&quot;, 3,4);
            System.out.println(&quot;cc----------&gt;&quot;+cc);
        }

        reader.close();
    }
}</code></pre><p>expression.js脚本内容  </p>
<pre><code>function merge(a,b){
    var c = a + b;
    return c;
}</code></pre><h3 id="9-Optional容器，新增-Optional-类。"><a href="#9-Optional容器，新增-Optional-类。" class="headerlink" title="9.Optional容器，新增 Optional 类。"></a>9.Optional容器，新增 Optional 类。</h3><p>在使用 Java 语言进行编程时，经常需要使用大量的代码来处理空指针<br>异常，而这种操作往往会降低程序的可读性。JDK1.8 引入了Optional 类来处理空指针的情况，从而增强了代码的可读性。下面给出一个简单的例子：  </p>
<pre><code>public class OptionalDemo {
    @SuppressWarnings(&quot;all&quot;)
    public static void main(String[] args) {
        //创建optional实例，也可以通过方法返回值得到
        Optional&lt;String&gt; name = Optional.of(&quot;Sanaulla&quot;);

        //创建没有值的Optional实例，例如值为&apos;null&apos;
        Optional empty = Optional.ofNullable(null);

        //isPresent方法来检查Optional实例是否有值
        if(name.isPresent()){
            //调用get()返回Optional值
            System.out.println(name.get());
        }

        try{
            //在Optional实例上调用get()抛出NoSuchElementException
            System.out.println(empty.get());
        }catch(NoSuchElementException ex){
            System.out.println(ex.getMessage());
        }

        //ifPresent方法接受lambda表达式参数
        //如果Optional值不为空，lambda表0达式会处理并在其上执行操作
        name.ifPresent((value) -&gt; {
            System.out.println(&quot;The length of the value is: &quot;+ value.length());
        }); 

        //如果有值orElse方法会返回Optional实例，否则返回传入的错误信息
        System.out.println(empty.orElse(&quot;There is no value present!&quot;));
        System.out.println(name.orElse(&quot;There is some value!&quot;));

        //orElseGet与orElse类似，区别在于传入的默认值
        //orElseGet接收lambda表达式生成默认值
        System.out.println(empty.orElseGet(() -&gt; &quot;Default value&quot;));
        System.out.println(name.orElseGet(() -&gt; &quot;Default value&quot;));

        try {
            //orElseThrow与orElse方法类似，区别在于返回值
            //orElseThrow接收lambda表达式/方法生成异常
            empty.orElseThrow(ValueAbsentException :: new);
        } catch (Throwable e) {
            System.out.println(e.getMessage());
        }

        //map方法通过传入的lambda表达式修改Optional实例默认值
        //lambda表达式返回值会包装为Optional实例
        Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());
        System.out.println(upperName.orElse(&quot;No value found&quot;));

        //faltMap与map（Function）非常相似，区别在于lambda表达式的返回值
        //map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例
        //但是faltMap方法的lambda返回值总是Optional类型
        upperName = name.flatMap((value) -&gt; Optional.of(value.toLowerCase()));
        System.out.println(upperName.orElse(&quot;No value found&quot;));

        //filter方法检查Optional值是否满足给定条件
        //如果满足返回Optional实例值，否则返回空Optional
        Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length()&gt;6);
        System.out.println(longName.orElse(&quot;The name is less than 6 characters&quot;));

        //另一个示例，Optional值不满足给定条件
        Optional&lt;String&gt; anotherName = Optional.of(&quot;Sana&quot;);
        Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length()&gt;6);
        System.out.println(shortName.orElse(&quot;The name is less than 6 characters&quot;));

    }
}

@SuppressWarnings(&quot;serial&quot;)
class ValueAbsentException extends Throwable {
    public ValueAbsentException(){
        super();
    }
    public ValueAbsentException(String msg){
        super(msg);
    }
    @Override
    public String getMessage() {
        return &quot;No value present in the Optional instance&quot;;
    }
}</code></pre><h3 id="10-增加了对数组并行处理的方法（parallelXxx），并行流和串行流"><a href="#10-增加了对数组并行处理的方法（parallelXxx），并行流和串行流" class="headerlink" title="10. 增加了对数组并行处理的方法（parallelXxx），并行流和串行流"></a>10. 增加了对数组并行处理的方法（parallelXxx），并行流和串行流</h3><p>JDK1.8 增加了对数组并行处理的方法（parallelXxx），可以说，最重要的是parallelSort()方法，因为它可以在多核机器上。<br>极大提高数组排序的速度。下面的例子展示了新方法（parallelXxx）的使用。  </p>
<pre><code>public class ParallelArrays {
    public static void main(String[] args) {
        long[] arrayOfLong = new long[20000];
        Arrays.parallelSetAll(arrayOfLong, index -&gt; ThreadLocalRandom.current().nextInt(1000000));
        Arrays.stream(arrayOfLong).limit(10).forEach(i -&gt; System.out.print(i + &quot; &quot;));
        System.out.println();
        Arrays.parallelSort(arrayOfLong);
        Arrays.stream(arrayOfLong).limit(10).forEach(i -&gt; System.out.print(i + &quot; &quot;));
        System.out.println();
    }
    /**
     * 上面的代码片段使用了parallelSetAll()方法来对一个有20000个元素的数组进行随机赋值。然后，调用parallelSort方法。
     * 这个程序首先打印出前10个元素的值，之后对整个数组排序。这个程序在控制台上的输出如下（请注意数组元素是随机生产的）：
     */
}</code></pre><h3 id="11-编译器优化。"><a href="#11-编译器优化。" class="headerlink" title="11.编译器优化。"></a>11.编译器优化。</h3><p>JDK1.8 通过在编译的时候增加–parameters 选项，以及增加反射 API 与Parameter.getName()方法实现了获取方法参数名的功能。  </p>
<pre><code>public class ParameterName {
    /**
     *  如果使用命令 javac Test.java 来编译并运行以上程序，程序的运行结果为 Parameter: args0。
        如果使用命令 javac Test.java –parameters 来编译并运行以上程序，程序的运行结果为
        Parameter: args。
     */
    public static void main(String[] args) {
        Method method;
        try {
            method = Parameter.class.getMethod(&quot;main&quot;, String[].class);
            for(final Parameter parameter:method.getParameters()){
                System.out.println(&quot;Parameter :&quot;+ parameter.getName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre><h3 id="12-引入流的概念，Stream-API"><a href="#12-引入流的概念，Stream-API" class="headerlink" title="12.引入流的概念，Stream API"></a>12.引入流的概念，Stream API</h3><pre><code>/**
 * 1.1 什么是流？
 * 流是Java8引入的全新概念，它用来处理集合中的数据，暂且可以把它理解为一种高级集合。
 * 
 * 众所周知，集合操作非常麻烦，若要对集合进行筛选、投影，需要写大量的代码，而流是以声明的形式操作集合，它就像SQL语句，
 * 我们只需告诉流需要对集合进行什么操作，它就会自动进行操作，并将执行结果交给你，无需我们自己手写代码。
 *
 *因此，流的集合操作对我们来说是透明的，我们只需向流下达命令，它就会自动把我们想要的结果给我们。由于操作过程完全由Java处理，
 *因此它可以根据当前硬件环境选择最优的方法处理，我们也无需编写复杂又容易出错的多线程代码了。
 *
 *1.2 流的特点
 *    1.只能遍历一次 
 *      我们可以把流想象成一条流水线，流水线的源头是我们的数据源(一个集合)，数据源中的元素依次被输送到流水线上，我们可以在流水
 *      线上对元素进行各种操作。一旦元素走到了流水线的另一头，那么这些元素就被“消费掉了”，我们无法再对这个流进行操作。当然，我们
 *      可以从数据源那里再获得一个新的流重新遍历一遍。
 *    2.采用内部迭代方式 
 *      若要对集合进行处理，则需我们手写处理代码，这就叫做外部迭代。而要对流进行处理，我们只需告诉流我们需要什么结果，处理过程
 *      由流自行完成，这就称为内部迭代。
 *
 *1.3 流的操作种类
 *    1.中间操作 
 *        当数据源中的数据上了流水线后，这个过程对数据进行的所有操作都称为“中间操作”。 
 *        中间操作仍然会返回一个流对象，因此多个中间操作可以串连起来形成一个流水线。
 *    2.终端操作 
 *        当所有的中间操作完成后，若要将数据从流水线上拿下来，则需要执行终端操作。 
 *        终端操作将返回一个执行结果，这就是你想要的数据
 *
 *1.4 流的操作过程
 *    使用流一共需要三步：
 *    1.准备一个数据源
 *    2.执行中间操作
 *        中间操作可以有多个，它们可以串连起来形成流水线。
 *    3.执行终端操作 
 *      执行终端操作后本次流结束，你将获得一个执行结果。
 *
 *2. 流的使用
 */
public class StreamDemo {
    @SuppressWarnings(&quot;all&quot;)
    public static void main(String[] args) {
        //2.1获取流
        //集合 这种数据源较为常用，通过stream()方法即可获取流对象：
        List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();
        Student s1 = new Student(&quot;张三&quot;,&quot;Y&quot;,20);
        Student s2 = new Student(&quot;李四&quot;,&quot;N&quot;,30);
        Student s3 = new Student(&quot;王五&quot;,&quot;Y&quot;,40);
        list.add(s1);
        list.add(s2);
        list.add(s3);
        Stream&lt;Student&gt; stream1 = list.stream();
        //数组 通过Arrays类提供的静态函数stream()获取数组的流对象：
        String[] names = {&quot;chaimm&quot;,&quot;peter&quot;,&quot;john&quot;,&quot;peter&quot;,&quot;john&quot;};
        Stream&lt;String&gt; stream2 = Arrays.stream(names);
        //值  直接将几个值变成流对象
        Stream&lt;String&gt; stream3 = Stream.of(&quot;chaimm&quot;,&quot;peter&quot;,&quot;john&quot;);
        //文件 PS：Java7简化了IO操作，把打开IO操作放在try后的括号中即可省略关闭IO的代码。
        try (Stream lines = Files.lines(Paths.get(&quot;文件路径名&quot;),Charset.defaultCharset())){
            //可对lines做一些操作
        } catch (IOException e) {
            // TODO: handle exception
        }

        //2.2 筛选filter filter函数接收一个Lambda表达式作为参数，该表达式返回boolean，在执行过程中，流将元素逐一输送给filter，并筛选出执行结果为true的元素。
        //如，筛选出所有学生：
        List&lt;Student&gt; result1 = stream1.filter(Student :: isStudent).collect(Collectors.toList());
        System.out.println(result1.toString());

        //2.3 去重distinct
        String[] result2 = stream2.distinct().toArray(String[] :: new);
        System.out.println(Arrays.toString(result2));

        //2.4 截取 截取流的前N个元素：
        //List&lt;Student&gt; result3 = stream1.limit(2).collect(Collectors.toList());  stream1 77行流已经关闭，再次执行报错! 只能遍历一次 
        List&lt;Student&gt; result3 = list.stream().limit(2).collect(Collectors.toList());
        System.out.println(result3.toString());
        String[] result4 =Arrays.stream(names).limit(2).toArray(String[] :: new);
        System.out.println(Arrays.toString(result4));

        //2.5 跳过 跳过流的前n个元素
        String[] result5 = stream3.skip(1).toArray(String[] :: new);
        System.out.println(Arrays.toString(result5));

        //2.6 映射  对流中的每个元素执行一个函数，使得元素转换成另一种类型输出。流会将每一个元素输送给map函数，并执行map中的Lambda表达式，最后将执行结果存入一个新的流中。 
        //如，获取每个人的姓名(实则是将Perosn类型转换成String类型)：
        List&lt;String&gt; result6 = list.stream().map(Student :: getName).collect(Collectors.toList());
        System.out.println(result6.toString());

        //2.7 合并多个流
        //例：列出List中各不相同的单词，List集合如下：
        List&lt;String&gt; list2 = new ArrayList&lt;String&gt;();
        list2.add(&quot;I am a boy&quot;);
        list2.add(&quot;I love the girl&quot;);
        list2.add(&quot;But the girl loves another girl&quot;);
        //首先将list2变成流：list2.stream();
        //Stream&lt;String&gt; stream4 = list2.stream();
        //按空格分词： list.stream().map(line-&gt;line.split(&quot; &quot;));
        //分完词之后，每个元素变成了一个String[]数组。
        //将每个String[]变成流：
        Stream stream5 = list2.stream().map(line -&gt; line.split(&quot; &quot;)).map(Arrays :: stream);
        //此时一个大流里面包含了一个个小流，我们需要将这些小流合并成一个流。
        //将小流合并成一个大流：用flagmap替换刚才的map stream4.map(line -&gt; line.split(&quot; &quot;)).flagmap(Arrays :: stream);
        //去重
        List&lt;String&gt; result7 =  list2.stream().map(line -&gt; line.split(&quot; &quot;)).flatMap(Arrays :: stream).distinct().collect(Collectors.toList());
        System.out.println(result7.toString());

        //2.8 是否匹配任一元素：anyMatch anyMatch用于判断流中是否存在至少一个元素满足指定的条件，这个判断条件通过Lambda表达式传递给anyMatch，执行结果为boolean类型。 
        //如，判断list中是否有学生： 类似 ||
        boolean result8 = list.stream().anyMatch(Student :: isStudent);
        System.out.println(&quot;result8-----&gt;&quot;+result8);
        List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;();
        Student s4 = new Student(&quot;张三&quot;,&quot;N&quot;);
        Student s5 = new Student(&quot;李四&quot;,&quot;N&quot;);
        Student s6 = new Student(&quot;王五&quot;,&quot;N&quot;);
        list3.add(s4);
        list3.add(s5);
        list3.add(s6);
        boolean result9 = list3.stream().anyMatch(Student :: isStudent);
        System.out.println(&quot;result9-----&gt;&quot;+result9);

        //2.9 是否匹配所有元素：allMatch
        //allMatch用于判断流中的所有元素是否都满足指定条件，这个判断条件通过Lambda表达式传递给anyMatch，执行结果为boolean类型。如，判断是否所有人都是学生：
        boolean result10 = list3.stream().allMatch(Student :: isStudent);
        System.out.println(&quot;result10-----&gt;&quot;+result10);
        List&lt;Student&gt; list4 = new ArrayList&lt;Student&gt;();
        Student s7 = new Student(&quot;张三&quot;,&quot;Y&quot;);
        Student s8 = new Student(&quot;李四&quot;,&quot;Y&quot;);
        Student s9 = new Student(&quot;王五&quot;,&quot;Y&quot;);
        list3.add(s7);
        list3.add(s8);
        list3.add(s9);
        boolean result11 = list4.stream().allMatch(Student :: isStudent);
        System.out.println(&quot;result11-----&gt;&quot;+result11);

        //2.10 是否未匹配所有元素：noneMatch
        //noneMatch与allMatch恰恰相反，它用于判断流中的所有元素是否都不满足指定条件：
        boolean result12 = list.stream().noneMatch(Student :: isStudent);
        System.out.println(&quot;result12-----&gt;&quot;+result12);
        boolean result13 = list3.stream().noneMatch(Student :: isStudent);
        System.out.println(&quot;result13-----&gt;&quot;+result13);
        boolean result14 = list4.stream().noneMatch(Student :: isStudent);
        System.out.println(&quot;result14-----&gt;&quot;+result14);

        //2.11 获取任一元素findAny
        Optional&lt;Student&gt; student = list.stream().findAny();
        Student stu = student.get();
        System.out.println(stu.toString());

        //2.12 获取第一个元素findFirst
        Optional&lt;Student&gt; student2 = list.stream().findFirst();
        Student stu2 = student.get();
        System.out.println(stu2.toString());

        //2.13 归约
        //归约是将集合中的所有元素经过指定运算，折叠成一个元素输出，如：求最值、平均数等，这些操作都是将一个集合的元素折叠成一个元素输出
        //在流中，reduce函数能实现归约。 reduce函数接收两个参数：
        //*初始值
        //*进行归约操作的Lambda表达式
        //2.13.1 元素求和：自定义Lambda表达式实现求和 例：计算所有人的年龄总和
        int age1 = list.stream().map(Student::getAge).reduce(0, (a,b) -&gt; a+b);
        System.out.println(&quot;age1----&gt;&quot;+age1);
        int age2 = list.stream().filter(stud -&gt; &quot;Y&quot;.equals(stud.getIsStudent())).map(Student :: getAge).reduce(0,(a,b) -&gt; a+b);
        System.out.println(&quot;age2----&gt;&quot;+age2);
        int[] digital = {1,2,3,4};
        int total1 = Arrays.stream(digital).reduce(0, (a,b) -&gt; a+b);
        System.out.println(&quot;total1----&gt;&quot;+total1);
        //reduce的第一个参数表示初试值为0； 
        //reduce的第二个参数为需要进行的归约操作，它接收一个拥有两个参数的Lambda表达式，reduce会把流中的元素两两输给Lambda表达式，最后将计算出累加之和。
        //2.13.2 元素求和：使用Integer.sum函数求和
        int age3 = list.stream().filter(stud -&gt; &quot;Y&quot;.equals(stud.getIsStudent())).map(Student :: getAge).reduce(0,Integer :: sum);
        System.out.println(&quot;age3----&gt;&quot;+age3);
        int total2 = Arrays.stream(digital).reduce(0, Integer :: max);
        System.out.println(&quot;total2----&gt;&quot;+total2);
        //Integer类还提供了min、max等一系列数值操作，当流中元素为数值类型时可以直接使用。

        //2.14 数值流的使用
        //采用reduce进行数值操作会涉及到基本数值类型和引用数值类型之间的装箱、拆箱操作，因此效率较低。 当流操作为纯数值操作时，使用数值流能获得较高的效率。
        //2.14.1 将普通流转换成数值流
        //StreamAPI提供了三种数值流：IntStream、DoubleStream、LongStream，也提供了将普通流转换成数值流的三种方法：mapToInt、mapToDouble、mapToLong。 
        //如，将Person中的age转换成数值流：
        IntStream intStream = list.stream().mapToInt(Student :: getAge);
        //2.14.2 数值计算
        //每种数值流都提供了数值计算函数，如max、min、sum等。 
        //如，找出最大的年龄：
        OptionalInt optionalInt = list.stream().mapToInt(Student :: getAge).max();
        System.out.println(&quot;最大的年龄----&gt;&quot;+optionalInt.getAsInt());
        OptionalInt optionalInt2 = Arrays.stream(digital).max();
        System.out.println(&quot;最大的数字----&gt;&quot;+optionalInt2.getAsInt());
        //由于数值流可能为空，并且给空的数值流计算最大值是没有意义的，因此max函数返回OptionalInt，它是Optional的一个子类，能够判断流是否为空，并对流为空
        //的情况作相应的处理。 
        //此外，mapToInt、mapToDouble、mapToLong进行数值操作后的返回结果分别为：OptionalInt、OptionalDouble、OptionalLong
    }
}

class Student{
    private String name;
    private String isStudent;
    private int age;
    public Student(){}
    public Student(String name,String isStudent){
        this.name=name;
        this.isStudent=isStudent;
    }
    public Student(String name,String isStudent,int age){
        this.name=name;
        this.isStudent=isStudent;
        this.age=age;
    }
    public static boolean isStudent(Student student){
        if(&quot;Y&quot;.equals(student.isStudent)){
            return true;
        }else{
            return false;
        }
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getIsStudent() {
        return isStudent;
    }
    public void setIsStudent(String isStudent) {
        this.isStudent = isStudent;
    }
    @Override
    public String toString() {
        return &quot;Student [name=&quot; + name + &quot;, isStudent=&quot; + isStudent + &quot;]&quot;;
    }

}</code></pre><p>//<a href="http://blog.csdn.net/u010425776/article/details/52344425" target="_blank" rel="noopener">http://blog.csdn.net/u010425776/article/details/52344425</a><br>//<a href="http://www.cnblogs.com/shenlanzhizun/p/6027042.html" target="_blank" rel="noopener">http://www.cnblogs.com/shenlanzhizun/p/6027042.html</a>  </p>
<h3 id="13-加强了类型推测机制"><a href="#13-加强了类型推测机制" class="headerlink" title="13.加强了类型推测机制"></a>13.加强了类型推测机制</h3><p>JDK1.8 加强了类型推测机制，这种机制可以使得代码更为简洁，假如有如下类的 定义：  </p>
<pre><code>@SuppressWarnings(&quot;all&quot;)
class List&lt;E&gt;{
    public static&lt;Z&gt; List&lt;Z&gt; nil(){
        return null;
    };
    public static&lt;Z&gt; List&lt;Z&gt; cons(Z head,List&lt;Z&gt; tail){
        return null;
    }
    E head(){
        return null;
    }
}

@SuppressWarnings(&quot;all&quot;)
public class TypeSpeculation {
    public static void main(String[] args) {
        //在调用时，可以使用下面的代码： 推荐写法
        List&lt;Integer&gt; list1=List.nil();
        //在 Java7 中，这种写法将会产生编译错误，正确写法如下：
        List&lt;Integer&gt; list2=List.&lt;Integer&gt;nil();
        //同理，在调用 cons 方法时的写法为 推荐写法
        List&lt;Integer&gt; list3=List.cons(5, List.nil()); 
        //而不需要显式地指定类型：
        List&lt;Integer&gt; list4=List.cons(5, List.&lt;Integer&gt;nil());

        Integer s = (Integer) List.nil().head();
        //因此在上面的链式方法调用中，会延迟到整个赋值表达式完成时才进行类型推断。通过赋值语句左边，编译器会为head()调用推断;为String。
        //然后，再次推断nil()调用的为String 。
    }
}</code></pre><h3 id="14-jdk1-8对hashMap等map集合的优化"><a href="#14-jdk1-8对hashMap等map集合的优化" class="headerlink" title="14.jdk1.8对hashMap等map集合的优化"></a>14.jdk1.8对hashMap等map集合的优化</h3><p><strong>hashMap数据结构的优化：</strong><br>原来的hashMap采用的数据结构是<strong>哈希表（数组+链表），</strong> hashMap默认大小是16，一个0-15索引的数组，如何往里面存储元素，首先调用元素的hashcode方法，计算出哈希码值，经过哈希算法算成数组的索引值，如果对应的索引处没有元素，直接存放，如果有对象在，那么比较它们的equals方法比较内容，如果内容一样，后一个value会将前一个value的值覆盖，如果不一样，在1.7的时候，后加的放在前面，形成一个链表，形成了碰撞，在某些情况下如果链表无限下去，那么效率极低，<strong>碰撞是避免不了的。</strong><br>加载因子：0.75，数组扩容，达到总容量的75%，就进行扩容，但是无法避免碰撞的情况发生。<br><strong>在1.8之后，在数组+链表+红黑树</strong>来实现hashmap，当碰撞的元素个数大于8时 &amp; 总容量大于64，会有红黑树的引入。<br>除了添加之后，效率都比链表高，<strong>1.8之后链表新进元素加到末尾。</strong><br><strong>ConcurrentHashMap (锁分段机制)，concurrentLevel，jdk1.8采用CAS算法(无锁算法，不再使用锁分段)，数组+链表中也引入了红黑树的使用。</strong>  </p>
]]></content>
  </entry>
  <entry>
    <title>生产者消费者模式</title>
    <url>/blog/2020/03/20/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。<br>阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者和消费者解耦的。  </p>
<a id="more"></a>  
<img src="/blog/img/2020/03/20/producer-consumer.png">

<p>主要是如何使用wait notify/notifyAll    </p>
<pre><code>//仓库代码 主要处理同步问题
public class Storage {

    private final int MAX_SIZE=100;//仓库最大容量
    private Queue&lt;Object&gt; queue = new LinkedBlockingDeque&lt;&gt;(MAX_SIZE);//产品存储在这里

    //生产num个产品
    public void produce(int num){
        synchronized (queue){
            //一定是while，因为wait被唤醒后需要判断是不是满足生产条件
            while(queue.size()+num&gt;MAX_SIZE){
                System.out.println(&quot;暂时不能执行生产任务&quot;);
                try {
                    queue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //满足生产条件开始生产
            for (int i = 0; i &lt; num; i++) {
                queue.add(new Object());
            }
            System.out.println(&quot;已生产产品数&quot;+num+&quot; 仓库容量&quot;+queue.size());
            queue.notifyAll();
        }
    }

    //消费num个产品
    public void consume(int num){
        synchronized(queue){
            while(queue.size()&lt;num){
                System.out.println(&quot;暂时不能执行消费任务&quot;);
                try {
                    queue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //满足消费条件开始消费
            for (int i = 0; i &lt; num; i++) {
                queue.poll();
            }
            System.out.println(&quot;已消费产品数&quot;+num+&quot; 仓库容量&quot;+queue.size());
            queue.notifyAll();
        }
    }
}</code></pre><p>之后定义生产者消费者线程  </p>
<pre><code>//生产者线程
public class Producer extends Thread {

    private int num;//生产数量
    public Storage storage;//仓库

    public Producer(Storage storage){
        this.storage=storage;
    }

    public void setNum(int num){
        this.num = num;
    }

    public void run() {
        storage.produce(num);
    }
}

//消费者
public class Consumer extends Thread {

    private int num;//生产数量
    public Storage storage;//仓库

    public Consumer(Storage storage){
        this.storage=storage;
    }

    public void setNum(int num){
        this.num = num;
    }

    public void run() {
        storage.consume(num);
    }
}</code></pre><p>主程序 用来开启多个生产者消费者线程执行操作  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
         Storage storage = new Storage();
            Producer p1 = new Producer(storage);
            Producer p2 = new Producer(storage);
            Producer p3 = new Producer(storage);
            Producer p4 = new Producer(storage);
            Producer p5 = new Producer(storage);

            Consumer c1 = new Consumer(storage);
            Consumer c2 = new Consumer(storage);
            Consumer c3 = new Consumer(storage);
            p1.setNum(10);
            p2.setNum(20);
            p3.setNum(10);
            p4.setNum(80);
            p5.setNum(10);
            c1.setNum(50);
            c2.setNum(20);
            c3.setNum(20);
            c1.start();
            c2.start();
            c3.start();
            p1.start();
            p2.start();
            p3.start();
            p4.start();
            p5.start();
    }

}</code></pre><p>输出结果  </p>
<pre><code>暂时不能执行消费任务
已生产产品数80 仓库容量80
已生产产品数10 仓库容量90
已生产产品数10 仓库容量100
暂时不能执行生产任务
暂时不能执行生产任务
已消费产品数20 仓库容量80
已消费产品数20 仓库容量60
已生产产品数10 仓库容量70
已生产产品数20 仓库容量90
已消费产品数50 仓库容量40</code></pre><p>核心的就是每个线程拿到锁之后检测是不是满足条件，不满足则wait释放锁及CPU资源，等待被唤醒之后判断条件满足的话执行生产/消费操作，然后唤醒别的等待的线程，此线程结束。  </p>
<p>参考文章：<a href="https://www.jianshu.com/p/de683751dcef" target="_blank" rel="noopener">https://www.jianshu.com/p/de683751dcef</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>SQL相关面试知识</title>
    <url>/blog/2020/03/18/SQL%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>整理了一些数据库的相关开发规范。  </p>
<a id="more"></a>  
<h1 id="一、数据库sql开发规范（SQL优化）"><a href="#一、数据库sql开发规范（SQL优化）" class="headerlink" title="一、数据库sql开发规范（SQL优化）"></a>一、数据库sql开发规范（SQL优化）</h1><h2 id="1-SELECT子句中避免使用"><a href="#1-SELECT子句中避免使用" class="headerlink" title="1.SELECT子句中避免使用*"></a>1.SELECT子句中避免使用*</h2><blockquote>
<p>在select子句中使用* 号会降低执行效率。使用select * 的时候，数据库在解析过程中会查询数据字段，将* 依次替换成所有的字段名。其次如果新增表字段，程序中存在insert into XXX select * 的话，可能会导致程序运行报错。  </p>
</blockquote>
<h2 id="2-对分区表进行查询时，尽量把分区键作为查询条件的第一个条件"><a href="#2-对分区表进行查询时，尽量把分区键作为查询条件的第一个条件" class="headerlink" title="2.对分区表进行查询时，尽量把分区键作为查询条件的第一个条件"></a>2.对分区表进行查询时，尽量把分区键作为查询条件的第一个条件</h2><h2 id="3-使用group-by替换distinct"><a href="#3-使用group-by替换distinct" class="headerlink" title="3.使用group by替换distinct"></a>3.使用group by替换distinct</h2><blockquote>
<p>1）DISTINCT和GROUP BY都需要进行排序操作，但DISTINCT是要排序整个的查询数据，而GROUP BY是在分组后进行排序。<br>2）做执行计划的时候可以看出DISTINCT的CPU成本是高于GROUP BY的， 但由于GROUP BY会先形成一个内嵌视力再做count， 所以GROUP BY的IO成本高于DISTINCT。当一个表的分组字段不是唯一的但取唯一值时， GROUP BY的执行效率会比DISTINCT高。 当分组字段是唯一值时，GROUP BY的执行效率和DISTINCT一样。  </p>
</blockquote>
<h2 id="4-SQL嵌套层数不能过多"><a href="#4-SQL嵌套层数不能过多" class="headerlink" title="4.SQL嵌套层数不能过多"></a>4.SQL嵌套层数不能过多</h2><blockquote>
<p>SQL嵌套层数过多会影响最优执行计划的生成，执行计划容易变化，最终造成SQL执行效率降低，影响数据库的稳定性。因此规范SQL嵌套层数不宜过多。  </p>
</blockquote>
<h2 id="5-无条件删除表中数据时，用TRUNCATE代替DELETE"><a href="#5-无条件删除表中数据时，用TRUNCATE代替DELETE" class="headerlink" title="5.无条件删除表中数据时，用TRUNCATE代替DELETE"></a>5.无条件删除表中数据时，用TRUNCATE代替DELETE</h2><blockquote>
<p>TRUNCATE清空表数据时，自增长的键会重新从1开始增加。  </p>
</blockquote>
<h2 id="6-用EXISTS替代IN"><a href="#6-用EXISTS替代IN" class="headerlink" title="6.用EXISTS替代IN"></a>6.用EXISTS替代IN</h2><blockquote>
<p>使用exists的执行效率比使用in更高。  </p>
</blockquote>
<h2 id="7-尽可能用UNION-ALL替换UNION"><a href="#7-尽可能用UNION-ALL替换UNION" class="headerlink" title="7.尽可能用UNION ALL替换UNION"></a>7.尽可能用UNION ALL替换UNION</h2><blockquote>
<p>当SQL语句需要UNION两个查询结果集合时，这两个结果集合会以UNION ALL的方式被合并， 然后在输出最终结果前进行排序。<br>如果用UNION ALL替代UNION，就不需排序，提高了查询效率。</p>
</blockquote>
<h2 id="8-避免使用NOT"><a href="#8-避免使用NOT" class="headerlink" title="8.避免使用NOT"></a>8.避免使用NOT</h2><blockquote>
<p>NOT运算符包含在另外一个逻辑运算符中，这就是不等于（&lt;&gt;）运算符。换句话说，即使不在查询WHERE子句中显式地加入NOT词，NOT仍在运算符中。<br>SELECT * FROM EMPLOYEE WHERE SALARY &lt;&gt; 3000;<br>对这个查询，可以改写为不使用NOT：<br>SELECT * FROM EMPLOYEE WHERE SALARY &lt; 3000 OR SALARY &gt; 3000;<br>虽然这两种查询的结果一样，但是第二种查询方案会比第一种查询方案更快些。第二种查询对SALARY列使用索引，而第一种查询则不能使用索引。  </p>
</blockquote>
<h2 id="9-子查询改写成表连接查询"><a href="#9-子查询改写成表连接查询" class="headerlink" title="9.子查询改写成表连接查询"></a>9.子查询改写成表连接查询</h2><blockquote>
<p>通常来说，表关联(left join)的执行效率比子查询更高。<br>但是并不是所有的子查询都可以改写成表关联的方式，只有当表关联的字段存在唯一性时才可以改写，否则重复字段会产生笛卡尔积。  </p>
</blockquote>
<h2 id="10-索引不会包含有NULL值的列"><a href="#10-索引不会包含有NULL值的列" class="headerlink" title="10.索引不会包含有NULL值的列"></a>10.索引不会包含有NULL值的列</h2><blockquote>
<p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。  </p>
</blockquote>
<h2 id="11-使用短索引"><a href="#11-使用短索引" class="headerlink" title="11.使用短索引"></a>11.使用短索引</h2><blockquote>
<p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作  </p>
</blockquote>
<h2 id="12-索引列排序"><a href="#12-索引列排序" class="headerlink" title="12.索引列排序"></a>12.索引列排序</h2><blockquote>
<p>MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。  </p>
</blockquote>
<h2 id="13-like语句操作"><a href="#13-like语句操作" class="headerlink" title="13.like语句操作"></a>13.like语句操作</h2><blockquote>
<p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。  </p>
</blockquote>
<h2 id="14-不要在列上进行运算"><a href="#14-不要在列上进行运算" class="headerlink" title="14.不要在列上进行运算"></a>14.不要在列上进行运算</h2><blockquote>
<p>select * from users where YEAR(adddate)&lt;2007; 将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成 select * from users where adddate&lt;‘2007-01-01’;  </p>
</blockquote>
<h2 id="15-尽量不使用NOT-IN和-lt-gt-操作"><a href="#15-尽量不使用NOT-IN和-lt-gt-操作" class="headerlink" title="15.尽量不使用NOT IN和&lt;&gt;操作"></a>15.尽量不使用NOT IN和&lt;&gt;操作</h2><blockquote>
<p>当有Null空值时，可能会造成查询结果不准确<br>解决办法：<br>    1.使用EXISTS 或 NOT EXISTS 代替<br>    2.用JOIN 代替  </p>
</blockquote>
<h2 id="16-limit-分布优化，先利用ID定位，再分页"><a href="#16-limit-分布优化，先利用ID定位，再分页" class="headerlink" title="16.limit 分布优化，先利用ID定位，再分页"></a>16.limit 分布优化，先利用ID定位，再分页</h2><h2 id="17-or条件优化，多个or条件可以用union-all对结果进行合并（union-all结果可能重复）"><a href="#17-or条件优化，多个or条件可以用union-all对结果进行合并（union-all结果可能重复）" class="headerlink" title="17.or条件优化，多个or条件可以用union all对结果进行合并（union all结果可能重复）"></a>17.or条件优化，多个or条件可以用union all对结果进行合并（union all结果可能重复）</h2><h2 id="18-不必要的排序-见12"><a href="#18-不必要的排序-见12" class="headerlink" title="18.不必要的排序(见12)"></a>18.不必要的排序(见12)</h2><h2 id="19-where代替having-having-检索完所有记录，才进行过滤"><a href="#19-where代替having-having-检索完所有记录，才进行过滤" class="headerlink" title="19.where代替having,having 检索完所有记录，才进行过滤"></a>19.where代替having,having 检索完所有记录，才进行过滤</h2><h2 id="20-对多个字段进行等值查询时，联合索引"><a href="#20-对多个字段进行等值查询时，联合索引" class="headerlink" title="20.对多个字段进行等值查询时，联合索引"></a>20.对多个字段进行等值查询时，联合索引</h2><h1 id="二、数据库建表规范"><a href="#二、数据库建表规范" class="headerlink" title="二、数据库建表规范"></a>二、数据库建表规范</h1><h2 id="1-分区"><a href="#1-分区" class="headerlink" title="1.分区"></a>1.分区</h2><blockquote>
<p>除定量维表外，其他表都需要创建成分区表。  </p>
</blockquote>
<h2 id="2-压缩"><a href="#2-压缩" class="headerlink" title="2.压缩"></a>2.压缩</h2><blockquote>
<p>数据库所有表都需要进行压缩，以减少数据库表空间的使用。<br>ORACLE中设置为压缩表： alter table schema.table_name compress for query high;<br>DB2中设置为压缩表：alter table schema.table_name compress yes;  </p>
</blockquote>
<h2 id="3-GP临时表的创建及使用"><a href="#3-GP临时表的创建及使用" class="headerlink" title="3.GP临时表的创建及使用"></a>3.GP临时表的创建及使用</h2><pre><code>1） 模式
    临时表创建在MASATMP模式下，方便统一管理。
2） 命名
    临时表命名规范： masatmp.tmp_[姓名简称]_[预计清理日期]_[自定义]。
    姓名简称： 如lc
    预计清理日期： 0代表按默认保存周期。 也可自定义清理日期， 如20180930，但保存时间不能超过2个月。
    如： masatmp.tmp_lc_0_lcceshi、masatmp.tmp_lc_20180930_lcceshi。
3） 保存周期
    规范临时表，按指定的保存周期保存。默认保存30天， 自定义的按设定好的保存（设定的保存周期不能超过2个月）。
    不规范临时表仅保留7天；
    在数据库存储资源不足的情况下， 无需确认可全部清空临时表。</code></pre><h1 id="三、常见面试题"><a href="#三、常见面试题" class="headerlink" title="三、常见面试题"></a>三、常见面试题</h1><h2 id="1-事务的四大特性"><a href="#1-事务的四大特性" class="headerlink" title="1.事务的四大特性"></a>1.事务的四大特性</h2><pre><code>原子性，原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。失败回滚的操作事务，将不能对事物有任何影响。

隔离性，隔离性是指当多个用户并发访问数据库时，比如同时访问一张表，数据库每一个用户开启的事务，不能被其他事务所做的操作干扰，多个并发事务之间，应当相互隔离

一致性，事务前后，数据总额一致。一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。  
例如完整性约束a+b=10，一个事务改变了a，那么b也应随之改变。

持久性，持久性是指事务的操作，一旦提交，对于数据库中数据的改变是永久性的，即使数据库发生故障也不能丢失已提交事务所完成的改变。</code></pre><h2 id="2-数据库隔离级别"><a href="#2-数据库隔离级别" class="headerlink" title="2.数据库隔离级别"></a>2.数据库隔离级别</h2><pre><code>1）读未提交（Read Uncommitted）
    读未提交，顾名思义，就是可以读到未提交的内容。
    因此，在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。
    如无特殊情况，基本是不会使用这种隔离级别的。
2）读已提交（Read Committed）
    读已提交，顾名思义，就是只能读到已经提交了的内容。
    这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显示的加锁，如：
    select * from T where ID=2 lock in share mode;
    select * from T where ID=2 for update;
    不然，普通的查询是不会加锁的。
    那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？
    这就要说道另一个机制“快照（snapshot）”，而这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）”
    假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞，这种情况下，并发能力就相当的差。
    而“快照读”就可以完成高并发的查询，不过，“读提交”只能避免“脏读”，并不能避免“不可重复读”和“幻读”。
3）可重复读（Repeated Read）
    可重复读，顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。而它也是MySql的默认隔离级别。  
    在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“修改操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。
4）串行化（Serializable）
    这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。  
    这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。

为什么会出现“脏读”？因为没有“select”操作没有规矩。

为什么会出现“不可重复读”？因为“update”操作没有规矩。

为什么会出现“幻读”？因为“insert”和“delete”操作没有规矩。  </code></pre><p><a href="https://baijiahao.baidu.com/s?id=1611918898724887602&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1611918898724887602&amp;wfr=spider&amp;for=pc</a>  </p>
<h2 id="3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"><a href="#3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景" class="headerlink" title="3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"></a>3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</h2><blockquote>
<p>MYISAM:不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描<br>INNODB:支持外键，行锁，查表总行数时，全表扫描</p>
</blockquote>
<h2 id="4-索引有B-索引和hash索引"><a href="#4-索引有B-索引和hash索引" class="headerlink" title="4.索引有B+索引和hash索引"></a>4.索引有B+索引和hash索引</h2><blockquote>
<p>Hash:hash索引，等值查询效率高，不能排序,不能进行范围查询<br>B+:数据有序,范围查询<br>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。<br>B+ Tree索引和Hash索引区别：哈希索引适合等值查询，但是无法进行范围查询，哈希索引没办法利用索引完成排序，哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。  </p>
</blockquote>
<h2 id="5-聚集索引和非聚集索引"><a href="#5-聚集索引和非聚集索引" class="headerlink" title="5.聚集索引和非聚集索引"></a>5.聚集索引和非聚集索引</h2><blockquote>
<p>聚集索引:数据按索引顺序存储，中子结点存储真实的物理数据<br>非聚集索引:存储指向真正数据行的指针  </p>
</blockquote>
<h2 id="6-索引的优缺点，什么时候使用索引，什么时候不能使用索引"><a href="#6-索引的优缺点，什么时候使用索引，什么时候不能使用索引" class="headerlink" title="6.索引的优缺点，什么时候使用索引，什么时候不能使用索引"></a>6.索引的优缺点，什么时候使用索引，什么时候不能使用索引</h2><blockquote>
<p>索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据。<br>索引最大的好处是提高查询速度，缺点是更新数据时效率低，因为要同时更新索引。对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引。<br>索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些操作的时候，还要操作索引文件，MySQL不仅要保存数据，还要保存一下索引文件。</p>
</blockquote>
<h2 id="7-InnoDB索引和MyISAM索引的区别"><a href="#7-InnoDB索引和MyISAM索引的区别" class="headerlink" title="7.InnoDB索引和MyISAM索引的区别"></a>7.InnoDB索引和MyISAM索引的区别</h2><blockquote>
<p>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。<br>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键  </p>
</blockquote>
<h2 id="8-索引的底层实现（B-树，为何不采用红黑树，B树）重点"><a href="#8-索引的底层实现（B-树，为何不采用红黑树，B树）重点" class="headerlink" title="8.索引的底层实现（B+树，为何不采用红黑树，B树）重点"></a>8.索引的底层实现（B+树，为何不采用红黑树，B树）重点</h2><blockquote>
<p>红黑树:增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间<br>B树也就是B-树:B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。<br>B+树:B+树相比较于另外两种树,显得更矮更宽，查询层次更浅  </p>
</blockquote>
<h2 id="9-B-树的实现"><a href="#9-B-树的实现" class="headerlink" title="9.B+树的实现"></a>9.B+树的实现</h2><pre><code>一个m阶的B+树具有如下几个特征：
1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素</code></pre><h2 id="10-为什么使用B-Tree"><a href="#10-为什么使用B-Tree" class="headerlink" title="10.为什么使用B+Tree"></a>10.为什么使用B+Tree</h2><pre><code>索引查找过程中就要产生磁盘I/O消耗,主要看IO次数，和磁盘存取原理有关。
根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，
将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入
局部性原理与磁盘预读</code></pre><h2 id="11-索引最左前缀问题"><a href="#11-索引最左前缀问题" class="headerlink" title="11.索引最左前缀问题"></a>11.索引最左前缀问题</h2><blockquote>
<p>如果对三个字段建立联合索引，如果第二个字段没有使用索引，第三个字段也使用不到索引了<br>在创建多列索引时，我们根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。  </p>
</blockquote>
<h2 id="12-索引失效条件"><a href="#12-索引失效条件" class="headerlink" title="12.索引失效条件"></a>12.索引失效条件</h2><blockquote>
<p>条件是or,如果还想让or条件生效，给or每个字段加个索引<br>like查询，以%开头<br>内部函数<br>对索引列进行计算<br>is null不会用，is not null 会用  </p>
</blockquote>
<h2 id="13-long-query怎么解决"><a href="#13-long-query怎么解决" class="headerlink" title="13.long_query怎么解决"></a>13.long_query怎么解决</h2><blockquote>
<p>设置参数，开启慢日志功能，得到耗时超过一定时间的sql  </p>
</blockquote>
<h2 id="14-varchar和char的使用场景"><a href="#14-varchar和char的使用场景" class="headerlink" title="14.varchar和char的使用场景"></a>14.varchar和char的使用场景</h2><blockquote>
<p>varchar:字符长度经常变的<br>char:用字符长度固定的  </p>
</blockquote>
<h2 id="15-数据库连接池的作用"><a href="#15-数据库连接池的作用" class="headerlink" title="15.数据库连接池的作用"></a>15.数据库连接池的作用</h2><blockquote>
<p>维护一定数量的连接，减少创建连接的时间<br>更快的响应时间<br>统一的管理  </p>
</blockquote>
<h2 id="16-分库分表，主从复制，读写分离"><a href="#16-分库分表，主从复制，读写分离" class="headerlink" title="16.分库分表，主从复制，读写分离"></a>16.分库分表，主从复制，读写分离</h2><blockquote>
<p>读写分离，读从库，写主库<br>spring配置两个数据库，通过AOP（面向切面编程），在写或读方法前面进行判断得到动态切换数据源。  </p>
</blockquote>
<h2 id="17-数据库三范式"><a href="#17-数据库三范式" class="headerlink" title="17.数据库三范式"></a>17.数据库三范式</h2><pre><code>级别    概念
1NF    属性不可分
2NF    非主键属性，完全依赖于主键属性
3NF    非主键属性无传递依赖</code></pre><h2 id="18-关系型数据库和非关系型数据库区别"><a href="#18-关系型数据库和非关系型数据库区别" class="headerlink" title="18.关系型数据库和非关系型数据库区别"></a>18.关系型数据库和非关系型数据库区别</h2><p><strong>关系型数据库</strong> </p>
<pre><code> 优点

1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；

2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；
3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；
4、支持SQL，可用于复杂的查询。
5.支持事务

缺点
1、为了维护一致性所付出的巨大代价就是其读写性能比较差；
2、固定的表结构；
3、不支持高并发读写需求；
4、不支持海量数据的高效率读写</code></pre><p><strong>非关系型数据库</strong>   </p>
<pre><code>1、使用键值对存储数据；
2、分布式；
优点
无需经过sql层的解析，读写性能很高
基于键值对，数据没有耦合性，容易扩展
存储数据的格式：nosql的存储格式是key,value形式
缺点
不提供sql支持</code></pre><h2 id="19-数据库中join的inner-join-outer-join-cross-join"><a href="#19-数据库中join的inner-join-outer-join-cross-join" class="headerlink" title="19.数据库中join的inner join, outer join, cross join"></a>19.数据库中join的inner join, outer join, cross join</h2><pre><code>1.以A，B两张表为例
A left join B
选出A的所有记录，B表中没有的以null 代替
right join 同理

2.inner join
选出A,B两个表相匹配的行记录

3.cross join (笛卡尔积)
A中的每一条记录和B中的每一条记录生成一条记录
例如A中有4条，B中有4条，cross join 就有16条记录</code></pre><h2 id="20-有哪些锁-select时怎么加排它锁"><a href="#20-有哪些锁-select时怎么加排它锁" class="headerlink" title="20.有哪些锁,select时怎么加排它锁"></a>20.有哪些锁,select时怎么加排它锁</h2><pre><code>锁         概念
乐观锁        自己实现，通过版本号
悲观锁        共享锁，多个事务，只能读不能写，加 lock in share mode
排它锁        一个事务，只能写，for update
行锁        作用于数据行
表锁        作于用表</code></pre><h2 id="21-死锁怎么解决"><a href="#21-死锁怎么解决" class="headerlink" title="21.死锁怎么解决"></a>21.死锁怎么解决</h2><blockquote>
<p>找到进程号，kill 进程  </p>
</blockquote>
<h2 id="22-最左匹配原则"><a href="#22-最左匹配原则" class="headerlink" title="22.最左匹配原则"></a>22.最左匹配原则</h2><pre><code>最左匹配原则是针对索引的
举例来说：两个字段（name,age）建立联合索引，如果where age=12这样的话，是没有利用到索引的，
这里我们可以简单的理解为先是对name字段的值排序，然后对age的数据排序，如果直接查age的话，这时就没有利用到索引了，
查询条件where name=‘xxx’ and age=xx 这时的话，就利用到索引了，再来思考下where age=xx and name=’xxx‘ 这个sql会利用索引吗，
按照正常的原则来讲是不会利用到的，但是优化器会进行优化，把位置交换下。这个sql也能利用到索引了</code></pre>]]></content>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/blog/2020/03/18/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>这里整理一些Linux的常用命令。  </p>
<a id="more"></a>  
<h2 id="1-系统信息"><a href="#1-系统信息" class="headerlink" title="1.系统信息"></a>1.系统信息</h2><pre><code>arch 显示机器的处理器架构
uname -m 显示机器的处理器架构
uname -r 显示正在使用的内核版本 
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) 
hdparm -i /dev/hda 罗列一个磁盘的架构特性 
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 
cat /proc/cpuinfo 显示CPU info的信息 
cat /proc/interrupts 显示中断 
cat /proc/meminfo 校验内存使用 
cat /proc/swaps 显示哪些swap被使用 
cat /proc/version 显示内核的版本 
cat /proc/net/dev 显示网络适配器及统计 
cat /proc/mounts 显示已加载的文件系统 
lspci -tv 罗列 PCI 设备 
lsusb -tv 显示 USB 设备 
date 显示系统日期 
cal 2007 显示2007年的日历表 
date 041217002007.00 设置日期和时间 - 月日时分年.秒 
clock -w 将时间修改保存到 BIOS </code></pre><h2 id="2-关机-系统的关机、重启以及登出"><a href="#2-关机-系统的关机、重启以及登出" class="headerlink" title="2.关机 (系统的关机、重启以及登出 )"></a>2.关机 (系统的关机、重启以及登出 )</h2><pre><code>shutdown -h now 关闭系统  
init 0 关闭系统  
telinit 0 关闭系统  
shutdown -h hours:minutes &amp; 按预定时间关闭系统  
shutdown -c 取消按预定时间关闭系统  
shutdown -r now 重启  
reboot 重启  
logout 注销   </code></pre><h2 id="3-文件和目录"><a href="#3-文件和目录" class="headerlink" title="3.文件和目录"></a>3.文件和目录</h2><pre><code>cd /home 进入 &apos;/ home&apos; 目录&apos;    
cd .. 返回上一级目录  
cd ../.. 返回上两级目录  
cd 进入个人的主目录   
cd ~user1 进入个人的主目录   
cd - 返回上次所在的目录   
pwd 显示工作路径   
ls 查看目录中的文件   
ls -F 查看目录中的文件   
ls -l 显示文件和目录的详细资料(ll也行)   
ls -a 显示隐藏文件  
ls *[0-9]* 显示包含数字的文件名和目录名  
tree 显示文件和目录由根目录开始的树形结构(如果找不到tree命令，yum install tree)   
lstree 显示文件和目录由根目录开始的树形结构  
mkdir dir1 创建一个叫做 &apos;dir1&apos; 的目录&apos;   
mkdir dir1 dir2 同时创建两个目录   
mkdir -p /tmp/dir1/dir2 创建一个目录树  
rm -f file1 删除一个叫做 &apos;file1&apos; 的文件&apos;   
rmdir dir1 删除一个叫做 &apos;dir1&apos; 的目录&apos;   
rm -rf dir1 删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容   
rm -rf dir1 dir2 同时删除两个目录及它们的内容   
mv dir1 new_dir 重命名/移动 一个目录   
cp file1 file2 复制一个文件   
cp dir/* . 复制一个目录下的所有文件到当前工作目录   
cp -a /tmp/dir1 . 复制一个目录到当前工作目录   
cp -a dir1 dir2 复制一个目录   
cp -r dir1 dir2 复制一个目录及子目录  
ln -s file1 lnk1 创建一个指向文件或目录的软链接  
ln file1 lnk1 创建一个指向文件或目录的物理链接   
touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)   
iconv -l 列出已知的编码   </code></pre><p><strong>ps：硬链接和软链接的区别</strong><br>硬链接：是通过文件系统的inode连接来产生新的文件名，而不是产生新文件<br>软链接：类似Windows的快捷方式功能的文件，可以让你快速连接到目标文件（或目录）<br>使用ln如果不加任何参数的话，那么就是hard link。而如果使用-s参数时，就做成差不多是Windows下面的快捷方式的意思，当你修改linux下的symbolic link文件时，则改动的其实是“源文件”，所以无论你的这个源文件被连接到哪里去，只要你修改了连接文件，源文件就跟着变了。  </p>
<h2 id="4-文件搜索"><a href="#4-文件搜索" class="headerlink" title="4.文件搜索"></a>4.文件搜索</h2><pre><code>find / -name file1 从 &apos;/&apos; 开始进入根文件系统搜索文件和目录   
find / -user user1 搜索属于用户 &apos;user1&apos; 的文件和目录  
find /home/user1 -name \*.bin 在目录 &apos;/ home/user1&apos; 中搜索带有&apos;.bin&apos; 结尾的文件   
find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件   
find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件    
find / -name \*.rpm -exec chmod 755 &apos;{}&apos; \; 搜索以 &apos;.rpm&apos; 结尾的文件并定义其权限    
find / -xdev -name \*.rpm 搜索以 &apos;.rpm&apos; 结尾的文件，忽略光驱、捷盘等可移动设备   
locate \*.ps 寻找以 &apos;.ps&apos; 结尾的文件 - 先运行 &apos;updatedb&apos; 命令   
whereis halt 显示一个二进制文件、源码或man的位置   
which halt 显示一个二进制文件或可执行文件的完整路径  </code></pre><h2 id="5-挂载一个文件系统"><a href="#5-挂载一个文件系统" class="headerlink" title="5.挂载一个文件系统"></a>5.挂载一个文件系统</h2><pre><code>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 &apos;/ mnt/hda2&apos; 已经存在   
umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 &apos;/ mnt/hda2&apos; 退出   
fuser -km /mnt/hda2 当设备繁忙时强制卸载   
umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用   
mount /dev/fd0 /mnt/floppy 挂载一个软盘   
mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom   
mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom   
mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom   
mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件   
mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统   
mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备   
mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享   </code></pre><h2 id="6-磁盘空间"><a href="#6-磁盘空间" class="headerlink" title="6.磁盘空间"></a>6.磁盘空间</h2><pre><code>df -h 显示已经挂载的分区列表   
ls -lSr |more 以尺寸大小排列文件和目录   
du -sh dir1 估算目录 &apos;dir1&apos; 已经使用的磁盘空间&apos;   
du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小   
rpm -q -a --qf &apos;%10{SIZE}t%{NAME}n&apos; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)   
dpkg-query -W -f=&apos;${Installed-Size;10}t${Package}n&apos; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)   </code></pre><h2 id="7-用户和群组"><a href="#7-用户和群组" class="headerlink" title="7.用户和群组"></a>7.用户和群组</h2><pre><code>groupadd group_name 创建一个新用户组   
groupdel group_name 删除一个用户组   
groupmod -n new_group_name old_group_name 重命名一个用户组   
useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &quot;admin&quot; 用户组的用户   
useradd user1 创建一个新用户   
userdel -r user1 删除一个用户 ( &apos;-r&apos; 排除主目录)   
usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性   
passwd 修改口令   
passwd user1 修改一个用户的口令 (只允许root执行)   
chage -E 2005-12-31 user1 设置用户口令的失效期限   
pwck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的用户   
grpck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的群组   
newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组  </code></pre><h2 id="8-文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#8-文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="8.文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>8.文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h2><pre><code>ls -lh 显示权限   
ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示   
chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限   
chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限   
chown user1 file1 改变一个文件的所有人属性   
chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性   
chgrp group1 file1 改变文件的群组   
chown user1:group1 file1 改变一个文件的所有人和群组属性   
find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件   
chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限   
chmod u-s /bin/file1 禁用一个二进制文件的 SUID位   
chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的   
chmod g-s /home/public 禁用一个目录的 SGID 位   
chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件   
chmod o-t /home/public 禁用一个目录的 STIKY 位   </code></pre><h2 id="9-文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#9-文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="9.文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>9.文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</h2><pre><code>chattr +a file1 只允许以追加方式读写文件   
chattr +c file1 允许这个文件能被内核自动压缩/解压   
chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件  
chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接   
chattr +s file1 允许一个文件被安全地删除   
chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘   
chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件   
lsattr 显示特殊的属性   </code></pre><h2 id="10-打包和压缩文件"><a href="#10-打包和压缩文件" class="headerlink" title="10.打包和压缩文件"></a>10.打包和压缩文件</h2><pre><code>bunzip2 file1.bz2 解压一个叫做 &apos;file1.bz2&apos;的文件   
bzip2 file1 压缩一个叫做 &apos;file1&apos; 的文件   
gunzip file1.gz 解压一个叫做 &apos;file1.gz&apos;的文件   
gzip file1 压缩一个叫做 &apos;file1&apos;的文件   
gzip -9 file1 最大程度压缩   
rar a file1.rar test_file 创建一个叫做 &apos;file1.rar&apos; 的包   
rar a file1.rar file1 file2 dir1 同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos;   
rar x file1.rar 解压rar包     
unrar x file1.rar 解压rar包   
tar -cvf archive.tar file1 创建一个非压缩的 tarball   
tar -cvf archive.tar file1 file2 dir1 创建一个包含了&apos;file1&apos;, &apos;file2&apos; 以及 &apos;dir1&apos;的档案文件   
tar -tf archive.tar 显示一个包中的内容   
tar -xvf archive.tar 释放一个包   
tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下   
tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包   
tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包   
tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包   
tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包   
zip file1.zip file1 创建一个zip格式的压缩包   
zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包   
unzip file1.zip 解压一个zip格式压缩包    </code></pre><h2 id="11-RPM-包-（Fedora-Redhat及类似系统）"><a href="#11-RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="11.RPM 包 - （Fedora, Redhat及类似系统）"></a>11.RPM 包 - （Fedora, Redhat及类似系统）</h2><pre><code>rpm -ivh package.rpm 安装一个rpm包   
rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告   
rpm -U package.rpm 更新一个rpm包但不改变其配置文件   
rpm -F package.rpm 更新一个确定已经安装的rpm包   
rpm -e package_name.rpm 删除一个rpm包   
rpm -qa 显示系统中所有已经安装的rpm包   
rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包   
rpm -qi package_name 获取一个已安装包的特殊信息   
rpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的rpm包   
rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表   
rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表   
rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表   
rpm -q package_name --whatprovides 显示一个rpm包所占的体积   
rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l   
rpm -q package_name --changelog 显示一个rpm包的修改历史   
rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供   
rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表   
rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书   
rpm --checksig package.rpm 确认一个rpm包的完整性   
rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性   
rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间   
rpm -Va 检查系统中所有已安装的rpm包- 小心使用   
rpm -Vp package.rpm 确认一个rpm包还未安装   
rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件   
rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包   
rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包   </code></pre><h2 id="12-YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#12-YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="12.YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>12.YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h2><pre><code>yum install package_name 下载并安装一个rpm包   
yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系   
yum update package_name.rpm 更新当前系统中所有安装的rpm包   
yum update package_name 更新一个rpm包   
yum remove package_name 删除一个rpm包   
yum list 列出当前系统中安装的所有包   
yum search package_name 在rpm仓库中搜寻软件包   
yum clean packages 清理rpm缓存删除下载的包   
yum clean headers 删除所有头文件   
yum clean all 删除所有缓存的包和头文件    </code></pre><h2 id="13-DEB-包-Debian-Ubuntu-以及类似系统"><a href="#13-DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="13.DEB 包 (Debian, Ubuntu 以及类似系统)"></a>13.DEB 包 (Debian, Ubuntu 以及类似系统)</h2><pre><code>dpkg -i package.deb 安装/更新一个 deb 包   
dpkg -r package_name 从系统删除一个 deb 包   
dpkg -l 显示系统中所有已经安装的 deb 包   
dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包   
dpkg -s package_name 获得已经安装在系统中一个特殊包的信息   
dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表   
dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表   
dpkg -S /bin/ping 确认所给的文件由哪个deb包提供   </code></pre><h2 id="13-APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#13-APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="13.APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>13.APT 软件工具 (Debian, Ubuntu 以及类似系统)</h2><pre><code>apt-get install package_name 安装/更新一个 deb 包   
apt-cdrom install package_name 从光盘安装/更新一个 deb 包   
apt-get update 升级列表中的软件包   
apt-get upgrade 升级所有已安装的软件   
apt-get remove package_name 从系统删除一个deb包   
apt-get check 确认依赖的软件仓库正确   
apt-get clean 从下载的软件包中清理缓存   
apt-cache search searched-package 返回包含所要搜索字符串的软件包名称   </code></pre><h2 id="14-查看文件内容"><a href="#14-查看文件内容" class="headerlink" title="14.查看文件内容"></a>14.查看文件内容</h2><pre><code>cat file1 从第一个字节开始正向查看文件的内容   
tac file1 从最后一行开始反向查看一个文件的内容   
more file1 查看一个长文件的内容   
less file1 类似于 &apos;more&apos; 命令，但是它允许在文件中和正向操作一样的反向操作   
head -2 file1 查看一个文件的前两行   
tail -2 file1 查看一个文件的最后两行   
tail -f /var/log/messages 实时查看被添加到一个文件中的内容  </code></pre><h2 id="15-文本处理"><a href="#15-文本处理" class="headerlink" title="15.文本处理"></a>15.文本处理</h2><pre><code>cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中   
cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中   
grep Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot;   
grep ^Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇    
grep [0-9] /var/log/messages 选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行   
grep Aug -R /var/log/* 在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot;   
sed &apos;s/stringa1/stringa2/g&apos; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot;   
sed &apos;/^$/d&apos; example.txt 从example.txt文件中删除所有空白行   
sed &apos;/ *#/d; /^$/d&apos; example.txt 从example.txt文件中删除所有注释和空白行   
echo &apos;esempio&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos; 合并上下单元格内容   
sed -e &apos;1d&apos; result.txt 从文件example.txt 中排除第一行   
sed -n &apos;/stringa1/p&apos; 查看只包含词汇 &quot;string1&quot;的行   
sed -e &apos;s/ *$//&apos; example.txt 删除每一行最后的空白字符   
sed -e &apos;s/stringa1//g&apos; example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部   
sed -n &apos;1,5p;5q&apos; example.txt 查看从第一行到第5行内容   
sed -n &apos;5p;5q&apos; example.txt 查看第5行   
sed -e &apos;s/00*/0/g&apos; example.txt 用单个零替换多个零   
cat -n file1 标示文件的行数   
cat example.txt | awk &apos;NR%2==1&apos; 删除example.txt文件中的所有偶数行   
echo a b c | awk &apos;{print $1}&apos; 查看一行第一栏   
echo a b c | awk &apos;{print $1,$3}&apos; 查看一行的第一和第三栏   
paste file1 file2 合并两个文件或两栏的内容   
paste -d &apos;+&apos; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分   
sort file1 file2 排序两个文件的内容   
sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)   
sort file1 file2 | uniq -u 删除交集，留下其他的行   
sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)   
comm -1 file1 file2 比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容   
comm -2 file1 file2 比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容   
comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分   </code></pre><h2 id="16-字符设置和文件格式转换"><a href="#16-字符设置和文件格式转换" class="headerlink" title="16.字符设置和文件格式转换"></a>16.字符设置和文件格式转换</h2><pre><code>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX 
unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS 
recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html 
recode -l | more 显示所有允许的转换格式    </code></pre><h2 id="17-文件系统分析"><a href="#17-文件系统分析" class="headerlink" title="17.文件系统分析"></a>17.文件系统分析</h2><pre><code>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 
fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 
fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 
e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 
e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 
fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 
fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 
fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 
dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 </code></pre><h2 id="18-初始化一个文件系统"><a href="#18-初始化一个文件系统" class="headerlink" title="18.初始化一个文件系统"></a>18.初始化一个文件系统</h2><pre><code>mkfs /dev/hda1 在hda1分区创建一个文件系统 
mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 
mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 
mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 
fdformat -n /dev/fd0 格式化一个软盘 
mkswap /dev/hda3 创建一个swap文件系统   </code></pre><h2 id="19-SWAP文件系统"><a href="#19-SWAP文件系统" class="headerlink" title="19.SWAP文件系统"></a>19.SWAP文件系统</h2><pre><code>mkswap /dev/hda3 创建一个swap文件系统 
swapon /dev/hda3 启用一个新的swap文件系统 
swapon /dev/hda2 /dev/hdb3 启用两个swap分区 </code></pre><h2 id="20-备份"><a href="#20-备份" class="headerlink" title="20.备份"></a>20.备份</h2><pre><code>dump -0aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的完整备份 
dump -1aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的交互式备份 
restore -if /tmp/home0.bak 还原一个交互式备份 
rsync -rogpav --delete /home /tmp 同步两边的目录 
rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync 
rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 
rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 
dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr &apos;dd of=hda.gz&apos; 通过ssh在远程主机上执行一次备份本地磁盘的操作 
dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 
tar -Puf backup.tar /home/user 执行一次对 &apos;/home/user&apos; 目录的交互式备份操作 
( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr &apos;cd /home/share/ &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个目录内容 
( tar c /home ) | ssh -C user@ip_addr &apos;cd /home/backup-home &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个本地目录 
tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 
find /home/user1 -name &apos;*.txt&apos; | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 &apos;.txt&apos; 结尾的文件到另一个目录 
find /var/log -name &apos;*.log&apos; | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 &apos;.log&apos; 结尾的文件并做成一个bzip包 
dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 
dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 </code></pre><h2 id="21-光盘"><a href="#21-光盘" class="headerlink" title="21.光盘"></a>21.光盘</h2><pre><code>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 
mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 
mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 
mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 
cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 
gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件 
mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 
cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 
cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3） 
cdrecord --scanbus 扫描总线以识别scsi通道 
dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </code></pre><h2 id="22-网络-（以太网和WIFI无线）"><a href="#22-网络-（以太网和WIFI无线）" class="headerlink" title="22.网络 - （以太网和WIFI无线）"></a>22.网络 - （以太网和WIFI无线）</h2><pre><code>ifconfig eth0 显示一个以太网卡的配置 
ifup eth0 启用一个 &apos;eth0&apos; 网络设备 
ifdown eth0 禁用一个 &apos;eth0&apos; 网络设备 
ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 
ifconfig eth0 promisc 设置 &apos;eth0&apos; 成混杂模式以嗅探数据包 (sniffing) 
dhclient eth0 以dhcp模式启用 &apos;eth0&apos; 
route -n show routing table 
route add -net 0/0 gw IP_Gateway configura default gateway 
route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network &apos;192.168.0.0/16&apos; 
route del 0/0 gw IP_gateway remove static route 
echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward activate ip routing 
hostname show hostname of system 
host www.example.com lookup hostname to resolve name to ip address and viceversa
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa
ip link show show link status of all interfaces 
mii-tool eth0 show link status of &apos;eth0&apos; 
ethtool eth0 show statistics of network card &apos;eth0&apos; 
netstat -tup show all active network connections and their PID 
netstat -tupl show all network services listening on the system and their PID 
tcpdump tcp port 80 show all HTTP traffic 
iwlist scan show wireless networks 
iwconfig eth1 show configuration of a wireless network card 
hostname show hostname 
host www.example.com lookup hostname to resolve name to ip address and viceversa 
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa 
whois www.example.com lookup on Whois database</code></pre><h2 id="23-JPS工具"><a href="#23-JPS工具" class="headerlink" title="23.JPS工具"></a>23.JPS工具</h2><pre><code>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。

    我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。

     使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。

jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path.

$&gt; jps
23991 Jps
23789 BossMain
23651 Resin




比较常用的参数：

-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数
$&gt;  jps -q
28680
23789
23651

-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null

$&gt; jps -m
28715 Jps -m
23789 BossMain
23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log

-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名

$&gt; jps -l
28729 sun.tools.jps.Jps
23789 com.asiainfo.aimc.bossbi.BossMain
23651 com.caucho.server.resin.Resin

-v 输出传递给JVM的参数

$&gt; jps -v
23789 BossMain
28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd

k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m
23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -

Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl

sudo jps看到的进程数量最全

jps 192.168.0.77

列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099

（前提是远程服务器提供jstatd服务）

注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。</code></pre><h2 id="24-其他"><a href="#24-其他" class="headerlink" title="24.其他"></a>24.其他</h2><pre><code>ps -ef| grep java 查看进程</code></pre><p>转自：<a href="https://www.cnblogs.com/yjd_hycf_space/p/7730690.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjd_hycf_space/p/7730690.html</a><br>详细情况请参考sun官方文档。<br><a href="http://java.sun.com/j2se/1.7.0/docs/tooldocs/share/jps.html" target="_blank" rel="noopener">http://java.sun.com/j2se/1.7.0/docs/tooldocs/share/jps.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/blog/2020/03/18/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。  </p>
<a id="more"></a>  
<h2 id="1-内部类的分类"><a href="#1-内部类的分类" class="headerlink" title="1.内部类的分类"></a>1.内部类的分类</h2><ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>静态内部类</li>
<li>匿名内部类</li>
</ul>
<h3 id="1-1-成员内部类"><a href="#1-1-成员内部类" class="headerlink" title="1.1 成员内部类"></a>1.1 成员内部类</h3><p>成员内部类——就是位于外部类成员位置的类<br>特点：可以使用外部类中所有的成员变量和成员方法（包括private的）  </p>
<pre><code>class Outer {
    private int age=20;
    //成员位置
    class Inner{
        public void show(){
            System.out.println(age);
        }
    }
}

public class Test{
    public static void main(String[] args) {
        Outer.Inner oi = new Outer().new Inner();
        oi.show();
    }
}</code></pre><p>使用private修饰成员内部类  </p>
<pre><code>class Outer {
    //private修饰的成员内部类
    private class Inner{
        public void show(){
            System.out.println(&quot;使用private修饰的成员内部类&quot;);
        }
    }
    public Inner getInner(){
        return new Inner();
    }

    public static void main(String[] args) {
        Outer.Inner oi= new Outer().getInner();
        oi.show();
    }
}</code></pre><p>使用static修饰成员内部类，又叫静态内部类，下面会讲。  </p>
<p><strong>成员内部类经典题(填空)</strong><br>请在三个println 后括号中填空使得输出25,20,18  </p>
<pre><code>class Outer {
      public int age = 18;    
      class Inner {
          public int age = 20;    
          public viod showAge() {
              int age  = 25;
              System.out.println(age);//空1
              System.out.println(this.age);//空2
              System.out.println(Outer.this.age);//空3
          }
      }
  }   </code></pre><h3 id="1-2-局部内部类"><a href="#1-2-局部内部类" class="headerlink" title="1.2 局部内部类"></a>1.2 局部内部类</h3><p>局部内部类——就是定义在一个方法或者一个作用域里面的类<br>特点：主要是作用域发生了变化，只能在自身所在方法和属性中被使用   </p>
<pre><code>//在局部位置，可以创建内部类对象，通过对象调用和内部类方法
class Outer {
    private int age=20;

    public void method(){
        final int age2=30;
        class Inner{
            public void show(){
                System.out.println(age);
                //从内部类中访问方法内变量age2，需要将变量声明为最终类型。
                System.out.println(age2);
            }
        }

        Inner i = new Inner();
        i.show();
    }
}

public class Test {
    public static void main(String[] args) {
        Outer o = new Outer();
        o.method();
    }
}</code></pre><p><strong>为什么局部内部类访问局部变量必须加final修饰呢？</strong><br>因为<strong>局部变量是随着方法的调用而调用，使用完毕就消失，而堆内存的数据并不会立即消失。</strong><br>所以，堆内存还是用该变量，而该变量已经没有了。<strong>为了让该值还存在，就加final修饰。</strong><br>原因是，当我们使用final修饰变量后，堆内存直接存储的是值，而<strong>不是变量名。</strong><br>（即上例 age2 的位置存储着常量30 而不是 age2 这个变量名）  </p>
<h3 id="1-3-静态内部类"><a href="#1-3-静态内部类" class="headerlink" title="1.3 静态内部类"></a>1.3 静态内部类</h3><p>我们所知道static是不能用来修饰类的,但是成员内部类可以看做外部类中的一个成员,所以可以用static修饰,这种用static修饰的内部类我们称作静态内部类,也称作嵌套内部类.<br>特点：不能使用外部类的非static成员变量和成员方法  </p>
<pre><code>class Outer {
    int age=10;
    static int age2 = 20;

    static class Inner{
        public void show(){
            //System.out.println(age);错误
            System.out.println(age2);//正确
        }
    }

}

public class Test {
    public static void main(String[] args) {
        Outer.Inner oi = new Outer.Inner();
        oi.show();
    }
}</code></pre><h3 id="1-4-匿名内部类"><a href="#1-4-匿名内部类" class="headerlink" title="1.4 匿名内部类"></a>1.4 匿名内部类</h3><p>一个没有名字的类，是内部类的简化写法  </p>
<pre><code>new 类名或者接口名() {
      重写方法();
}</code></pre><p>本质：其实是继承该类或者实现接口的子类匿名对象<br>这也就是下例中，可以直接使用 new Inner() {}.show(); 的原因 == 子类对象.show();  </p>
<pre><code>interface Inner{
    public void show();
}

class Outer{
    public void method(){
        new Inner() {
            @Override
            public void show() {
                System.out.println(&quot;HelloWorld&quot;);
            }
        }.show();
    }
}

public class Test {
    public static void main(String[] args) {
        Outer o = new Outer();
        o.method();
    }
}</code></pre><p>如果匿名内部类中有多个方法又该如何调用呢？  </p>
<pre><code>class Outer{
    public void method(){
        Inner i = new Inner() {//多态，因为new Inner(){}代表的是接口的子类对象
            @Override
            public void show() {
                System.out.println(&quot;HelloWorld&quot;);
            }
        };
        i.show();
    }
}</code></pre><p><strong>匿名内部类在开发中的使用</strong><br>我们在开发的时候，会看到抽象类，或者接口作为参数。<br>而这个时候，实际需要的是一个子类对象。<br>如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。  </p>
<h2 id="2-内部类的作用"><a href="#2-内部类的作用" class="headerlink" title="2.内部类的作用"></a>2.内部类的作用</h2><h3 id="2-1-实现隐藏（封装性）"><a href="#2-1-实现隐藏（封装性）" class="headerlink" title="2.1 实现隐藏（封装性）"></a>2.1 实现隐藏（封装性）</h3><p>平时我们对类的访问权限，都是通过类前面的访问修饰符来限制的，一般的非内部类，是不允许有 private 与protected权限的，但内部类可以，所以我们能通过内部类来隐藏我们的信息。可以看下面的例子  </p>
<pre><code>public interface Demo{
    void show();
}

class Outer{

    private class Test implements Demo{
        @Override
        public void show() {
            System.out.println(&quot;密码备份文件&quot;);
        }
    }
    public Demo getInner(){
        return new Test();
    }
}</code></pre><p>测试代码  </p>
<pre><code>public class Test {
    public static void main(String[] args) {
        Outer o = new Outer();
        Demo demo=o.getInner();
        demo.show();
    }
}</code></pre><p>运行结果  </p>
<pre><code>密码备份文件</code></pre><p>这样做的好处之一就是，我们可以在这个public方法中增加一些判断语句，起到数据安全的作用。<br>其次呢，我们的对外可见的只是getInner()这个方法，它返回了一个Demo接口的一个实例，如果不看源代码的话，我们真正的内部类的名称就被隐藏起来了。  </p>
<h3 id="2-2-实现多继承-※"><a href="#2-2-实现多继承-※" class="headerlink" title="2.2 实现多继承 ※"></a>2.2 实现多继承 ※</h3><p>我们之前的学习知道，java是不可以实现多继承的，一次只能继承一个类，我们学习接口的时候，有提到可以用接口来实现多继承的效果，即一个接口有多个实现，但是这里也是有一点弊端的，那就是，一旦实现一个接口就必须实现里面的所有方法，有时候就会出现一些累赘，但是使用内部类可以很好的解决这些问题。  </p>
<pre><code>class Demo1{
    public String name(){
        return &quot;BWH_Steven&quot;;
    }
}

class Demo2{
    public String email(){
        return &quot;xxx.@163.com&quot;;
    }
}

public class Test {

    private class test1 extends Demo1{
        public String name() {
            return super.name();
        }
    }
    private class test2 extends Demo2{
        public String email() {
            return super.email();
        }
    }
    public String name(){
        return new test1().name();
    }

    public String email() {
        return new test2().email();
    }

    public static void main(String args[]) {
        Test t = new Test();
        System.out.println(&quot;我的姓名:&quot; + t.name());
        System.out.println(&quot;我的邮箱:&quot; + t.email());
    }
}</code></pre><h3 id="2-3-内部类拥有外围类的所有元素的访问权限-可以实现回调功能"><a href="#2-3-内部类拥有外围类的所有元素的访问权限-可以实现回调功能" class="headerlink" title="2.3 内部类拥有外围类的所有元素的访问权限(可以实现回调功能)"></a>2.3 内部类拥有外围类的所有元素的访问权限(可以实现回调功能)</h3><p>一个类，因为不方便直接修改内部的属性，所以可以通过回调的方式来进行。  </p>
<pre><code>public class Animal {

    private int weight; 

    public int getWeight() {
        return weight;
    }

    public void setWeight(int weight) {
        this.weight = weight;
    }

    public class WeightAdjust{
        public void adjust(int weight){
            setWeight(weight);
        }
    }

    public WeightAdjust getWeightAdjust(){
        return new WeightAdjust();
    }

    public Animal(int weight) {
        this.weight = weight;
    }
}</code></pre><p>下面是回调方法  </p>
<pre><code>public static void main(String[] args) {
    Animal animal = new Animal(15);
    animal.getWeightAdjust().adjust(19);
    System.out.println(animal.getWeight());
}</code></pre><p>上面的代码中，通过利用成员内部类可以持有所寄生的外部类的特性，利用内部类来完成了回调的功能，这种方式在很多代码中都被使用，比如线程，比如集合的比较器。   </p>
<h3 id="2-4-解决继承及实现接口出现同名方法的问题"><a href="#2-4-解决继承及实现接口出现同名方法的问题" class="headerlink" title="2.4 解决继承及实现接口出现同名方法的问题"></a>2.4 解决继承及实现接口出现同名方法的问题</h3><p>大家假想一下如果，你的类要继承一个类，还要实现一个接口，可是你发觉你继承的类和接口里面有两个同名的方法怎么办？你怎么区分它们？？这就需要我们的内部类了。看下面的代码   </p>
<pre><code>public interface Demo {
   public void test();
}

public class MyDemo{
    public void test(){
        System.out.println(&quot;父类的test方法&quot;);
    }
}

public class Test extends MyDemo implements Demo{
     public void test() {

     }
}</code></pre><p>这样的话我就有点懵了，这样如何区分这个方法是接口的还是继承的，所以我们使用内部类解决这个问题  </p>
<pre><code>public interface Demo {
   public void test();
}

public class MyDemo{
    public void test(){
        System.out.println(&quot;父类的test方法&quot;);
    }
}

public class Test extends MyDemo{

    private class Inner implements Demo{
        @Override
        public void test() {
            System.out.println(&quot;接口的test方法&quot;);
        }
    }

    public Inner getInner(){
        return new Inner();
    }

    public static void main(String[] args) {
        //调用接口而来的test()方法
        Test t = new Test();
        Demo d = t.getInner();
        d.test();

        //调用继承而来的test()方法
        t.test();
    }
}</code></pre><p>运行结果  </p>
<pre><code>接口的test方法
父类的test方法</code></pre><h2 id="3-参考文章"><a href="#3-参考文章" class="headerlink" title="3.参考文章"></a>3.参考文章</h2><p><a href="https://www.cnblogs.com/HHR-SUN/p/11699273.html" target="_blank" rel="noopener">https://www.cnblogs.com/HHR-SUN/p/11699273.html</a><br><a href="https://www.cnblogs.com/uu5666/p/8185061.html" target="_blank" rel="noopener">https://www.cnblogs.com/uu5666/p/8185061.html</a><br><a href="https://blog.csdn.net/ziwen00/article/details/8838841" target="_blank" rel="noopener">https://blog.csdn.net/ziwen00/article/details/8838841</a>    </p>
]]></content>
  </entry>
  <entry>
    <title>HashMap为什么会导致CPU100%?</title>
    <url>/blog/2020/03/18/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BC%E8%87%B4CPU100/</url>
    <content><![CDATA[<p>这个问题相关的知识点，有以下几个：<br>1.HashMap 的底层数据结构是什么？<br>2.什么是哈希碰撞？如何该解决这个问题？<br>3.什么是扩展因子？它有什么用？<br>4.还有对HashMap源码的理解，为什么HashMap会导致死循环？  </p>
<a id="more"></a>  
<h2 id="1-HashMap-的底层数据结构"><a href="#1-HashMap-的底层数据结构" class="headerlink" title="1.HashMap 的底层数据结构"></a>1.HashMap 的底层数据结构</h2><p>先来说 HashMap 的底层数据结构，看过 HashMap 的源码我们就会发现，JDK 1.7 和 JDK 1.8 HashMap 的组成是不同的，JDK 1.7 HashMap 的组成是数组 + 链表的形式，而 JDK 1.8 新增了红黑树的数据结构，当 HashMap 中的链表长度大于 8 时，链表结构就会转换为红黑树，如下图所示：<br><img src="/blog/img/2020/03/18/HashMap底层数据结构.png"><br></p>
<h2 id="2-哈希碰撞及解决方案"><a href="#2-哈希碰撞及解决方案" class="headerlink" title="2.哈希碰撞及解决方案"></a>2.哈希碰撞及解决方案</h2><p>所谓的<strong>哈希碰撞指的是不同的值，经过哈希之后得到的值确是相同的，这种情况就叫做哈希碰撞或哈希冲突。</strong> 解决哈希碰撞的常用方法是：<strong>开放定址法和链表地址法</strong> ，而<strong>HashMap 采用的就是链表地址法。</strong> 它的<strong>实现原理就是将 HashMap 中相同的哈希值以链表的形式存储起来。</strong>  </p>
<h2 id="3-扩展因子（负载因子）"><a href="#3-扩展因子（负载因子）" class="headerlink" title="3.扩展因子（负载因子）"></a>3.扩展因子（负载因子）</h2><p>既然哈希表是基于数组实现的，那么哈希表也要涉及扩容问题。<br>当经过多次元素插入，哈希表达到一定饱和度时，Key映射位置发生冲突的概率会逐渐增高。这样一来，大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大的影响。<br>这时，哈希表就需要扩展它的长度，也就是进行扩容。 对于JDK中的哈希表实现类HashMap来说，影响其扩容的因素有两个。  </p>
<ul>
<li>Capacity，即HashMap的当前长度。  </li>
<li>LoadFactor，即HashMap的负载因子，默认值为0.75f。<br>衡量HashMap需要进行扩容的条件如下：   </li>
</ul>
<p><strong>HashMap.Size&gt;=Capacity*LoadFactory</strong><br><img src="/blog/img/2020/03/18/加载因子.png"><br><br><strong>那么散列表的扩容具体做了什么操作呢？</strong><br>1.扩容，创建一个新的Entry空数组，长度是原数组的2倍。<br>2.重新Hash，遍历原Entry数组，把所有的Entry重新Hash到新数组找中（长度扩大，Hash的规则也随之改动）。  </p>
<h2 id="4-HashMap死循环分析"><a href="#4-HashMap死循环分析" class="headerlink" title="4.HashMap死循环分析"></a>4.HashMap死循环分析</h2><p>HashMap 导致 CPU 100% 的原因就是因为 HashMap 死循环导致的，那 HashMap 是如何造成死循环的？接下来我们一起来看。  </p>
<p>以 JDK 1.7 为例，假设 HashMap 的默认大小为 2，HashMap 本身中有一个键值 key(5)，我们再使用两个线程：t1 添加 key(3)，t2 添加 key(7)，首先两个线程先把 key(3) 和 key(7) 都添加到 HashMap 中，此时因为 HashMap 的长度不够用了就会进行扩容操作，然后这时线程 t1 在执行到 Entry&lt;K,V&gt; next = e.next; 时，交出了 CPU 的使用权，源代码如下：  </p>
<pre><code>void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    for (Entry&lt;K,V&gt; e : table) {
        while(null != e) {
            Entry&lt;K,V&gt; next = e.next; // 线程一执行此处
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
}</code></pre><p>那么此时线程 t1 中的 e 指向了 key(3)，而 next 指向了 key(7) ；之后线程 t2 重新 rehash 之后链表的顺序被反转，链表的位置变成了 key(5) -&gt; key(7) -&gt; key(3)，其中 “-&gt;” 用来表示下一个元素，当 t1 重新获得执行权之后，先执行 newTalbe[i] = e 把 key(3) 的 next 设置为 key(7)，而下次循环时查询到 key(7) 的 e.next 为 key(3)，于是就形 成了 key(3) 和 key(7) 的环形引用，就导致了死循环的产生，如下图所示：<br><img src="/blog/img/2020/03/18/死循环.jpg"><br><br>HashMap 发生死循环的一个重要原因是 JDK 1.7 时链表的插入是首部倒序插入的（头插法，会引起死循环），而 JDK 1.8 时已经变成了尾部插入（JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题），有人把这个死循环的问题反馈给了 Sun 公司，但它们认为这不是一个问题，因为 HashMap 本身就是非线程安全的，如果要在多线程使用建议使用 ConcurrentHashMap 替代 HashMap。  </p>
]]></content>
  </entry>
  <entry>
    <title>JAVA多线程实现的3种方式</title>
    <url>/blog/2020/03/17/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>Java中线程的实现有三种方式，分别是<strong>继承Thread类、实现Runnable接口和实现Callable接口。</strong>  </p>
<a id="more"></a>  
<h3 id="1-继承Thread类，重写Run方法"><a href="#1-继承Thread类，重写Run方法" class="headerlink" title="1.继承Thread类，重写Run方法"></a>1.继承Thread类，重写Run方法</h3><pre><code>public class ThreadTest{
    public static void main(String[] args) {
        Thread1 thread1 = new Thread1();//创建实例
        thread1.start();//启动线程
    }
}

class Thread1 extends Thread{
    @Override
    public void run() {
        //具体业务操作
    }
}</code></pre><h3 id="2-实现Runnable接口，重写Run方法"><a href="#2-实现Runnable接口，重写Run方法" class="headerlink" title="2.实现Runnable接口，重写Run方法"></a>2.实现Runnable接口，重写Run方法</h3><pre><code>public class ThreadTest{
    public static void main(String[] args) {
        new Thread(new MyRunnable()).start();
    }
}

class MyRunnable implements Runnable{
    @Override
    public void run() {
        //具体业务操作
    }
}</code></pre><p>其实不管是通过继承Thread类还是通过实现Runable接口来实现线程，最终都是通过Thread类的对象的API来控制线程（代理设计模式）。<br>Thread类本质上也是实现了Runnable接口，启动线程的唯一方法就是通过Thread类的start()方法。start()方法是一个native（本地）方法，它将启动一个新线程，并执行run()方法（Thread类中提供的run()方法是一个空方法）。  </p>
<h3 id="3-实现Callable接口，重写call-方法"><a href="#3-实现Callable接口，重写call-方法" class="headerlink" title="3.实现Callable接口，重写call()方法"></a>3.实现Callable接口，重写call()方法</h3><p>Callable接口与Runnable接口的功能类似，但提供了比Runnable更强大的功能，主要表现为以下三点：<br>（1）Callable可以在任务结束后提供一个返回值，Runnable无法提供这个功能；<br>（2）Callable接口中的call()方法可以抛出异常，而Runnable的run()方法不能抛出异常，必须在run()捕获；<br>（3）运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，它提供了检查计算是否完成的方法。由于线程属于异步计算模型，因此无法从别的线程中得到函数的返回值，在这种情况下，就可以使用Future来监视目标线程调用call()方法的情况，当调用Future的get方法以获取结果时，当前线程就会阻塞，直到call()方法结束返回结果。  </p>
<p>使用Callable接口实现线程的步骤如下：  </p>
<p>（1）自定义类实现Callable接口，并实现该接口的call()方法；<br>（2）创建实现Callable接口的自定义类对象；<br>（3）创建执行服务；<br>（4）提交执行；<br>（5）获取结果；<br>（6）关闭服务。  </p>
<pre><code>public class ThreadTest{
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        //创建目标对象
        MyCallable mc1 = new MyCallable();
        //创建执行服务
        ExecutorService service = Executors.newFixedThreadPool(2);
        //提交执行
        Future&lt;String&gt; result = service.submit(mc1);
        //获取结果
        String r = result.get();
        //关闭服务
        service.shutdownNow();

        System.out.println(&quot;执行结果：&quot;+r);
    }
}

class MyCallable implements Callable&lt;String&gt;{
    @Override
    public String call() throws Exception {
        //具体业务操作
        //···
        return &quot;成功&quot;;
    }
}</code></pre><p>输出结果  </p>
<pre><code>执行结果：成功</code></pre>]]></content>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/blog/2020/03/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>在了解线程池之前，首先我们先了解一下，什么是进程？什么是线程？  </p>
<a id="more"></a>
<h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h2><p>进程是计算机中的程序关于某数据集合的一次运行活动，是系统进行资源分配的调度的基本单位，是操作系统结构的基础。简单来讲：进程是指运行中的应用程序，进程是一个实体，每一个进程都有它自己的地址空间。例如我们点击了QQ，就启动了一个进程，操作系统就会为这个进程分配独立的地址空间，当我们又点击浏览器，这样又启动了一个进程，操作系统将为新的进程分配新的独立的地址空间。  </p>
<h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h2><p>线程是操作系统能够进行运算调度的最小单位，被包含在进程之中，是进程中的实际运作单位。一个进程至少有一个线程。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。注意：线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属于一个进程的其他线程共享进程所拥有的全部资源，线程有就绪，阻塞，运行三种基本状态。  </p>
<h2 id="3-什么是线程池？"><a href="#3-什么是线程池？" class="headerlink" title="3.什么是线程池？"></a>3.什么是线程池？</h2><p>线程池就是创建多个线程并且进行管理的容器。（线程池是个容器，可以创建线程和管理线程，并且给线程分配任务）。<br>线程池是一种多线程处理形式，处理过程中将任务添加队列，然后在创建线程后自动启动这些任务，每个线程都使用默认的堆栈大小，以默认的优先级运行，并处在多线程单元中，如果某个线程在托管代码中空闲，则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后辅助线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才能启动。  </p>
<h2 id="4-为什么要用线程池？"><a href="#4-为什么要用线程池？" class="headerlink" title="4.为什么要用线程池？"></a>4.为什么要用线程池？</h2><p>我们都知道，在Java中创建一个线程其实是一个很简单的事情，只要new Thread就可以了，但是这样做并不是一种很好的方式。那么为什么不好呢？<br>比如在一个项目里，全部都是用的new Thread的方式去启用线程，那么创建好Thread1，而1在运行的时候，创建了Thread2，等等等… 创建了10个线程的时候，1，2，3都执行完毕了但是没被销毁，就可能导致<strong>无限制的新建线程，相互竞争，占用过多的系统资源，导致死锁以及OOM。</strong> 而且这些线程缺乏统一的<strong>管理的功能，也缺乏定期执行，定时执行，线程中断的功能。</strong>  </p>
<h2 id="5-如何创建一个线程池？"><a href="#5-如何创建一个线程池？" class="headerlink" title="5.如何创建一个线程池？"></a>5.如何创建一个线程池？</h2><p><strong>5.1 ThreadPoolExecutor 的构造方法如下</strong>  </p>
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize &lt; 0 ||
        //maximumPoolSize必须&gt;=1 &amp; corePoolSize(第1处)
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    //（第2处）
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}    </code></pre><p><strong>5.2 第1个参数: corePoolSize 表示常驻核心线程数</strong>  </p>
<pre><code>如果等于0,则任务执行完之后,没有任何请求进入时销毁线程池的线程;
如果大于0,即使本地任务执行完毕,核心线程也不会被销毁.
这个值的设置非常关键;
设置过大会浪费资源;
设置过小会导致线程频繁地创建或销毁.</code></pre><p><strong>5.3 第2个参数: maximumPoolSize 表示线程池能够容纳同时执行的最大线程数</strong>  </p>
<pre><code>从第1处来看,必须&gt;=1.
如果待执行的线程数大于此值,需要借助第5个参数的帮助,缓存在队列中.
如果maximumPoolSize = corePoolSize,即是固定大小线程池.</code></pre><p><strong>5.4 第3个参数: keepAliveTime 表示线程池中的线程空闲时间</strong>  </p>
<pre><code>当空闲时间达到keepAliveTime时,线程会被销毁,直到只剩下corePoolSize个线程;
避免浪费内存和句柄资源.
在默认情况下,当线程池的线程数大于corePoolSize时,keepAliveTime才起作用.
但是当ThreadPoolExecutor的allowCoreThreadTimeOut = true时,核心线程超时后也会被回收.</code></pre><p><strong>5.5 第4个参数: TimeUnit表示时间单位</strong>  </p>
<pre><code>keepAliveTime的时间单位通常是TimeUnit.SECONDS.</code></pre><p><strong>5.6 第5个参数: workQueue 表示缓存队列</strong>  </p>
<pre><code>当请求的线程数大于maximumPoolSize时,线程进入BlockingQueue.
后续示例代码中使用的LinkedBlockingQueue是单向链表,使用锁来控制入队和出队的原子性;
两个锁分别控制元素的添加和获取,是一个生产消费模型队列.</code></pre><p><strong>5.7 第6个参数: threadFactory 表示线程工厂</strong>  </p>
<pre><code>它用来生产一组相同任务的线程;
线程池的命名是通过给这个factory增加组名前缀来实现的.
在虚拟机栈分析时,就可以知道线程任务是由哪个线程工厂产生的.</code></pre><p><strong>5.8 第7个参数: handler 表示执行拒绝策略的对象</strong>  </p>
<pre><code>当超过第5个参数workQueue的任务缓存区上限的时候,就可以通过该策略处理请求,这是一种简单的限流保护.
友好的拒绝策略可以是如下三种:
(1)保存到数据库进行削峰填谷;在空闲时再提取出来执行
(2)转向某个提示页面
(3)打印日志</code></pre><h2 id="6-JAVA中的常用线程池有哪些？作用分别是什么"><a href="#6-JAVA中的常用线程池有哪些？作用分别是什么" class="headerlink" title="6.JAVA中的常用线程池有哪些？作用分别是什么?"></a>6.JAVA中的常用线程池有哪些？作用分别是什么?</h2><p>java里面的线程池的顶级接口是Executor，Executor并不是一个线程池，而只是一个执行线程的工具，而真正的线程池是ExecutorService。<br><strong>6.1 newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</strong><br>是一种线程数量不定的线程池，并且其最大线程数（maximumPoolSize）为Integer.MAX_VALUE，这个数是很大的，一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。但是线程池中的空闲线程都有超时限制，这个超时时长是60秒，超过60秒闲置线程就会被回收。调用execute将重用以前构造的线程(如果线程可用)。这类线程池比较适合执行大量的耗时较少的任务，当整个线程池都处于闲置状态时，线程池中的线程都会超时被停止。  </p>
<pre><code>public static void newCachedThreadPool(){
    ExecutorService cacheThreadPool = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; 10; i++) {
        try {
            Thread.sleep(1000);
        } catch (Exception e) {
            e.printStackTrace();
        }
        //cacheThreadPool.submit(task); 有返回值
        cacheThreadPool.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;正在被执行&quot;);
            }
        });
    }
}</code></pre><p>输出结果  </p>
<pre><code>pool-1-thread-1正在被执行
pool-1-thread-1正在被执行
pool-1-thread-1正在被执行
pool-1-thread-1正在被执行
pool-1-thread-1正在被执行
pool-1-thread-1正在被执行
pool-1-thread-1正在被执行
pool-1-thread-1正在被执行
pool-1-thread-1正在被执行
pool-1-thread-1正在被执行</code></pre><p>线程池为无限大，当执行当前任务时上一个任务已经完成，会复用执行上一个任务的线程，而不用每次新建线程。  </p>
<p><strong>6.2 newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</strong><br>创建一个指定工作线程数量的线程池，每当提交一个任务就创建一个工作线程，当线程 处于空闲状态时，它们并不会被回收，除非线程池被关闭了，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列（没有大小限制）中。由于newFixedThreadPool只有核心线程并且这些核心线程不会被回收，这样它能更加快速的响应外界的请求。  </p>
<pre><code>public static void newFixedThreadPool(){
    //创建一个可重用固定个数的线程池
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
    for (int i = 0; i &lt; 10; i++) {
        try {
            Thread.sleep(2000);
        } catch (Exception e) {
            e.printStackTrace();
        }
        fixedThreadPool.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;正在被执行&quot;);
            }
        });
    }
}</code></pre><p>输出结果  </p>
<pre><code>pool-1-thread-1正在被执行
pool-1-thread-2正在被执行
pool-1-thread-3正在被执行
pool-1-thread-1正在被执行
pool-1-thread-2正在被执行
pool-1-thread-3正在被执行
pool-1-thread-1正在被执行
pool-1-thread-2正在被执行
pool-1-thread-3正在被执行
pool-1-thread-1正在被执行</code></pre><p>因为线程池大小为3，每个任务输出打印结果后sleep 2秒，所以每两秒打印3个结果。<br>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()  </p>
<p><strong>6.3 newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。</strong><br>创建一个线程池，它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收，它可安排给定延迟后运行命令或者定期地执行。这类线程池主要用于执行定时任务和具有固定周期的重复任务。  </p>
<pre><code>public static void newScheduledThreadPool(){
    //创建一个定长线程池，支持定时及周期性任务执行
    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
    //延迟执行——延迟1秒执行
    scheduledThreadPool.schedule(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;延迟1秒执行&quot;);
        }
    }, 1, TimeUnit.SECONDS);
    //定期执行——延迟1秒后每3秒执行一次
    scheduledThreadPool.scheduleAtFixedRate(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;延迟1秒后每3秒执行一次&quot;);
        }
    }, 1,3, TimeUnit.SECONDS);
}</code></pre><p>输出结果  </p>
<pre><code>延迟1秒执行
延迟1秒后每3秒执行一次
延迟1秒后每3秒执行一次
延迟1秒后每3秒执行一次
延迟1秒后每3秒执行一次
延迟1秒后每3秒执行一次
......</code></pre><p><strong>6.4 newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</strong><br>这类线程池内部只有一个核心线程，以无界队列方式来执行该线程，这使得这些任务之间不需要处理线程同步的问题，它确保所有的任务都在同一个线程中按顺序中执行，并且可以在任意给定的时间不会有多个线程是活动的。  </p>
<pre><code>public static void newSingleThreadExecutor(){
    //创建一个单线程化的线程池
    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
    for (int i = 0; i &lt; 10; i++) {
        final int index = i;
        singleThreadExecutor.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    //结果依次输出，相当于顺序执行
                    System.out.println(Thread.currentThread().getName()+&quot;正在被执行,打印的值是:&quot;+index);
                    Thread.sleep(1000);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
    }
}</code></pre><p>输出结果  </p>
<pre><code>pool-1-thread-1正在被执行,打印的值是:0
pool-1-thread-1正在被执行,打印的值是:1
pool-1-thread-1正在被执行,打印的值是:2
pool-1-thread-1正在被执行,打印的值是:3
pool-1-thread-1正在被执行,打印的值是:4
pool-1-thread-1正在被执行,打印的值是:5
pool-1-thread-1正在被执行,打印的值是:6
pool-1-thread-1正在被执行,打印的值是:7
pool-1-thread-1正在被执行,打印的值是:8
pool-1-thread-1正在被执行,打印的值是:9</code></pre><p><strong>6.5 newWorkStealingPool创建一个具有抢占式操作的线程池。</strong><br>这个是 JDK1.8 版本加入的一种线程池，stealing 翻译为抢断、窃取的意思。<br>newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中：    </p>
<pre><code> // 线程数
private static final int threads = 10;
 // 用于计数线程是否执行完成
static CountDownLatch countDownLatch = new CountDownLatch(threads);

public static void newWorkStealingPool(){
    //创建一个抢占式的线程池
    System.out.println(&quot;---- start ----&quot;);
    ExecutorService executorService = Executors.newWorkStealingPool(5);
    for (int i = 0; i &lt; threads; i++) {
        executorService.execute(() -&gt; {
            try {
                System.out.println(Thread.currentThread().getName());
            } catch (Exception e) {
                System.out.println(e);
            } finally {
                countDownLatch.countDown();
            }
        });
    }
    try {
        countDownLatch.await();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;---- end ----&quot;);
}   </code></pre><p>输出结果  </p>
<pre><code>---- start ----
ForkJoinPool-1-worker-2
ForkJoinPool-1-worker-1
ForkJoinPool-1-worker-1
ForkJoinPool-1-worker-1
ForkJoinPool-1-worker-3
ForkJoinPool-1-worker-2
ForkJoinPool-1-worker-1
ForkJoinPool-1-worker-4
ForkJoinPool-1-worker-2
ForkJoinPool-1-worker-3
---- end ----</code></pre><p>来看看newWorkStealingPool的构造函数：  </p>
<pre><code>/**
    * Creates a thread pool that maintains enough threads to support
    * the given parallelism level, and may use multiple queues to
    * reduce contention. The parallelism level corresponds to the
    * maximum number of threads actively engaged in, or available to
    * engage in, task processing. The actual number of threads may
    * grow and shrink dynamically. A work-stealing pool makes no
    * guarantees about the order in which submitted tasks are
    * executed.
    *
    * @param parallelism the targeted parallelism level
    * @return the newly created thread pool
    * @throws IllegalArgumentException if {@code parallelism &lt;= 0}
    * @since 1.8
*/
public static ExecutorService newWorkStealingPool(int parallelism) {
    return new ForkJoinPool(parallelism,
        ForkJoinPool.defaultForkJoinWorkerThreadFactory,
        null, true);
}</code></pre><p>从上面代码的介绍，最明显的用意就是它是一个并行的线程池，参数中传入的是一个线程并发的数量，这里和之前就有很明显的区别，前面4种线程池都有核心线程数、最大线程数等等，而这就使用了一个并发线程数解决问题。从介绍中，还说明这个线程池不会保证任务的顺序执行，也就是 WorkStealing 的意思，抢占式的工作。  </p>
<p>如下图，任务的执行是无序的，哪个线程抢到任务，就由它执行：<br><img src="/blog/img/2020/03/17/抢占式线程池.jpg"><br> </p>
<h2 id="7-使用线程池的优点"><a href="#7-使用线程池的优点" class="headerlink" title="7.使用线程池的优点"></a>7.使用线程池的优点</h2><p>1.重用线程池的线程，避免因为线程的创建和销毁锁带来的性能开销。<br>2.有效控制线程池的最大并发数，避免大量的线程之间因抢占系统资源而阻塞。<br>3.能够对线程进行简单的管理，并提供一下特定的操作如：可以提供定时、定期、单线程、并发数控制等功能。   </p>
<p><strong>PS:在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。</strong>  </p>
<h2 id="8-参考文章"><a href="#8-参考文章" class="headerlink" title="8.参考文章"></a>8.参考文章</h2><p><a href="https://blog.csdn.net/hnd978142833/article/details/80253784" target="_blank" rel="noopener">https://blog.csdn.net/hnd978142833/article/details/80253784</a><br><a href="https://blog.csdn.net/tjbsl/article/details/98480843" target="_blank" rel="noopener">https://blog.csdn.net/tjbsl/article/details/98480843</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>JAVA面试题整理</title>
    <url>/blog/2020/03/15/JAVA%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-说说你的项目，用了-SpringCloud-哪些功能？"><a href="#1-说说你的项目，用了-SpringCloud-哪些功能？" class="headerlink" title="1.说说你的项目，用了 SpringCloud 哪些功能？"></a>1.说说你的项目，用了 SpringCloud 哪些功能？</h2><a id="more"></a>  
<blockquote>
<p><strong>基础功能：</strong><br>&emsp;&emsp;服务治理(服务注册与发现:Eureka、consul、zookeeper)<br>&emsp;&emsp;客户端负载均衡（Spring Cloud Ribbon）<br>&emsp;&emsp;服务容错保护(熔断器Spring Cloud Hystrix)<br>&emsp;&emsp;声名式服务调用(Feign实现声明式Rest调用)<br>&emsp;&emsp;API网关服务(Spring Cloud Zuul)<br>&emsp;&emsp;分布式配置中心(Spring Cloud Config)<br><strong>高级功能：</strong><br>&emsp;&emsp;消息总线： Spring  Cloud Bus<br>&emsp;&emsp;消息驱动的微服务： Spring Cloud Stream<br>&emsp;&emsp;分布式服务跟踪： Spring  Cloud Sleuth  </p>
</blockquote>
<h2 id="2-谈谈服务治理"><a href="#2-谈谈服务治理" class="headerlink" title="2.谈谈服务治理"></a>2.谈谈服务治理</h2><blockquote>
<p><a href="https://blog.csdn.net/fly910905/article/details/100023415" target="_blank" rel="noopener">https://blog.csdn.net/fly910905/article/details/100023415</a>  </p>
</blockquote>
<h2 id="3-熟悉-Mysql-吗？说说索引"><a href="#3-熟悉-Mysql-吗？说说索引" class="headerlink" title="3.熟悉 Mysql 吗？说说索引"></a>3.熟悉 Mysql 吗？说说索引</h2><details>
<summary><mark><font color="darkred">点击查看详细内容</font></mark></summary>

<blockquote>
<p><strong>什么是索引吗？：</strong>索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据。<br><strong>那么索引具体采用的哪种数据结构呢？</strong><br>&emsp;&emsp;常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树。<br><strong>既然你提到InnoDB使用的B+ Tree的索引模型，那么你知道为什么采用B+ 树吗？这和Hash索引比较起来有什么优缺点吗？</strong><br>&emsp;&emsp;因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。<br>&emsp;&emsp;B+ Tree索引和Hash索引区别：哈希索引适合等值查询，但是无法进行范围查询，哈希索引没办法利用索引完成排序，哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。<br><strong>常用的索引有：</strong><br>&emsp;&emsp;<strong>主键索引：</strong>primary key, 是特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字PRIMARY KEY创建，不允许重复，不允许为空。<br>&emsp;&emsp;<strong>唯一索引：</strong>unique，创建索引的列的值唯一，允许为空。<br>&emsp;&emsp;<strong>普通索引：</strong>index，它的唯一任务就是加快对数据的访问速度普通索引允许被索引的数据列包含重复的值，如果能确定某个数据列将只包含彼此间各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE将它定义为唯一索引。<br>&emsp;&emsp;索引可以覆盖多个数据列，像INDEX（columnA，columnB)索引，就是联合索引，<br>&emsp;&emsp;索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些操作的时候，还要操作索引文件，MySQL不仅要保存数据，还要保存一下索引文件。<br><strong>聚簇索引、覆盖索引</strong><br><strong>刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？</strong><br>&emsp;&emsp;InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值。<br><strong>那这两者有什么区别吗？</strong><br>&emsp;&emsp;在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的记录，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储相应行数据的聚集索引键（即主键），并不包含行记录的全部数据，被称之为非聚簇索引(辅助索引)，当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。<br><strong>那么，聚簇索引和非聚簇索引，在查询数据的时候有区别吗？</strong><br>&emsp;&emsp;我：聚簇索引查询会更快？ 面试官：为什么呢？ 我：因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询。<br><strong>刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做回表）是所有情况都是这样的吗？非主键索引一定会查询多次吗？</strong><br>&emsp;&emsp;我：（额、这个问题我回答的不好，后来我自己查资料才知道，通过覆盖索引也可以只查询一次）<br>&emsp;&emsp;覆盖索引：覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。<br><strong>联合索引、最左前缀匹配</strong><br><strong>你们在创建索引的时候都会考虑哪些因素呢？</strong><br>&emsp;&emsp;我们一般对于查询概率比较高，经常作为where条件的字段设置索引。<br><strong>那你们有用过联合索引吗？那你们在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？</strong><br>&emsp;&emsp;我们把识别度最高的字段放到最前面（where子句中使用最频繁的一列放在最左边）。<br><strong>为什么这么做呢？（这里要考的是最左前缀匹配）</strong><br>&emsp;&emsp;在创建多列索引时，我们根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。<br><strong>索引下推、查询优化</strong><br><strong>你们线上用的MySQL是哪个版本啊呢？（我们用的是5.7）那你知道在MySQL 5.6中，对索引做了哪些优化吗？（有一个比较重要的 ：Index Condition Pushdown Optimization） **  
&emsp;&emsp;Index Condition Pushdown（索引下推） MySQL 5.6引入了索引下推优化，默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。官方文档中给的例子和解释如下： people表中（zipcode，lastname，firstname）构成一个索引<br>&emsp;&emsp; SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;<br>&emsp;&emsp;如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’和address LIKE ‘%Main Street%’来判断数据是否符合条件。 如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’和address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。 有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。<br>**你们创建的那么多索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你们有统计过吗？</strong><br>&emsp;&emsp;这个还没有统计过，除非遇到慢SQL的时候我们才会去排查。<br><strong>那排查的时候，有什么手段可以知道有没有走索引查询呢？</strong><br>&emsp;&emsp;可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况。<br><strong>那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？</strong><br>&emsp;&emsp;查询优化器：一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。 优化过程大致如下： 1、根据搜索条件，找出所有可能使用的索引 2、计算全表扫描的代价 3、计算使用不同索引执行查询的代价 4、对比各种执行方案的代价，找出成本最低的那一个。<br><strong>mysql中的索引采用前缀匹配选择，B+树存储结构，查询的时间复杂度为O(logkn)，如果不使用索引，将会进行顺序查找，时间复杂度为O(n)。</strong><br><strong>使用索引的注意事项：</strong><br><strong>1.索引不会包含有NULL值的列</strong><br>&emsp;&emsp;只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。<br><strong>2.使用短索引</strong><br>&emsp;&emsp;对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作<br><strong>3.索引列排序</strong><br>&emsp;&emsp;MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。<br><strong>4.like语句操作</strong><br>&emsp;&emsp;一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。<br><strong>5.不要在列上进行运算</strong><br>&emsp;&emsp;select * from users where YEAR(adddate)&lt;2007; 将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成 select * from users where adddate&lt;‘2007-01-01’;<br><strong>6.尽量不使用NOT IN和&lt;&gt;操作</strong><br>&emsp;&emsp;当有Null空值时，可能会造成查询结果不准确<br>&emsp;&emsp;解决办法：<br>&emsp;&emsp;&emsp;&emsp;1.使用EXISTS 或 NOT EXISTS 代替<br>&emsp;&emsp;&emsp;&emsp;2.用JOIN 代替<br><a href="https://blog.csdn.net/dxyzhbb/article/details/100099493" target="_blank" rel="noopener">https://blog.csdn.net/dxyzhbb/article/details/100099493</a></p>
</blockquote>
</details>

<h2 id="4-如何实现一个单例模式"><a href="#4-如何实现一个单例模式" class="headerlink" title="4.如何实现一个单例模式"></a>4.如何实现一个单例模式</h2><blockquote>
<p><a href="/blog/2019/09/08/设计模式/单例模式/" target="_blank">单例模式</a>  </p>
</blockquote>
<h2 id="5-平时使用了哪些线程池"><a href="#5-平时使用了哪些线程池" class="headerlink" title="5.平时使用了哪些线程池"></a>5.平时使用了哪些线程池</h2><blockquote>
<p><a href="/blog/2020/03/17/线程池/" target="_blank">线程池</a>    </p>
</blockquote>
<h2 id="6-如何实现免登陆功能（cookie-session？）"><a href="#6-如何实现免登陆功能（cookie-session？）" class="headerlink" title="6.如何实现免登陆功能（cookie session？）"></a>6.如何实现免登陆功能（cookie session？）</h2><details>
<summary><mark><font color="darkred">点击查看详细内容</font></mark></summary>

<blockquote>
<p><strong>Cookie的机制</strong><br>&emsp;&emsp;Cookie是浏览器（User Agent）访问一些网站后，这些网站存放在客户端的一组数据，用于使网站等跟踪用户，实现用户自定义功能。<br>&emsp;&emsp;Cookie的Domain和Path属性标识了这个Cookie是哪一个网站发送给浏览器的；Cookie的Expires属性标识了Cookie的有 效时间，当Cookie的有效时间过了之后，这些数据就被自动删除了。<br>&emsp;&emsp;如果不设置过期时间，则表示这个Cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，Cookie就消失了。这种生命期为浏览会话期的 Cookie被称为会话Cookie。会话Cookie一般不保存在硬盘上而是保存在内存里。如果设置了过期时间，浏览器就会把Cookie保存到硬盘 上，关闭后再次打开浏览器，这些Cookie依然有效直到超过设定的过期时间。存储在硬盘上的Cookie可以在不同的浏览器进程间共享，比如两个IE窗 口。而对于保存在内存的Cookie，不同的浏览器有不同的处理方式。<br><strong>Session的机制</strong><br>&emsp;&emsp;Session是存放在服务器端的类似于HashTable结构（每一种Web开发技术的实现可能不一样，下文直接称之为HashTable）来存放用户 数据，当浏览器第一次发送请求时，服务器自动生成了一个HashTable和一个Session ID用来唯一标识这个HashTable，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。<br>&emsp;&emsp;一般情况下，服务器会在一定时间内（默认20分钟）保存这个HashTable，过了时间限制，就会销毁这个HashTable。在销毁之前，程序员可以 将用户的一些数据以Key和Value的形式暂时存放在这个HashTable中。当然，也有使用数据库将这个HashTable序列化后保存起来的，这 样的好处是没了时间的限制，坏处是随着时间的增加，这个数据库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。  <img src="/blog/img/2020/03/17/Cookie与Session的区别.jpg"><br><strong>一些网站的3天免登陆是如何做到的？</strong><br>&emsp;&emsp;方式一：首先想到的是使用cookie保存用户登录信息，设置有效期，在用户下次访问时免去登录环节，直接通过cookie获取用户信息。<br>&emsp;&emsp;方式二：直接将session会话保存，用户下次访问时，继续使用这个session。<br>&emsp;&emsp;相比之下session显得更加安全，但是，大家知道，session会随着浏览器的关闭而消失（确切的说，是在客户端消失，服务器端的session存活周期取决于相应配置），当用户下次启动浏览器，访问网站时，又会得到由网站自动分配的新的session。那么，问题来了：<br><strong>如何做到关闭浏览器后到下次登录时session仍然有效？</strong><br>&emsp;&emsp;思路：<br>&emsp;&emsp;1、在用户登录成功时，创建session对象，保存用户信息<br>&emsp;&emsp;2、将此session的sessionid保存到cookie中<br>&emsp;&emsp;3、同时将sessionid于session对应关系存储到应用域中，以便后面可以根据sessionid来获取到session<br>&emsp;&emsp;4、在用户关闭浏览器，重新打开浏览器访问网站时，读取用户的cookie，得到sessionid<br>&emsp;&emsp;5、根据sessionid获取到第3步存储到应用域中的session对象<br>&emsp;&emsp;6、从session中读取用户信息  </p>
</blockquote>
</details>

<h2 id="7-Map接口有哪些类？"><a href="#7-Map接口有哪些类？" class="headerlink" title="7.Map接口有哪些类？"></a>7.Map接口有哪些类？</h2><details>
<summary><mark><font color="darkred">点击查看详细内容</font></mark></summary>

<blockquote>
<p>Map提供了一种映射关系，其中的元素是以键值对（key-value）的形式存储的，能够实现根据key快速查找value；<br>Map中的键值对以Entry类型的对象实例形式存在；<br>键（key值）不可重复，value值可以重复，一个value值可以和很多key值形成对应关系，每个键最多只能映射到一个值。<br><strong>HahsMap</strong><br>&emsp;&emsp;基于哈希表(散列表)的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）除实现了Map接口外还实现了Cloneable，Serializable，继承了AbstractMap抽象类。<br>&emsp;&emsp;此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>&emsp;&emsp;特点：<br>&emsp;&emsp;键无序，唯一，类似于Set集合<br>&emsp;&emsp;值有序，可重复，类似于List<br>&emsp;&emsp;底层数据结构是哈希表，保证键唯一<br>&emsp;&emsp;允许键为null，值为null<br><strong>LinkedHashMap</strong><br>&emsp;&emsp;Map 接口的哈希表和链表(双向链表)实现，具有可预知的迭代顺序（按照插入顺序输出结果）。<br>&emsp;&emsp;特点：<br>&emsp;&emsp;键有序，唯一，<br>&emsp;&emsp;值有序，可重复，类似于List<br>&emsp;&emsp;底层数据结构是哈希表和链表，哈希表保证键唯一，链表保证键有序<br><strong>TreeMap</strong><br>&emsp;&emsp;Map 基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。<br>&emsp;&emsp;特点：<br>&emsp;&emsp;键可排序，唯一，<br>&emsp;&emsp;值有序，可重复，类似于List<br>&emsp;&emsp;底层数据结构是自平衡的二叉树，可排序<br>&emsp;&emsp;排序方式类似于TreeSet，分为自然排序和比较器排序，具体取决于使用的构造方法<br><strong>HashTable</strong><br>&emsp;&emsp;此类实现一个哈希表，该哈希表将键映射到相应的值。任何非 null 对象都可以用作键或值。<br>&emsp;&emsp;特点：<br>&emsp;&emsp;不允许null键和null值<br>&emsp;&emsp;线程安全，效率低<br>&emsp;&emsp;HashMap和Hashtable的区别:<br>&emsp;&emsp;HashMap是不安全的不同步的效率高的，允许null键和null值；Hashtable是安全的同步的效率低的 不允许null键和null值<br>底层都是哈希表结构。<br><strong>WeakHashMap</strong><br>&emsp;&emsp;以弱键实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。<br>&emsp;&emsp;丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的 Map 实现有所不同。<br><strong>EnumMap</strong><br>键是枚举类型  </p>
</blockquote>
</details>

<h2 id="8-HashMap为什么会导致CPU100"><a href="#8-HashMap为什么会导致CPU100" class="headerlink" title="8.HashMap为什么会导致CPU100%?"></a>8.HashMap为什么会导致CPU100%?</h2><blockquote>
<p><a href="/blog/2020/03/18/HashMap为什么会导致CPU100/" target="_blank">HashMap为什么会导致CPU100%的原因</a> </p>
</blockquote>
<h2 id="9-接口的意义"><a href="#9-接口的意义" class="headerlink" title="9.接口的意义"></a>9.接口的意义</h2><blockquote>
<p><strong>为了更好的将设计与实现分离,能够间接达到多继承的效果</strong><br>Java中接口顾名思义就是用来接收数据的一个端口，用来给不同类或前后端做通信用的。<br>Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。<br><strong>接口的规范和特性</strong><br>&emsp;&emsp;在java中接口interface定义了使用此接口的类的规范，也就是一些变量和抽象方法。<br>&emsp;&emsp;接口中的成员变量默认为 public static final 修饰的静态常量。<br>&emsp;&emsp;默认方法为 public abstract修饰的抽象方法。  </p>
</blockquote>
<h2 id="10-抽象类的意义"><a href="#10-抽象类的意义" class="headerlink" title="10.抽象类的意义"></a>10.抽象类的意义</h2><blockquote>
<p><strong>对代码的维护和重用</strong><br><strong>1.因为抽象类不能实例化对象，所以必须要有子类来实现它之后才能使用。这样就可以把一些具有相同属性和方法的组件进行抽象，这样更有利于代码和程序的维护。</strong><br>&emsp;&emsp;比如本科和研究生可以抽象成学生，他们有相同的属性和方法。这样当你对其中某个类进行修改时会受到父类的限制，这样就会提醒开发人员有些东西不能进行随意修改，这样可以对比较重要的东西进行统一的限制，也算是一种保护，对维护会有很大的帮助。<br><strong>2.当又有一个具有相似的组件产生时，只需要实现该抽象类就可以获得该抽象类的那些属性和方法。</strong><br>&emsp;&emsp;比如学校又新产生了专科生这类学生，那么专科生直接继承学生，然后对自己特有的属性和方法进行补充即可。这样对于代码的重用也是很好的体现。<br><strong>所以，Java中抽象类对于代码的维护和重用有很好的帮助，也是Java面向对象的一个重要体现。</strong>  </p>
</blockquote>
<h2 id="11-抽象类与接口类的相同点与区别"><a href="#11-抽象类与接口类的相同点与区别" class="headerlink" title="11.抽象类与接口类的相同点与区别"></a>11.抽象类与接口类的相同点与区别</h2><blockquote>
<p><strong>相同点</strong><br>&emsp;&emsp;1.不能实例化<br>&emsp;&emsp;2.包含未实现的方法声明<br>&emsp;&emsp;3.派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员(不仅是方法包括其他成员)<br><strong>不同点</strong><br>&emsp;&emsp;1.类可以实现无限个接口，但仅能从一个抽象（或任何其他类型）类继承，从抽象类派生的类仍可实现接口，从而得出接口是用来解决多重继承问题的。<br>&emsp;&emsp;2.抽象类当中可以存在非抽象的方法，可接口不能，且它里面的方法只是一个声明必须用public来修饰没有具体实现的方法。<br>&emsp;&emsp;3.抽象类中的成员变量可以被不同的修饰符来修饰，可接口中的成员变量默认的都是静态常量（static final）。<br>&emsp;&emsp;4.类是对对象的抽象，抽象类是对类的抽象；接口是对行抽象。接口是对类（行为）进行的抽象，而抽象是对类整体（字段、属性、方法）的抽象。如果只关注行为抽象，那么也可以认为接口就是抽象类。总之，不论是接口、抽象类、类甚至对象，都是在不同层次、不同角度进行抽象的结果，它们的共性，就是抽象。<br>&emsp;&emsp;5.如果行为跨越不同类的对象，可使用接口；对于一些相似的类对象，用继承抽象类。<br>&emsp;&emsp;6.抽象类：强调的是is-a关系，抽象类中定义的是共性特征。接口：强调的是like-a关系,接口中定义的是扩展功能。<br>&emsp;&emsp;7.抽象类是自底向上抽象出来的，而接口则是自顶向下设计出来的。从设计的角度来说，抽象类是从子类中发现公共的东西，泛化出父类，然后子类继承父类，而接口是根本不知子类的存在，方法是如何实现还不确定，预先定义。    </p>
</blockquote>
<h2 id="12-内部类的作用"><a href="#12-内部类的作用" class="headerlink" title="12.内部类的作用"></a>12.内部类的作用</h2><blockquote>
<p>将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。<br><strong>内部类的分类</strong><br>&emsp;&emsp;1.成员内部类<br>&emsp;&emsp;2.局部内部类<br>&emsp;&emsp;3.静态内部类<br>&emsp;&emsp;4.匿名内部类<br><strong>作用</strong><br>&emsp;&emsp;1.内部类可以很好的实现隐藏<br> &emsp;&emsp;&emsp;&emsp;一般的非内部类，是不允许有 private 与protected权限的，但内部类可以 。<br>&emsp;&emsp;2．内部类拥有外围类的所有元素的访问权限(可以实现回调功能)<br>&emsp;&emsp;3.可是实现多重继承<br>&emsp;&emsp;4.可以避免修改接口而实现同一个类中两种同名方法的调用。<br><a href="/blog/2020/03/18/内部类/" target="_blank"> &gt;&gt;内部类</a> </p>
</blockquote>
<h2 id="13-父类的静态方法能否被子类重写，为什么？"><a href="#13-父类的静态方法能否被子类重写，为什么？" class="headerlink" title="13.父类的静态方法能否被子类重写，为什么？"></a>13.父类的静态方法能否被子类重写，为什么？</h2><details>
<summary><mark><font color="darkred">点击查看详细内容</font></mark></summary>

<blockquote>
<p><strong>不能</strong><br>&emsp;&emsp;JAVA的静态方法形式上可以重写，但是本质上不是JAVA的重写，所以答案是不能。  </p>
</blockquote>
<pre><code>class Fruit{

    static String color = &quot;五颜六色&quot;;
    static public void call() {
        System.out.println(&quot;这是一个水果&quot;);
    }
}

public class Banana extends Fruit{

    static String color = &quot;黄色&quot;;
    static public void call() {
        System.out.println(&quot;这是一个香蕉&quot;);
    }

    public static void main(String[] args) {

        Fruit fruit = new Banana();
        System.out.println(fruit.color);    //五颜六色
        fruit.call();         //这是一个水果
    }
}</code></pre><blockquote>
<p><strong>为什么？</strong><br>&emsp;&emsp;静态方法只与类有关，不与实例有关，重写只适用于实例方法，不适用于静态方法。<br>&emsp;&emsp;非静态方法，按重写规则，调用相应的类的实现方法，而静态方法只与类有关。<br>&emsp;&emsp;因为静态方法是程序一运行就已经分配好了内存地址，而且该地址是固定的，所有引用到该方法的对象（父类或者子类）所指向的始终是同一个内存地址中的数据，即该静态方法。如果子类定义了相同名称的静态方法，只会新增一个内存地址，并不会重写。<br><strong>重写指的是根据运行时对象的类型来决定调用哪个方法，而不是根据编译时的类型。</strong><br><strong>静态属性和静态方法是否可以被继承?</strong><br>可以被继承，如果子类中有相同的静态方法和静态变量，那么父类的方法以及变量就会被覆盖。要想调用就就必须使用父类来调用。  </p>
</blockquote>
<pre><code>class Fruit{

    static String color = &quot;五颜六色&quot;;
    static String xingzhuang = &quot;奇形怪状&quot;;
    static public void call() {
        System.out.println(&quot;这是一个水果&quot;);
    }
    static public void test() {
        System.out.println(&quot;这是没有被子类覆盖的方法&quot;);
    }
}

public class Banana extends Fruit{

    static String color = &quot;黄色&quot;;
    static public void call() {
        System.out.println(&quot;这是一个香蕉&quot;);
    }

    public static void main(String[] args) {

        Banana banana = new Banana();    
        banana.test();     //这是没有被子类覆盖的方法
        banana.call();     //调用Banana类中的call方法    这是一个香蕉
        Fruit.call();         //调用Fruit类中的方法 这是一个水果

        System.out.println(banana.xingzhuang + &quot; &quot; + banana.color);   //奇形怪状 黄色
    }
}</code></pre></details> 

<h2 id="14-举1-2个排序算法，并使用java代码实现"><a href="#14-举1-2个排序算法，并使用java代码实现" class="headerlink" title="14.举1-2个排序算法，并使用java代码实现"></a>14.举1-2个排序算法，并使用java代码实现</h2><blockquote>
<p><a href="/blog/2020/01/08/排序算法/" target="_blank">排序算法</a> </p>
</blockquote>
<h2 id="15-列举java的集合和继承关系"><a href="#15-列举java的集合和继承关系" class="headerlink" title="15.列举java的集合和继承关系"></a>15.列举java的集合和继承关系</h2><blockquote>
<img src="/blog/img/2020/03/18/Java的集合和继承关系.jpg">  
</blockquote>
<h2 id="16-java虚拟机的特性"><a href="#16-java虚拟机的特性" class="headerlink" title="16.java虚拟机的特性"></a>16.java虚拟机的特性</h2><blockquote>
<p>&emsp;&emsp;Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键(体现了可移植性强)。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。  </p>
</blockquote>
<h2 id="17-哪些情况下的对象会被垃圾回收机制处理掉"><a href="#17-哪些情况下的对象会被垃圾回收机制处理掉" class="headerlink" title="17.哪些情况下的对象会被垃圾回收机制处理掉"></a>17.哪些情况下的对象会被垃圾回收机制处理掉</h2><blockquote>
<p>1.没有引用指向<br>2.只有弱引用指向并且不回收弱引用对象的话存储区无空间<br>3.虚引用指向的对象<br><strong>有什么方法可以让GC判断对象是否可以回收？</strong><br>1.引用计数法(可能会造成内存泄漏，大部分虚拟机不采用此方法进行垃圾回收)<br>2.可达性分析算法<br><a href="https://cloud.tencent.com/developer/article/1332790" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1332790</a><br><a href="https://www.cnblogs.com/l199616j/p/11297583.html" target="_blank" rel="noopener">https://www.cnblogs.com/l199616j/p/11297583.html</a>   </p>
</blockquote>
<h2 id="18-内存溢出和内存泄漏"><a href="#18-内存溢出和内存泄漏" class="headerlink" title="18.内存溢出和内存泄漏"></a>18.内存溢出和内存泄漏</h2><details>
<summary><mark><font color="darkred">点击查看详细内容</font></mark></summary>

<blockquote>
<p><strong>内存泄漏：</strong> 是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。<br><strong>内存溢出：</strong> 指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。<br>&emsp;&emsp;通俗的说就是停车场（堆）保安（gc）让很久不用的废弃车子(无用的对象)从车位上挪走，但是这个车子又没办法挪走。这就是内存泄漏。停车场所有的车位都有车子占用了，再来车子没地了，或者说给你一个小汽车的停车位（int），你非要停一辆高铁(Long)，这就是内存溢出。<br>&emsp;&emsp;<strong>内存泄露量大到一定程度会导致内存溢出。但是内存溢出不一定是内存泄露引起的。</strong><br><strong>常见的内存泄漏：</strong><br><strong>1、单例造成的内存泄漏</strong><br>&emsp;&emsp;由于单例的静态特性，使得它的生命周期和应用的生命周期一样长，如果一个对象已经不再需要使用了，而单例对象还持有该对象的引用，就会使该对象不能被正确的回收，从而导致内存泄漏。<br><strong>2、非静态内部类创建静态实例造成的内存泄漏</strong><br>&emsp;&emsp;非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用一样长，这就导致了该静态实例一直会持有该Activity的引用，从而导致Activity的内存资源不能被正确回收。<br><strong>3、Handler造成的内存泄漏</strong><br>&emsp;&emsp;handler发送的消息在当前handler的消息队列中，如果此时activity finish掉了，那么消息队列的消息依旧会由handler进行处理，若此时handler声明为内部类（非静态内部类），我们知道内部类天然持有外部类的实例引用，那么就会导致activity无法回收，进而导致activity泄露。<br><strong>4、线程造成的内存泄漏</strong><br>&emsp;&emsp;如果任务在Activity销毁之前还未完成，那么将导致Activity的内存资源无法被回收，从而造成内存泄漏。<br><strong>5、资源未关闭，造成内存泄漏</strong><br>&emsp;&emsp;对于使用了BraodcastReceiver, ContentObserver, File, Cursor, Stream, Bitmap 等資源，立垓在Activity銷毀肘及吋美閉或者注銷，否則込些湊源将不会被回收，从而造成内存泄漏。<br><strong>6、使用ListView吋造成的内存泄漏</strong><br>&emsp;&emsp;构造Adapter时，没有使用缓存的convertView，Adapter中引用了Activity如何避免内存泄漏。有时需要点击ListView条目里的某个按钮实现界面跳转，getView()方法inflate布局的时候需要上下文，而且点击按钮后的跳转逻辑也需要上下文。所以我们经常会把Activity传入到Adapter中，如果Adapter中有很多耗时操作，可能就会防止Activity finish的时候被回收。<br><strong>7、集合容器中的内存泄露</strong><br>&emsp;&emsp;我们通常把一些对象的引用加入到了集合容器（比如ArrayList）中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。<br><strong>8、WebView 造成的泄露</strong><br>&emsp;&emsp;当我们不要使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存，否则其长期占用的内存也不能被回收，从而造成内存泄露。<br>内存泄漏与解决办法详解：<a href="https://www.jianshu.com/p/90caf813682d" target="_blank" rel="noopener">https://www.jianshu.com/p/90caf813682d</a><br><strong>常见内存溢出：</strong><br>1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；<br>2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；<br>3.代码中存在死循环或循环产生过多重复的对象实体；<br>4.使用的第三方软件中的BUG；<br>5.启动参数内存值设定的过小<br><strong>内存溢出的解决方案：</strong><br>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)<br>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。<br>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。  </p>
</blockquote>
</details>  

<h2 id="19-进程和线程的区别"><a href="#19-进程和线程的区别" class="headerlink" title="19.进程和线程的区别"></a>19.进程和线程的区别</h2><blockquote>
<p><a href="/blog/2020/03/17/线程池/" target="_blank">线程池</a>    </p>
</blockquote>
<h2 id="20-常见的排序算法时间复杂度"><a href="#20-常见的排序算法时间复杂度" class="headerlink" title="20.常见的排序算法时间复杂度"></a>20.常见的排序算法时间复杂度</h2><blockquote>
<img src="/blog/img/2020/03/19/常见排序算法的时间复杂度.jpg">  
</blockquote>
<h2 id="21-ArrayList和HashMap的实现原理"><a href="#21-ArrayList和HashMap的实现原理" class="headerlink" title="21.ArrayList和HashMap的实现原理"></a>21.ArrayList和HashMap的实现原理</h2><blockquote>
<p>ArrayList的底层实现是一个数组，动态的数组，能自动扩容。<br>HashMap底层实现其实也是一个数组，该数组存放的元素是一个entry键值对，同时数组的每个元素也是一个链表的头节点，HashMap经过hash函数将值存放在对应的数组下标中，一般是根据存储元素 hashcode值%数组长度 得到数组的下标。   </p>
</blockquote>
<h2 id="22-Java中-和equals的区别，equals和hashCode的区别"><a href="#22-Java中-和equals的区别，equals和hashCode的区别" class="headerlink" title="22.Java中==和equals的区别，equals和hashCode的区别"></a>22.Java中==和equals的区别，equals和hashCode的区别</h2><blockquote>
<p>1.对于8大基本数据类型来说，==比较的是值的内容是否相等。没有equals方法。<br>2.对于String数据类型以及Integer等包装类来说，==比较的是地址值，equals比较的是内容是否相等。<br>3.对于引用类型来说，==和equals比较的都是地址值。<br>4.equals和hashCode是属于Object的两个不同的方法，但是在进行equals比较时，需要用到hashcode。   </p>
</blockquote>
<h2 id="23-java中int-char-long各占多少字节数"><a href="#23-java中int-char-long各占多少字节数" class="headerlink" title="23.java中int char long各占多少字节数"></a>23.java中int char long各占多少字节数</h2><blockquote>
<p>int 4个字节（1个字节占8位）<br>char 2个字节<br>long 8个字节<br><br> </p>
<p>byte 1个字节（ -128（-2^7）~127(2^7-1) ）<br>short 2个字节<br>boolean 至少1字节<br>float  4字节 单精度浮点数字长32位，尾数长度23，指数长度8,指数偏移量127；<br>double 8字节 双精度浮点数字长64位，尾数长度52，指数长度11，指数偏移量1023；<br><strong>英文字母：</strong><br>字节数 : 1;编码：GB2312<br>字节数 : 1;编码：GBK<br>字节数 : 1;编码：ISO-8859-1<br>字节数 : 1;编码：UTF-8<br><strong>中文汉字：</strong><br>字节数 : 2;编码：GB2312<br>字节数 : 2;编码：GBK<br>字节数 : 1;编码：ISO-8859-1<br>字节数 : 3;编码：UTF-8<br><a href="https://www.cnblogs.com/jiftle/p/10864492.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiftle/p/10864492.html</a>  </p>
</blockquote>
<h2 id="24-java-int与integer的区别"><a href="#24-java-int与integer的区别" class="headerlink" title="24.java int与integer的区别"></a>24.java int与integer的区别</h2><blockquote>
<p>1、Integer是int的包装类，里面包含了一些操作int数据的方法，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0  </p>
</blockquote>
<h2 id="25-string-stringbuffer-stringbuilder-区别"><a href="#25-string-stringbuffer-stringbuilder-区别" class="headerlink" title="25.string stringbuffer stringbuilder 区别"></a>25.string stringbuffer stringbuilder 区别</h2><blockquote>
<p><strong>String</strong><br>String底层是一个final类型的字符数组，所以String的值是不可变的，每次对String的操作都会生成新的String对象，造成内存浪费。<br><img src="/blog/img/2020/03/19/String.png"><br><strong>StringBuffer和StringBuilder</strong><br>而StringBuffer和StringBuilder就不一样了，他们两都继承了AbstractStringBuilder抽象类，从AbstractStringBuilder抽象类中我们可以看到<br><img src="/blog/img/2020/03/19/StringBuffer和StringBuilder.png"><br>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuffer和StringBuilder来进行操作。<br>StringBuilder 和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）由于 StringBuilder 相较于StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。<br><a href="https://blog.csdn.net/TTTZZZTTTZZZ/article/details/84892985" target="_blank" rel="noopener">https://blog.csdn.net/TTTZZZTTTZZZ/article/details/84892985</a>  </p>
</blockquote>
<h2 id="26-Java多态"><a href="#26-Java多态" class="headerlink" title="26.Java多态"></a>26.Java多态</h2><blockquote>
<p>多态是指同一个行为具有多个不同表现形式或形态的能力。是指一个类的实例(对象)的相同方法在不同情形有不同表现形式。<br>简单来说，多态是指一个名字多种实现。多态使得一个实体通过一个通用的方式来实现不同的操作。具体的操作是由实际的实现来决定的。<br>多态在java里有三种表现方式：方法重载、通过继承实现方法重写、通过java接口进行方法重写。  </p>
</blockquote>
<h2 id="27-什么导致线程阻塞"><a href="#27-什么导致线程阻塞" class="headerlink" title="27.什么导致线程阻塞?"></a>27.什么导致线程阻塞?</h2><blockquote>
<p>阻塞状态的线程的特点是：该线程放弃CPU的使用，暂停运行，只有等到导致阻塞的原因消除之后才恢复运行。或者是被其他的线程中断，该线程也会退出阻塞状态，同时抛出InterruptedException。<br>1）线程执行了Thread.sleep(intmillsecond);方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行<br>2）线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行。<br>3）线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。<br>4）线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。  </p>
</blockquote>
<h2 id="28-容器类之间的区别"><a href="#28-容器类之间的区别" class="headerlink" title="28.容器类之间的区别"></a>28.容器类之间的区别</h2><blockquote>
<p>总体上分为两大类Collection接口和Map接口，然后Collection接口下面又包含List、set（HashSet、treeSet、LinkedSet）接口。<br><img src="/blog/img/2020/03/18/Java的集合和继承关系.jpg">  </p>
</blockquote>
<h2 id="29-ArrayMap-VS-HashMap"><a href="#29-ArrayMap-VS-HashMap" class="headerlink" title="29.ArrayMap VS HashMap"></a>29.ArrayMap VS HashMap</h2><blockquote>
<p>&emsp;&emsp;HashMap内部是使用一个默认容量为16的数组来存储数据的，而数组中每一个元素却又是一个链表的头结点，所以，更准确的来说，HashMap内部存储结构是使用哈希表的拉链结构（数组+链表），这种存储数据的方法叫做拉链法 。 <br><br>&emsp;&emsp;ArrayMap是一个&lt;key,value&gt;映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，所以，应用场景和SparseArray的一样，如果在数据量比较大的情况下，那么它的性能将退化至少50%。<br><br><strong>ArrayMap应用场景</strong><br>1.数据量不大，最好在千级以内<br>2.数据结构类型为Map类型<br><a href="https://www.cnblogs.com/clwydjgs/p/9185574.html" target="_blank" rel="noopener">https://www.cnblogs.com/clwydjgs/p/9185574.html</a><br><a href="https://www.jianshu.com/p/999be2ee763a" target="_blank" rel="noopener">https://www.jianshu.com/p/999be2ee763a</a>  </p>
</blockquote>
<h2 id="30-Switch能否用string做参数？"><a href="#30-Switch能否用string做参数？" class="headerlink" title="30.Switch能否用string做参数？"></a>30.Switch能否用string做参数？</h2><blockquote>
<p>能  
java7以后新增的<br><strong>为什么jdk1.7后又可以用string类型作为switch参数呢？</strong><br>其实，jdk1.7并没有新的指令来处理switch string，而是通过调用switch中string.hashCode,将string转换为int从而进行判断。<br><a href="https://blog.csdn.net/wjhelloworld/article/details/78439118" target="_blank" rel="noopener">https://blog.csdn.net/wjhelloworld/article/details/78439118</a>  </p>
</blockquote>
<h2 id="31-Object有哪些公用方法？"><a href="#31-Object有哪些公用方法？" class="headerlink" title="31.Object有哪些公用方法？"></a>31.Object有哪些公用方法？</h2><blockquote>
<p>(1)clone():保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法<br>(2)getClass()：final方法，获得运行时的类。<br>(3)toString():该方法用得比较多，一般子类都有覆盖。<br>(4)finalize():该方法用于释放资源，因为无法确定方法什么时候被调用，很少使用。<br>(5)equals():该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。<br>(6)hashCode():该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。<br>(7)wait():wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br>调用该方法后当前线程进入睡眠状态，直到以下事件发生。<br>（7.1）其他线程调用了该对象的notify方法。<br>（7.2）其他线程调用了该对象的notifyAll方法。<br>（7.3）其他线程调用了interrupt中断该线程。<br>（7.4）时间间隔到了。<br>(8)notify():该方法唤醒在该对象上等待的某个线程。<br>(9)notifyAll():该方法唤醒在该对象上等待的所有线程。  </p>
</blockquote>
<h2 id="32-Java的四种引用，强弱软虚，用到的场景"><a href="#32-Java的四种引用，强弱软虚，用到的场景" class="headerlink" title="32.Java的四种引用，强弱软虚，用到的场景"></a>32.Java的四种引用，强弱软虚，用到的场景</h2><blockquote>
<p><a href="https://blog.csdn.net/heminghung/article/details/51379143" target="_blank" rel="noopener">https://blog.csdn.net/heminghung/article/details/51379143</a>  </p>
</blockquote>
<h2 id="33-hashcode的作用"><a href="#33-hashcode的作用" class="headerlink" title="33.hashcode的作用"></a>33.hashcode的作用</h2><blockquote>
<p>当我们向一个集合中添加某个元素，集合会首先调用hashCode方法。这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置。这样处理，<strong>当我们存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。</strong><br><a href="https://www.jianshu.com/p/c7fc90711913" target="_blank" rel="noopener">https://www.jianshu.com/p/c7fc90711913</a>  </p>
</blockquote>
<h2 id="34-ArrayList、LinkedList、Vector的区别"><a href="#34-ArrayList、LinkedList、Vector的区别" class="headerlink" title="34.ArrayList、LinkedList、Vector的区别"></a>34.ArrayList、LinkedList、Vector的区别</h2><blockquote>
<p><strong>1.基本区别：</strong> 三个类都实现了List接口，都是有序集合，数据是允许重复的；ArrayList 和Vector都是基于数组实现存储的，集合中的元素的位置都是有顺序即连续的；LinkedList是基于双向链表实现存储的，集合中的元素的位置是不连续的<br><strong>2.性能区别：</strong> Vector和ArrayList底层实现原理一致，但是Vector是线程安全的，因此性能比ArrayList差很多；LinkedList相比于集合Vector和ArrayList在插入,修改，删除等操作上速度较快，但是随机访问的性能较差<br><strong>3.安全区别：</strong> Vector是使用了synchronized同步锁是线程安全的，ArrayList和LinkedList都是线程不安全的<br><strong>4.原理区别：</strong> ArrayList与Vector都有初始的容量大小，当存储的元素的个数超过了容量时，就需要增加存储空间，Vector默认增长为原来两倍，而ArrayList的增长为原来的1.5倍；ArrayList与Vector都可以设置初始空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。 </p>
</blockquote>
<h2 id="35-Map、Set、List、Queue、Stack的特点与用法。"><a href="#35-Map、Set、List、Queue、Stack的特点与用法。" class="headerlink" title="35.Map、Set、List、Queue、Stack的特点与用法。"></a>35.Map、Set、List、Queue、Stack的特点与用法。</h2><blockquote>
<p><strong>Map:</strong> Map用于保存具有”映射关系”的数据，因此Map集合里保存着两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value。 key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较结果总是返回false。<br><strong>Set:</strong> Set集合类似于一个罐子，”丢进”Set集合里的多个对象之间没有明显的顺序。Set继承自Collection接口，不能包含有重复元素(记住，这是整个Set类层次的共有属性)。 Set判断两个对象相同不是使用”==”运算符，而是根据equals方法。<br><strong>List:</strong> List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。 List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。List集合默认按元素的添加顺序设置元素的索引。<br><strong>Stack：</strong> Stack是Vector提供的一个子类，用于模拟”栈”这种数据结构(后进先出LIFO)<br>方法:push、pop、peek、empty、seatch<br><strong>queue：</strong> Queue用于模拟”队列”这种数据结构(先进先出FIFO)。队列的头部保存着队列中存放时间最长的元素，队列的尾部保存着队列中存放时间最短的元素。 新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素，队列不允许随机访问队列中的元素。结合生活中常见的排队就会很好理解这个概念。  </p>
</blockquote>
<h2 id="36-HashMap和ConcurrentHashMap的区别，HashMap的底层源码。"><a href="#36-HashMap和ConcurrentHashMap的区别，HashMap的底层源码。" class="headerlink" title="36.HashMap和ConcurrentHashMap的区别，HashMap的底层源码。"></a>36.HashMap和ConcurrentHashMap的区别，HashMap的底层源码。</h2><blockquote>
<p>&emsp;&emsp;Hashmap本质是数组加链表。根据key取得hash值，然后计算出数组下标，如果多个key对应到同一个下标，就用链表串起来，新插入的在前面。<br>&emsp;&emsp;ConcurrentHashMap：在hashMap的基础上，ConcurrentHashMap将数据分为多个segment(段)，默认16个（concurrency level），然后每次操作对一个segment(段)加锁，避免多线程锁的几率，提高并发效率。<br>&emsp;&emsp;ConcurrentHashMap融合了hashtable和hashmap二者的优势。<br>hashtable是做了同步的，hashmap未考虑同步。所以hashmap在单线程情况下效率较高。hashtable在的多线程情况下，同步操作能保证程序执行的正确性。<br>但是hashtable每次同步执行的时候都要锁住整个结构。看下图：<img src="/blog/img/2020/03/20/CurrentHashMap.jpg"><br>&emsp;&emsp;图左侧清晰的标注出来，lock每次都要锁住整个结构。<br>&emsp;&emsp;ConcurrentHashMap正是为了解决这个问题而诞生的。<br>&emsp;&emsp;ConcurrentHashMap锁的方式是稍微细粒度的(分段锁)。ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶。<br>&emsp;&emsp;从ConcurrentHashMap代码中可以看出，它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。<br>&emsp;&emsp;在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中：<br>&emsp;&emsp;试想，原来 只能一个线程进入，现在却能同时16个写线程进入（写线程才需要锁定，而读线程几乎不受限制，之后会提到），并发性的提升是显而易见的。<br>&emsp;&emsp;更令人惊讶的是ConcurrentHashMap的读取并发，因为在读取的大多数时候都没有用到锁定，所以读取操作几乎是完全的并发操作，而写操作锁定的粒度又非常细，比起之前又更加快速（这一点在桶更多时表现得更明显些）。只有在求size等操作时才需要锁定整个表。  </p>
</blockquote>
<h2 id="37-Collection包结构，与Collections的区别。"><a href="#37-Collection包结构，与Collections的区别。" class="headerlink" title="37.Collection包结构，与Collections的区别。"></a>37.Collection包结构，与Collections的区别。</h2><blockquote>
<p>Collection是集合类的顶级接口，实现它的接口和类主要有List和Set接口，以及他们的子类。<br>Collections是针对集合类的一个帮助类，提供操作集合的工具方法。一系列静态方法实现对各种集合的<strong>搜索、排序、线程安全化</strong>等操作。服务于java的Collection的框架。  </p>
</blockquote>
<h2 id="38-try-catch-finally，try里有return，finally还执行么？"><a href="#38-try-catch-finally，try里有return，finally还执行么？" class="headerlink" title="38.try catch finally，try里有return，finally还执行么？"></a>38.try catch finally，try里有return，finally还执行么？</h2><blockquote>
<p>(1)、不管有木有出现异常，finally块中代码都会执行；<br>(2)、当try和catch中有return时，finally仍然会执行(finally语句块是在程序退出方法之前被执行的)；<br>(3)、在try语句中，try要把返回的结果放置到不同的局部变量当中，执行finaly之后，从中取出返回结果，因此，即使finaly中对变量进行了改变，但是不会影响返回结果，因为使用栈保存返回值，即使在finaly当中进行数值操作，但是影响不到之前保存下来的具体的值，所以return影响不了基本类型的值，这里使用的栈保存返回值。而如果修改list，map，自定义类等引用类型时，在进入了finaly之前保存了引用的地址， 所以在finaly中引用地址指向的内容改变了，影响了返回值。<br>具体参考此文章：<a href="/blog/2019/08/14/final、finally、finalize的用法/" target="_blank">final、finally、finalize的用法</a>   </p>
</blockquote>
<h2 id="39-Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。"><a href="#39-Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。" class="headerlink" title="39.Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。"></a>39.Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。</h2><blockquote>
<p>Excption与Error的顶级接口都是Throwable。Java将可抛出(Throwable)的结构分为三种类型：被检查的异常(CheckedException)，运行时异常(RuntimeException)，错误(Error)。<br><strong>OOM：</strong><br>1，OutOfMemoryError异常（Java Heap溢出）一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess。<br>2.虚拟机栈和本地方法栈溢出<br>3.运行时常量池溢出<br>4.方法区溢出<br><strong>SOF（堆栈溢出 StackOverflow）：</strong><br>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。<br><a href="https://blog.csdn.net/qiuchaoxi/article/details/79788993" target="_blank" rel="noopener">https://blog.csdn.net/qiuchaoxi/article/details/79788993</a>  </p>
</blockquote>
<h2 id="40-Java面向对象的三个特征与含义。"><a href="#40-Java面向对象的三个特征与含义。" class="headerlink" title="40.Java面向对象的三个特征与含义。"></a>40.Java面向对象的三个特征与含义。</h2><blockquote>
<p>封装、继承、多态。<br>具体看这：<a href="/blog/2019/08/20/面向对象的三大基本特征，七大基本原则/" target="_blank">面向对象的三大基本特征，七大基本原则</a>   </p>
</blockquote>
<h2 id="41-Override和Overload的含义去区别。"><a href="#41-Override和Overload的含义去区别。" class="headerlink" title="41.Override和Overload的含义去区别。"></a>41.Override和Overload的含义去区别。</h2><blockquote>
<p>Override：方法重写，同名同参同返回值<br>Overload：方法重载 ，同名不同参，返回值也可以不同   </p>
</blockquote>
<h2 id="42-Static-class-与non-static-class的区别。"><a href="#42-Static-class-与non-static-class的区别。" class="headerlink" title="42.Static class 与non static class的区别。"></a>42.Static class 与non static class的区别。</h2><blockquote>
<p>&emsp;&emsp;内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。<br>根据Oracle官方的说法：<br>&emsp;&emsp;Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are called static nested classes.<br>&emsp;&emsp;Non-static nested classes are called inner classes.<br>&emsp;&emsp;从字面上看，一个被称为静态嵌套类，一个被称为内部类。<br>&emsp;&emsp;从字面的角度解释是这样的：<br>&emsp;&emsp;什么是嵌套？嵌套就是我跟你没关系，自己可以完全独立存在，但是我就想借你的壳用一下，来隐藏一下我自己（真TM猥琐）。<br>&emsp;&emsp;什么是内部？内部就是我是你的一部分，我了解你，我知道你的全部，没有你就没有我。（所以内部类对象是以外部类对象存在为前提的）    </p>
</blockquote>
<h2 id="43-java多态的实现原理"><a href="#43-java多态的实现原理" class="headerlink" title="43. java多态的实现原理"></a>43. java多态的实现原理</h2><blockquote>
<p>&emsp;&emsp;多态是指同一个行为具有多个不同表现形式或形态的能力。是指一个类实例(对象)的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这就意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们(那些操作)可以通过相同的方式给予调用。<br><strong>多态存在的三个必要条件：</strong><br>&emsp;&emsp;1.继承(接口)<br>&emsp;&emsp;2.重写(子类继承父类后对父类方法进行重新定义)<br>&emsp;&emsp;3.父类引用指向子类对象<br>&emsp;&emsp;简言之，<strong>多态其实是在继承的基础上的。</strong>比如说今天我们要去动物园参观动物，那么你说我们去参观兔子、参观绵羊、参观狮子、参观豹子都是对的，但你不能说我们去参观汽车。在这个例子中，子类具有多态性：除了使用自己的身份，还能充当父类。<br>具体看这：<a href="/blog/2019/08/20/面向对象的三大基本特征，七大基本原则/" target="_blank">面向对象的三大基本特征，七大基本原则</a>  </p>
</blockquote>
<h2 id="44-线程同步的方法：sychronized、lock、reentrantLock等。"><a href="#44-线程同步的方法：sychronized、lock、reentrantLock等。" class="headerlink" title="44.线程同步的方法：sychronized、lock、reentrantLock等。"></a>44.线程同步的方法：sychronized、lock、reentrantLock等。</h2><blockquote>
<p>&emsp;&emsp;synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。<br>&emsp;&emsp;synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。<br>&emsp;&emsp;Lock用的是乐观锁方式。每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<br>&emsp;&emsp;<strong>ReentrantLock:</strong> 一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的<strong>隐式监视器</strong>锁相同的一些基本行为和语义，但功能更强大。<br>&emsp;&emsp;ReentrantLock必须在finally中释放锁，否则后果很严重，编码角度来说使用synchronized更加简单，不容易遗漏或者出错。<br>&emsp;&emsp;ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized则一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。<br>&emsp;&emsp;synchronized的话，锁的范围是整个方法或synchronized块部分；而Lock因为是方法调用，可以跨方法，灵活性更大<br>&emsp;&emsp;一般情况下都是用synchronized原语实现同步，除非下列情况使用ReentrantLock<br>&emsp;&emsp;①某个线程在等待一个锁的控制权的这段时间需要中断<br>&emsp;&emsp;②需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程<br>&emsp;&emsp;③具有公平锁功能，每个到来的线程都将排队等候  </p>
</blockquote>
<h2 id="45-锁的等级：方法锁、对象锁、类锁"><a href="#45-锁的等级：方法锁、对象锁、类锁" class="headerlink" title="45.锁的等级：方法锁、对象锁、类锁"></a>45.锁的等级：方法锁、对象锁、类锁</h2><details>
<summary><mark><font color="darkred">点击查看详细内容</font></mark></summary>

<blockquote>
<p><strong>1.方法锁：</strong> 通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。<br>synchronized方法控制对类成员变量的访问：  </p>
<ul>
<li>每个类实例对应一把锁  </li>
<li>每个synchronized方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞</li>
<li>方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态 </li>
<li>所有声明为synchronized的成员函数中至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。</li>
</ul>
<p><strong>2.对象锁（实例对象锁）：</strong> 当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。（<strong>方法锁也是对象锁</strong>）  </p>
<ul>
<li>Java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。</li>
<li>线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；</li>
<li>synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的1个好处，<strong>方法抛异常的时候，锁仍然可以由JVM来自动释放。</strong>　  </li>
</ul>
<p>对象锁的两种形式：  </p>
</blockquote>
<pre><code>public class Test {
    // 对象锁：形式1(方法锁) 
    public synchronized void Method1(){ 
        System.out.println(&quot;我是对象锁也是方法锁&quot;); 
        try{ 
            Thread.sleep(500); 
        } catch (InterruptedException e){ 
            e.printStackTrace(); 
        } 

    } 

    // 对象锁：形式2（代码块形式） 
    public void Method2(){ 
        synchronized (this){ 
            System.out.println(&quot;我是对象锁&quot;); 
            try{ 
                Thread.sleep(500); 
            } catch (InterruptedException e){ 
                e.printStackTrace(); 
            } 
        } 

    } 
}</code></pre><blockquote>
<p><strong>3.类锁（Class对象锁）</strong><br>&emsp;&emsp;类锁即synchronized修饰静态的方法或代码块。<br>&emsp;&emsp;由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只有一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。<br>&emsp;&emsp;类锁与对象锁区别为：<br>&emsp;&emsp;<strong>对象锁是用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步</strong><br>&emsp;&emsp;类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。<br>&emsp;&emsp;Java类可能会有很多个对象，但是只有1个Class对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个Java对象，只不过有点特殊而已。由于每个Java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。获取类的Class对象有好几种，最简单的就是［类名.class］的方式。<br>&emsp;&emsp;示例代码如下： </p>
</blockquote>
<pre><code>public class Test {
     // 类锁：形式1 
    public static synchronized void Method1(){ 
        System.out.println(&quot;我是类锁一号&quot;); 
        try{ 
            Thread.sleep(500); 
        } catch (InterruptedException e){ 
            e.printStackTrace(); 
        } 

    } 

    // 类锁：形式2 
    public void Method2(){ 
        synchronized (Test.class){ 
            System.out.println(&quot;我是类锁二号&quot;); 
            try{ 
                Thread.sleep(500); 
            } catch (InterruptedException e){ 
                e.printStackTrace(); 
            } 
        } 
    } 
}   </code></pre><p>原文：<a href="https://www.cnblogs.com/cherish010/p/8337706.html" target="_blank" rel="noopener">https://www.cnblogs.com/cherish010/p/8337706.html</a>  </p>
</details>  

<h2 id="46-写出生产者消费者模式"><a href="#46-写出生产者消费者模式" class="headerlink" title="46.写出生产者消费者模式"></a>46.写出生产者消费者模式</h2><blockquote>
<p>具体参考此文章：<a href="/blog/2020/03/20/生产者消费者模式/" target="_blank">生产者消费者模式</a>  </p>
</blockquote>
<h2 id="47-ThreadLocal的设计理念与作用。"><a href="#47-ThreadLocal的设计理念与作用。" class="headerlink" title="47.ThreadLocal的设计理念与作用。"></a>47.ThreadLocal的设计理念与作用。</h2><details>
<summary><mark><font color="darkred">点击查看详细内容</font></mark></summary>

<blockquote>
<p>Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量。   </p>
</blockquote>
<pre><code>public class ThreadLocalExample {

    public static class MyRunnable implements Runnable{

        private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();

        private int a=0;

        @Override
        public void run() {
            a = (int)(Math.random()*100);
            threadLocal.set(a);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(a+&quot;--&quot;+threadLocal.get());
        }
    }

    public static void main(String[] args) {
        MyRunnable sharedRunnableInstance = new MyRunnable();
        Thread thread1 = new Thread(sharedRunnableInstance);
        Thread thread2 = new Thread(sharedRunnableInstance);
        thread1.start();
        thread2.start();
    }
}  </code></pre><p>输出结果  </p>
<pre><code>26--27
26--26</code></pre><p>很明显普通变量a的值被第二个线程覆盖了，而使用了ThreadLocal对象之后，他们明显无法看到对方保存的值。<br><a href="https://blog.csdn.net/u011860731/article/details/48733073" target="_blank" rel="noopener">https://blog.csdn.net/u011860731/article/details/48733073</a>   </p>
</details>

<h2 id="48-Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。"><a href="#48-Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。" class="headerlink" title="48.Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。"></a>48.Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。</h2><details>
<summary><mark><font color="darkred">点击查看详细内容</font></mark></summary>

<blockquote>
<p>1.<strong>BlockingQueue(阻塞队列)：</strong>如果BlockingQueue是空的，从BlockingQueue取东西的操作将会被阻断进入等待状态，直到BlockingQueue进了东西才会被唤醒，同样，如果BlockingQueue是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到BlockingQueue里有空间时才会被唤醒继续操作。<br><br><strong>BlockingQueue有四个具体的实现类:</strong><br><strong>ArrayBlockingQueue：</strong>规定大小的BlockingQueue，其构造函数必须带一个int参数来指明其大小。其所含的对象是以FIFO（先入先出）顺序排序的。<br><strong>LinkedBlockingQueue：</strong>大小不定的BlockingQueue，若其构造函数带一个规定大小的参数，生成的BlockingQueue有大小限制，若不带大小参数，所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定。其所含的对象是以FIFO顺序排序的。<br><strong>PriorityBlockingQueue：</strong>类似于LinkedBlockingQueue,但其所含对象的排序不是FIFO，而是依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序。<br><strong>SynchronousQueue：</strong>特殊的BlockingQueue，对其的操作必须是放和取交替完成的。<br><br>2.<strong>semaphore：Java 并发库</strong> 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，acquire()获取一个许可，如果没有就等待，而release()释放一个许可。比如在Windows下可以设置共享文件的最大客户端访问个数。<br><br>3.<strong>countdownLatch：</strong> CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。（当每个线程调用countdown方法直到将countdownlatch方法创建时数减为0时，那么之前调用await（）方法的线程才会继续执行。有一点注意，那就是只执行一次，不能到0以后重新执行）。<br><br>4.<strong>CyclicBarrier：</strong>类有一个整数初始值，此值表示将在同一点同步的线程数量。当其中一个线程到达确定点，它会调用await() 方法来等待其他线程。当线程调用这个方法，CyclicBarrier阻塞线程进入休眠直到其他线程到达。当最后一个线程调用CyclicBarrier 类的await() 方法，它唤醒所有等待的线程并继续执行它们的任务。（当等待的线程数量达到CyclicBarrier线程指定的数量以后（调用await方法的线程数），才一起往下执行，否则大家都在等待，注意：如果达到指定的线程数量的时候：则可以重新计数，上面的过程可以循环）。<br><br>5.CountDownLatch是减计数方式，计数==0时释放所有等待的线程；CyclicBarrier是加计数方式，计数达到构造方法中参数指定的值时释放所有等待的线程。<br><a href="https://www.cnblogs.com/feicheninfo/p/9679042.html" target="_blank" rel="noopener">https://www.cnblogs.com/feicheninfo/p/9679042.html</a>  </p>
</blockquote>
</details> 

<h2 id="49-wait-和sleep-的区别。"><a href="#49-wait-和sleep-的区别。" class="headerlink" title="49.wait()和sleep()的区别。"></a>49.wait()和sleep()的区别。</h2><details>
<summary><mark><font color="darkred">点击查看详细内容</font></mark></summary>

<blockquote>
<p>sleep()是使线程暂停执行一段时间的方法。wait()也是一种使线程暂停执行的方法。例如，当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。并且可以调用notify（）方法或者notifyAll（）方法通知正在等待的其他线程。notify（）方法仅唤醒一个线程（等待队列中的第一个线程）并允许他去获得锁。notifyAll（）方法唤醒所有等待这个对象的线程并允许他们去竞争获得锁。具体区别如下：<br>1)  原理不同。sleep()方法是Thread类的静态方法，是线程用来控制自身流程的，他会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到计时时间一到，此线程会自动苏醒。例如，当线程执行报时功能时，每一秒钟打印出一个时间，那么此时就需要在打印方法前面加一个sleep()方法，以便让自己每隔一秒执行一次，该过程如同闹钟一样。而wait()方法是object类的方法，用于线程间通信，这个方法会使当前拥有该对象锁的进程等待，直到其他线程调用notify（）方法或者notifyAll（）时才醒来，不过开发人员也可以给他指定一个时间，自动醒来。<br>2)  对锁的 处理机制不同。由于sleep()方法的主要作用是让线程暂停执行一段时间，时间一到则自动恢复，不涉及线程间的通信，因此，调用sleep()方法并不会释放锁。而wait()方法则不同，当调用wait()方法后，线程会释放掉他所占用的锁，从而使线程所在对象中的其他synchronized数据可以被其他线程使用。<br>3)  使用区域不同。wait()方法必须放在同步控制方法和同步代码块中使用，sleep()方法则可以放在任何地方使用。sleep()方法必须捕获异常，而wait()、notify（）、notifyAll（）不需要捕获异常。在sleep的过程中，有可能被其他对象调用他的interrupt（），产生InterruptedException。由于sleep不会释放锁标志，容易导致死锁问题的发生，因此一般情况下，推荐使用wait（）方法。<br><a href="https://blog.csdn.net/qiuchaoxi/article/details/79837568" target="_blank" rel="noopener">https://blog.csdn.net/qiuchaoxi/article/details/79837568</a></p>
</blockquote>
</details> 

<h2 id="50-foreach与正常for循环效率对比"><a href="#50-foreach与正常for循环效率对比" class="headerlink" title="50.foreach与正常for循环效率对比"></a>50.foreach与正常for循环效率对比</h2><blockquote>
<p>对于for循环就是调用get(i)取得元素，而对于foreach是通过iterator实现的遍历。<br>对于ArrayList来说，它是通过一个数组实现的，可以随机存取；但是LinkedList是通过链表实现的，for循环时要获取第i个元素必须从头开始遍历，而iterator遍历就是从头开始遍历，遍历完只需要一次，所以for循环需要的时间远远超过foreach循环。<br>总结：<br>对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。  </p>
</blockquote>
<h2 id="51-Java-IO与NIO"><a href="#51-Java-IO与NIO" class="headerlink" title="51.Java IO与NIO"></a>51.Java IO与NIO</h2><blockquote>
<p><strong>概念：</strong><br>NIO即New IO，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同，NIO主要用到的是块，所以NIO的效率要比IO高很多。在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。<br><strong>区别：</strong><br><strong>1、面向流与面向缓冲：</strong>Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。<br><strong>2、阻塞与非阻塞IO：</strong>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。<br><strong>3、选择器（Selectors）</strong>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。<br><a href="https://www.jianshu.com/p/fc3542868c84" target="_blank" rel="noopener">https://www.jianshu.com/p/fc3542868c84</a>  </p>
</blockquote>
<h2 id="52-反射的作用与原理"><a href="#52-反射的作用与原理" class="headerlink" title="52.反射的作用与原理"></a>52.反射的作用与原理</h2><blockquote>
<p><strong>概念：</strong><br>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；<br>对于任意一个对象，都能够调用它的任意一个方法和属性；<br>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br><strong>作用：</strong><br>1.在运行时判断任意一个对象所属的类；<br>2.在运行时构造任意一个类的对象；<br>3.在运行时判断任意一个类所具有的成员变量和方法；<br>4.在运行时调用任意一个对象的方法；<br>5.生成动态代理。  </p>
</blockquote>
<h2 id="53-泛型常用特点，List-lt-String-gt-能否转为List-lt-Object-gt-。"><a href="#53-泛型常用特点，List-lt-String-gt-能否转为List-lt-Object-gt-。" class="headerlink" title="53.泛型常用特点，List&lt;String&gt;能否转为List&lt;Object&gt;。"></a>53.泛型常用特点，List&lt;String&gt;能否转为List&lt;Object&gt;。</h2><blockquote>
<p>不能。<br>String 是 Object 的子类型，但是 List&lt;String&gt; 不是 List&lt;Object&gt; 的子类型<br><a href="https://developer.aliyun.com/ask/128778?spm=a2c6h.13159736" target="_blank" rel="noopener">https://developer.aliyun.com/ask/128778?spm=a2c6h.13159736</a>  </p>
</blockquote>
<h2 id="54-解析XML的几种方式的原理与特点：DOM、SAX、PULL"><a href="#54-解析XML的几种方式的原理与特点：DOM、SAX、PULL" class="headerlink" title="54.解析XML的几种方式的原理与特点：DOM、SAX、PULL"></a>54.解析XML的几种方式的原理与特点：DOM、SAX、PULL</h2><blockquote>
<p>DOM:会一次性将所有内容读取到内存中，便于操作；支持删除、修改，重新排列等多种功能。不适合占用内存大的数据结构。<br>SAX:解析采用事件驱动型。解析效率高，占用内存少;可以随时停止解析。<br>PULL解析：解析原理类似SAX解析。不同点：pull读取xml文件后出发相应的事件调用方法返回的是数字；pull可以在程序中复制，想解析到那里就可以停止在哪里。  </p>
</blockquote>
<h2 id="55-Java1-7与1-8新特性"><a href="#55-Java1-7与1-8新特性" class="headerlink" title="55.Java1.7与1.8新特性"></a>55.Java1.7与1.8新特性</h2><blockquote>
<p><a href="/blog/2020/03/26/JAVA7与JAVA8的新特性/" target="_blank">JAVA7与JAVA8的新特性</a>   </p>
</blockquote>
<h2 id="56-设计模式：单例、工厂、适配器、责任链、观察者等等"><a href="#56-设计模式：单例、工厂、适配器、责任链、观察者等等" class="headerlink" title="56.设计模式：单例、工厂、适配器、责任链、观察者等等"></a>56.设计模式：单例、工厂、适配器、责任链、观察者等等</h2><blockquote>
<p><a href="/blog/2019/08/28/设计模式/" target="_blank">设计模式</a> </p>
</blockquote>
<h2 id="57-JNI的使用"><a href="#57-JNI的使用" class="headerlink" title="57.JNI的使用"></a>57.JNI的使用</h2><blockquote>
<p><a href="/blog/2019/08/21/java中native的用法/" target="_blank">java中native的用法</a></p>
</blockquote>
<h2 id="58-JVM面试知识点整理"><a href="#58-JVM面试知识点整理" class="headerlink" title="58.JVM面试知识点整理"></a>58.JVM面试知识点整理</h2><blockquote>
<p><a href="/blog/2020/03/26/JVM面试知识点/" target="_blank">JVM面试知识点</a>  </p>
</blockquote>
<h2 id="59-java死锁的原因例子及解决方法"><a href="#59-java死锁的原因例子及解决方法" class="headerlink" title="59.java死锁的原因例子及解决方法"></a>59.java死锁的原因例子及解决方法</h2><blockquote>
<p>Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。即线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。  </p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配算法</title>
    <url>/blog/2020/03/05/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给你两个字符串A和B，请你判断B是否A的子串，并返回B在A中第一次出现的位置。<br>什么意思呢？举个例子：<br>字符串A：a b <strong>c d e f</strong> g h<br>字符串B：<strong>c d e f</strong><br>在上面的例子中，字符串B是A的子串，B第一次在A中出现的位置下标是2（字符串的首位下标是0），所以返回 2。</p>
<a id="more"></a>  
<p>我们再看另一个例子：<br>字符串A：a b c d e f g h<br>字符串B：b c d g<br>在上面的例子中，字符串B在A中并不存在，所以返回 -1。<br>为了统一概念，在后文中，我们把字符串A称为主串，把字符串B称为模式串。    </p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><h3 id="2-1-BF算法-是Brute-Force（暴力算法）的缩写"><a href="#2-1-BF算法-是Brute-Force（暴力算法）的缩写" class="headerlink" title="2.1 BF算法(是Brute Force（暴力算法）的缩写)"></a>2.1 BF算法(是Brute Force（暴力算法）的缩写)</h3><p><strong>第一轮</strong>，我们从主串的首位开始，把主串和模式串的字符逐个比较：<br><img src="/blog/img/2020/03/05/BF算法1.jpg"><br><br>显然，主串的首位字符是a，模式串的首位字符是b，两者并不匹配。<br><strong>第二轮</strong>，我们把模式串后移一位，从主串的第二位开始，把主串和模式串的字符逐个比较：<br><img src="/blog/img/2020/03/05/BF算法2.png"><br><br>主串的第二位字符是b，模式串的第二位字符也是b，两者匹配，继续比较：<br><img src="/blog/img/2020/03/05/BF算法3.png"><br><br>主串的第三位字符是b，模式串的第三位字符也是c，两者并不匹配。<br><strong>第三轮</strong>，我们把模式串再次后移一位，从主串的第三位开始，把主串和模式串的字符逐个比较：<br><img src="/blog/img/2020/03/05/BF算法4.png"><br><br>主串的第三位字符是b，模式串的第三位字符也是b，两者匹配，继续比较：<br><img src="/blog/img/2020/03/05/BF算法5.png"><br><br>主串的第四位字符是c，模式串的第四位字符也是c，两者匹配，继续比较：<br><img src="/blog/img/2020/03/05/BF算法6.png"><br><br>主串的第五位字符是e，模式串的第五位字符也是e，两者匹配，比较完成！<br>由此得到结果，模式串 bce 是主串 abbcefgh 的子串，在主串第一次出现的位置下标是 2：<br><img src="/blog/img/2020/03/05/BF算法7.png"><br> </p>
<pre><code>public static int bruteForce(String a,String b){
    for (int i = 0; i &lt; a.length()-b.length()+1; i++) {
        //主串开始比较的起始位置
        int point = i;
        //是否匹配成功
        boolean flag = true;
        for (int j = 0; j &lt; b.length(); j++) {
            //开始进行匹配
            if((b.charAt(j) == a.charAt(point))){
                point++;
            }else{
                //只要有一个位置没有对应成功，修改标记，并结束内循环，重新开始下一轮的比较
                flag = false;
                break;
            }
        }
        if(flag){
            return i;
        }
    }
    return -1;
}</code></pre><p>虽然这个方法能解决问题，但是在极端情况下算法的效率会很低，举个例子：<br><img src="/blog/img/2020/03/05/BF算法8.png"><br><br>上图的情况，在每一轮进行字符匹配时，模式串的前三个字符a都和主串中的字符相匹配，一直检查到模式串最后一个字符b，才发现不匹配：<br><img src="/blog/img/2020/03/05/BF算法9.png"><br><br>这样一来，两个字符串在每一轮都需要白白比较4次，显然非常浪费。<br>假设主串的长度是m，模式串的长度是n，那么在这种极端情况下，BF算法的最坏时间复杂度是<strong>O（mn）</strong>。  </p>
<h3 id="2-2-RK算法-比较两个字符串的哈希值"><a href="#2-2-RK算法-比较两个字符串的哈希值" class="headerlink" title="2.2 RK算法(比较两个字符串的哈希值)"></a>2.2 RK算法(比较两个字符串的哈希值)</h3><p>比较哈希值是什么意思呢？<br>用过哈希表的朋友们都知道，每一个字符串都可以通过某种哈希算法，转换成一个整型数，这个整型数就是hashcode：<br>hashcode = hash（string）<br>显然，相对于逐个字符比较两个字符串，仅比较两个字符串的hashcode要容易得多。<br><img src="/blog/img/2020/03/05/RK算法1.png"><br><br>给定主串和模式串如下（假定字符串只包含26个小写字母）：<br><img src="/blog/img/2020/03/05/RK算法2.png"><br><br><strong>第一步，我们需要生成模式串的hashcode。</strong><br>生成hashcode的算法多种多样，比如：<br><strong>按位相加</strong><br>这是最简单的方法，我们可以把a当做1，b当做2，c当做3……然后把字符串的所有字符相加，相加结果就是它的hashcode。<br>bce =  2 + 3 + 5 = 10<br>但是，这个算法虽然简单，却很可能产生hash冲突，比如bce、bec、cbe的hashcode是一样的。<br><strong>转换成26进制数</strong><br>既然字符串只包含26个小写字母，那么我们可以把每一个字符串当成一个26进制数来计算。<br>bce = 2x(26^2) + 3x26 + 5 = 1435<br>这样做的好处是大幅减少了hash冲突，缺点是计算量较大，而且有可能出现超出整型范围的情况，需要对计算结果进行取模。<br>为了方便演示，后续我们采用的是按位相加的hash算法，所以bce的hashcode是10：<br><img src="/blog/img/2020/03/05/RK算法3.jpg"><br><br><strong>第二步，生成主串当中第一个等长子串的hashcode。</strong><br>由于主串通常要长于模式串，把整个主串转化成hashcode是没有意义的，只有比较主串当中<strong>和模式串等长的子串</strong>才有意义。<br>因此，我们首先生成主串中第一个和模式串等长的子串hashcode，<br>即abb = 1 + 2 + 2 = 5：<br><img src="/blog/img/2020/03/05/RK算法4.png"><br><br><strong>第三步，比较两个hashcode。</strong><br>显然，5！=10，说明模式串和第一个子串不匹配，我们继续下一轮比较。<br><strong>第四步，生成主串当中第二个等长子串的hashcode。</strong><br>bbc = 2 + 2 + 3 = 7：<br><img src="/blog/img/2020/03/05/RK算法5.jpg"><br><br><strong>第五步，比较两个hashcode。</strong><br>显然，7！=10，说明模式串和第二个子串不匹配，我们继续下一轮比较。<br><strong>第六步，生成主串当中第三个等长子串的hashcode。</strong><br>bce= 2 + 3 + 5 = 10：<br><img src="/blog/img/2020/03/05/RK算法6.jpg"><br><br><strong>第七步，比较两个hashcode。</strong><br>显然，10 ==10，两个hash值相等！这是否说明两个字符串也相等呢？<br>别高兴的太早，由于存在hash冲突的可能，我们还需要进一步验证。<br><strong>第八步，逐个字符比较两字符串。</strong><br>hashcode的比较只是初步验证，之后我们还需要像BF算法那样，对两个字符串逐个字符比较，最终判断出两个字符串匹配。<br><img src="/blog/img/2020/03/05/RK算法7.png"><br><br>最后得出结论，模式串bce是主串abbcefgh的子串，第一次出现的下标是2。<br><img src="/blog/img/2020/03/05/RK算法8.png"><br><br>什么意思呢？让我们再来看一个例子：<br><img src="/blog/img/2020/03/05/RK算法9.png"><br><br>上图中，我已知子串abbcefg的hashcode是26，那么如何计算下一个子串，也就是bbcefgd的hashcode呢？<br><img src="/blog/img/2020/03/05/RK算法10.png"><br><br>我们没有必要把子串的字符重新进行累加运算，而是可以采用一个更简单的方法。由于新子串的前面少了一个a，后面多了一个d，所以：<br><strong>新hashcode = 旧hashcode - 1 + 4 = 26-1+4 = 29</strong><br>再下一个子串bcefgde的计算也是同理：<br><strong>新hashcode = 旧hashcode - 2 + 5 = 29-2+5 = 32</strong></p>
<pre><code>public static int rabinKarp(String a,String b){
    //主串长度
    int m = a.length();
    //模式串长度
    int n = b.length();
    //计算模式串哈希值
    int bHashCode = hash(b);
    //计算主串当中第一个和模式串等长的子串的hash值
    int aHashCode = hash(a.substring(0,n));
    for (int i = 0; i &lt; m-n+1; i++) {
        if(bHashCode == aHashCode &amp;&amp; compareString(i,a,b)){
            return i;
        }
        //如果不是最后一轮，更新主串从i到i+n的hash值
        if(i&lt;m-n){
            aHashCode = nextHash(a,aHashCode,i,n);
        }
    }
    return -1;
}

private static int hash(String str){
    int hashcode = 0;
    //这里采用最简单的hashcode计算方式：
    //把a当做1，把b当中2，把c当中3.....然后按位相加
    for (int i = 0; i &lt; str.length(); i++) {
        hashcode +=(str.charAt(i)-&apos;a&apos;);
    }
    return hashcode;
}

private static int nextHash(String str,int hash,int index,int n){
    hash -=str.charAt(index)-&apos;a&apos;;
    hash +=str.charAt(index+n)-&apos;a&apos;;
    return hash;
}

private static boolean compareString(int i,String a,String b){
    String subStr = a.substring(i,i+b.length());
    return subStr.equals(b);
}</code></pre><p>RK算法计算单个子串hash的时间复杂度是O(n)，但由于后续的子串hash是增量计算，所以总的时间复杂度仍然是O(n)。<br>相比于BF算法，RK算法采用哈希值比较的方式，免去了许多无谓的字符串比较，所以时间复杂度大大提高了。<br>RK算法的不足之处：RK算法的缺点在于哈希冲突。每一次哈希冲突的时候，RK算法都要对子串和模式串进行逐个字符的比较，如果冲突太多了，RK算法就退化成了BF算法。  </p>
<h3 id="2-3-BM算法"><a href="#2-3-BM算法" class="headerlink" title="2.3 BM算法"></a>2.3 BM算法</h3><p>上面讲的RK算法回避了字符的直接比较，改为比较两个字符串的哈希值。但这样可能产生哈希冲突，性能并不稳定。<br>那么，我们能否仍然用字符串比较的思路呢，并且尽量减少无谓的比较呢？这就是BM算法的努力方向。<br>为了能减少比较，BM算法制定了两条规则，一个是[坏字符串规则]，一个是[好后缀规则]。<br><strong>坏字符规则</strong><br>“坏字符” 是什么意思？就是指模式串和子串当中不匹配的字符。<br>还以上面的字符串为例，当模式串和主串的第一个等长子串比较时，子串的最后一个字符T就是坏字符：<br><img src="/blog/img/2020/03/06/BM算法1.jpg"><br><br><img src="/blog/img/2020/03/06/小灰1.jpg"><br><br>当检测到第一个坏字符之后，我们有必要让模式串一位一位向后挪动和比较吗？并不需要。<br>因为只有<strong>模式串与坏字符T对齐的位置也是字符T的情况下，</strong>两者才有匹配的可能。<br>不难发现，模式串的第1位字符也是T，这样一来我们就可以对模式串做一次“乾坤大挪移”，直接把模式串当中的字符T和主串的坏字符对齐，进行下一轮的比较：<br><img src="/blog/img/2020/03/06/BM算法2.png"><br><br>坏字符的位置越靠右，下一轮模式串的挪动跨度就可能越长，节省的比较次数也就越多。这就是BM算法从右向左检测的好处。<br>接下来，我们继续逐个字符比较，发现右侧的G、C、G都是一致的，但主串当中的字符A，是又一个坏字符：<br><img src="/blog/img/2020/03/06/BM算法3.png"><br><br>我们按照刚才的方式，找到模式串的第2位字符也是A，于是我们把模式串的字符A和主串中的坏字符对齐，进行下一轮比较：<br><img src="/blog/img/2020/03/06/BM算法4.png"><br><br>接下来，我们继续逐个字符比较，这次发现全部字符都是匹配的，比较公正完成：<br><img src="/blog/img/2020/03/06/BM算法5.png"><br><br><img src="/blog/img/2020/03/06/小灰2.jpg"><br><br><img src="/blog/img/2020/03/06/BM算法6.png"><br> </p>
<p><strong>代码实现，这段代码是BM算法的阉割版实现</strong>  </p>
<pre><code>public static int boyerMoore(String a,String b){
    //主串长度
    int m = a.length();
    //模式串长度
    int n = b.length();
    //模式串的起始位置
    int start = 0;
    while(start &lt;= m-n){
        int i;
        //从后向前，逐个字符比较
        for (i=n-1; i&gt;=0; i--) {
            if(a.charAt(start+i)!=b.charAt(i)){
                //发现坏字符串，跳出比较，i记录了坏字符串的位置
                break;
            }
        }
        if(i&lt;=0){
            //匹配成功，返回第一次匹配的下标位置
            return start;
        }
        //寻找坏字符串在模式串中的对应  
        int charIndex = findCharacter(b,a.charAt(start+i),i);
        //计算坏字符串产生的位移
        int bcOffset = charIndex&gt;=0?i-charIndex:i+1;
        start +=bcOffset;
    }
    return -1;
}

private static int findCharacter(String b, char badCharacter, int index) {
    for (int i = index-1; i&gt;=0; i--) {
        if(b.charAt(i) == badCharacter){
            return i;
        }
    }
    //模式串不存在该字符串，则返回-1
    return -1;
}</code></pre><p>为什么说它是阉割版代码呢？<br>因为坏字符串规则只是BM算法额两大法宝之一，除此之外它还具有另一件法宝:[好后缀规则]。<br><strong>好后缀规则</strong><br>“好后缀” 又是什么意思？就是指模式串和子串当中相匹配的后缀。<br>让我们看一组新的例子：<br><img src="/blog/img/2020/03/06/BM算法7.png"><br><br>对于上面的例子，如何我们继续使用“坏字符规则”，会有怎样的效果呢？<br>从后向前比对字符，我们发现后面三个字符都是匹配的，到了第四个字符的时候，发现坏字符G：<br><img src="/blog/img/2020/03/06/BM算法8.png"><br><br>接下来我们在模式串找到了对应的字符G，但是按照坏字符规则，模式串仅仅能够向后挪动一位：<br><img src="/blog/img/2020/03/06/BM算法9.jpg"><br><br>这时候坏字符规则显然并没有起到作用，为了能真正减少比较次数，轮到我们的好后缀规则出场了。由于好后缀规则的实现细节比坏字符规则要难理解得多，所以我们这里只介绍一个大概思路：<br><img src="/blog/img/2020/03/06/BM算法10.png"><br><br>我们回到第一轮的比较过程，发现主串和模式串都有共同的后缀“GCG”，这就是所谓的“好后缀”。<br>如果模式串其他位置也包含与“GCG”相同的片段，那么我们就可以挪动模式串，让这个片段和好后缀对齐，进行下一轮的比较：<br><img src="/blog/img/2020/03/06/BM算法11.jpg"><br><br>显然，在这个例子中，采用好后缀规则能够让模式串向后移动更多位，节省了更多无谓的比较。<br><img src="/blog/img/2020/03/06/小灰3.jpg"><br><br><img src="/blog/img/2020/03/06/BM算法12.jpg"><br><br><img src="/blog/img/2020/03/06/小灰4.jpg"><br><br><img src="/blog/img/2020/03/06/BM算法13.jpg"><br><br><img src="/blog/img/2020/03/06/小灰5.jpg"><br><br><img src="/blog/img/2020/03/06/小灰6.jpg"><br><br><img src="/blog/img/2020/03/06/小灰7.jpg"><br><br><img src="/blog/img/2020/03/06/小灰8.jpg"><br></p>
<p><strong>坏字符规则+好后缀规则代码实现(后续加入)</strong> </p>
<h3 id="2-4-KMP算法"><a href="#2-4-KMP算法" class="headerlink" title="2.4 KMP算法"></a>2.4 KMP算法</h3><p>和BM算法类似，KMP算法也在视图减少无谓的字符比较。为了实现这一点，KMP算法把专注点放在了[已匹配的前缀]。<br><strong>KMP算法的整体思路</strong> </p>
]]></content>
  </entry>
  <entry>
    <title>Bitmap的巧用</title>
    <url>/blog/2020/03/05/%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/Bitmap%E7%9A%84%E5%B7%A7%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-1-一个关于用户标签的需求"><a href="#1-1-一个关于用户标签的需求" class="headerlink" title="1.1 一个关于用户标签的需求"></a>1.1 一个关于用户标签的需求</h2><a id="more"></a>
<p><img src="/blog/img/2020/03/05/一个关于用户标签的需求1.png"><br><br><img src="/blog/img/2020/03/05/一个关于用户标签的需求2.png"><br><br><img src="/blog/img/2020/03/05/小灰的用户标签.png"><br><br><img src="/blog/img/2020/03/05/一个关于用户标签的需求3.png"><br><br>为了满足用户标签的统计需求，小灰利用关系型数据库设计了如下的表结构，每一个维度的标签对应着数据库表中的一列。<br><img src="/blog/img/2020/03/05/表格1.png"><br><br>要想统计所有“90后”的程序员，该怎么做呢？<br>用一条求交集的SQL语句即可。  </p>
<blockquote>
<p>Select count（distinct Name）as 用户数 from table where age = ‘90 后’ and Occupation = ‘程序员’ ;  </p>
</blockquote>
<p>要想统计所有使用苹果手机或“00后”的用户总和，该怎么做呢？<br>用一条求并集的SQL语句即可。  </p>
<blockquote>
<p>Select count （distinct Name） as 用户数 from table where Phone = ‘苹果’ or age = ‘00 后’ ;  </p>
</blockquote>
<p><img src="/blog/img/2020/03/05/小灰1.png"><br><br>两个月之后······<br><img src="/blog/img/2020/03/05/小灰2.png"><br><br><img src="/blog/img/2020/03/05/小灰3.png"><br><br><img src="/blog/img/2020/03/05/小灰4.png"><br><br><img src="/blog/img/2020/03/05/小灰5.png"><br> </p>
<h2 id="1-2-用算法解决问题"><a href="#1-2-用算法解决问题" class="headerlink" title="1.2 用算法解决问题"></a>1.2 用算法解决问题</h2><p><img src="/blog/img/2020/03/05/位图算法.png"><br><br>很简单，具体做法如下。<br>第1步，给出一块长度为10的Bitmap，其中的每一个bit位分别对应着从0到9的整型数。此时，Bitmap的所有位都是0（用紫色表示）。<br><img src="/blog/img/2020/03/05/位图算法1.png"><br><br>第2步，把整型数4存入Bitmap，对应存储的位置就是下标为4的位置，将此bit设置为1（用黄色表示）。<br><img src="/blog/img/2020/03/05/位图算法2.png"><br><br>第3步，把整型数2存入Bitmap，对应存储的位置就是下标为2的位置，将此bit设置为1。<br><img src="/blog/img/2020/03/05/位图算法3.png"><br><br>第4步，把整型数1存入Bitmap，对应存储的位置就是下标为1的位置，将此bit设置为1。<br><img src="/blog/img/2020/03/05/位图算法4.png"><br><br>第5步，把整型数3存入Bitmap，对应存储的位置就是下标为3的位置，将此bit设置为1。<br><img src="/blog/img/2020/03/05/位图算法5.png"><br><br>如果问此时Bitmap里存储了哪些元素。显然是4、3、2、1，一目了然。Bitmap不仅方便查询，还可以去掉重复的整数。<br><img src="/blog/img/2020/03/05/小灰6.png"><br><br>第1步，建立用户名和用户ID的映射。<br><img src="/blog/img/2020/03/05/表格2.png"><br><br>第2步，让每一个标签存储包含此标签的所有用户ID，每一个标签都是一个独立的Bitmap。<br><img src="/blog/img/2020/03/05/表格3.png"><br><br>这样一来，每一个用户特征都变得一目了然。<br>例如程序员和“00后”这两个群体，各自的Bitmap分别如下。<br><img src="/blog/img/2020/03/05/表格4.png"><br><br><img src="/blog/img/2020/03/05/小灰7.png"><br><br><strong>1.如何查找使用苹果手机的程序员用户</strong><br><img src="/blog/img/2020/03/05/表格5.png"><br><br><strong>2.如何查找所有男性用户或“00后”用户</strong><br><img src="/blog/img/2020/03/05/表格6.png"><br><br><img src="/blog/img/2020/03/05/小灰8.png"><br><br>会出现什么问题呢？我们来看一看。<br>“90后”用户的Bitmap如下。<br><img src="/blog/img/2020/03/05/表格7.png"><br><br>如果想得到非“90后” 的用户，能够直接进行非运算吗？<br><img src="/blog/img/2020/03/05/表格8.png"><br><br>显然，非“90后”用户实际上只有1个，而不是图中所得到的8个结果，所以不能直接进行非运算。<br><img src="/blog/img/2020/03/05/小灰9.png"><br><br>同样是刚才的例子，我们给出“90后”用户的Bitmap，再给出一个全量用户的Bitmap。最终要求出的是存在于全量用户，但又不存在于“90后”用户的部分。<br><img src="/blog/img/2020/03/05/表格9.png"><br><br>如何求出这部分用户呢？我们可以使用<strong>异或</strong> 运算进行操作，即相同位为0，不同位为1。<br><img src="/blog/img/2020/03/05/表格10.png"><br><br><img src="/blog/img/2020/03/05/小灰10.png"><br> </p>
<pre><code>public class MyBitmap {

    //每一个word是一个long类型元素，对应一个64位二进制数据
    private long[] words;
    //Bitmap的位数大小
    private int size;

    public MyBitmap(int size){
        this.size=size;
        this.words = new long[getWordIndex(size-1)+1];
    }

    /**
     * 判断Bitmap某一位的状态
     * @param bitIndex 位图的第bitIndex位(bitIndex=0代表Bitmap左数第1位)
     * @return
     */
    public boolean getBit(int bitIndex) throws Exception{
        if(bitIndex &lt; 0 || bitIndex&gt;size-1){
            throw new Exception(&quot;超过Bitmap有效范围&quot;);
        }
        int wordIndex = getWordIndex(bitIndex);
        return (words[wordIndex]&amp;(1L &lt;&lt; bitIndex))!=0;
    }

    /**
     * 把Bitmap的某一位设置为true
     * @param bitIndex 位图的第bitIndex位(bitIndex=0代表Bitmap左数第1位)
     */
    public void setBit(int bitIndex) throws Exception{
        if(bitIndex &lt; 0 || bitIndex&gt;size-1){
            throw new Exception(&quot;超过Bitmap有效范围&quot;);
        }
        int wordIndex = getWordIndex(bitIndex);
        words[wordIndex] |= (1L &lt;&lt; bitIndex);
    }


    /**
     * 定位Bitmap某一位所对应的word
     * @param bitIndex 位图的第bitIndex(bitIndex=0代表Bitmap左数第1位)
     * @return
     */
    private int getWordIndex(int bitIndex) {
        //右移6位，相当于除以64
        return bitIndex&gt;&gt;6;
    }

    public static void main(String[] args) throws Exception {
        MyBitmap bitmap = new MyBitmap(128);
        bitmap.setBit(126);
        bitmap.setBit(75);
        System.out.println(bitmap.getBit(126));
        System.out.println(bitmap.getBit(78));
    }
}</code></pre><p>在上述代码中，<strong>使用一个命名为words的long类型数组来存储所有的二进制位。每一个long元素占用其中的64位</strong> 。 </p>
<p>如果要把Bitmap的某一位设为1，需要经过两步。</p>
<ol>
<li>定位到words中的对应的long元素。  </li>
<li>通过与运算修改long元素的值。<br>如果要查看Bitmap的某一位是否为1，也需要经过两步。  </li>
<li>定位到words中的对应的long元素。  </li>
<li>判断long元素的对应的二进制位是否为1。<br>有了Bitmap的基本读写操作，该如何实现两个Bitmap的与、或、异或运算呢？感兴趣的读者可以思考一下。<br><img src="/blog/img/2020/03/05/小灰11.png"><br><br>虽然有现成的工具类和数据库，但我们仍然应该了解Bitmap算法的底层原理和实现方式。  </li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>算法的实际运用</title>
    <url>/blog/2020/03/05/%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<p>这里整理了一些算法的实际应用。  </p>
<a id="more"></a>  

<p><strong>传送门</strong> </p>
<ul>
<li>1.<a href="/blog/2020/03/05/算法的实际应用/Bitmap的巧用/" target="_blank">Bitmap的巧用</a>  </li>
<li></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>寻找缺失的整数</title>
    <url>/blog/2020/03/04/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>在一个无序数组里面有99个不重复的正整数，范围是1<del>100，唯独缺少1个1</del>100中的整数。如何找出这个缺失的整数。  </p>
<a id="more"></a>  

<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>方法很简单也很高效，也不需要进行排序，先算出1+2+3+···+100的和，然后依次减去数组里的元素，最后得到的这个差值就是缺失的那个整数。<br>假设数组长度是n，那么该解法的时间复杂度是O(n)，空间复杂度是O(1)。  </p>
<p>这个解法对于没有重复元素的数组来说，在时间上和空间上已经最优了。那么现在我们扩展一下。  </p>
<h2 id="3-问题扩展"><a href="#3-问题扩展" class="headerlink" title="3.问题扩展"></a>3.问题扩展</h2><h3 id="3-1-题目第1次扩展"><a href="#3-1-题目第1次扩展" class="headerlink" title="3.1 题目第1次扩展"></a>3.1 题目第1次扩展</h3><p>一个无序数组里有若干个正整数，范围是1~100，其中99个整数都出现了<strong>偶数次</strong> ，只有1个整数出现了<strong>奇数次</strong>，如何找到这个出现奇数次的整数？  </p>
<p><strong>解题思路</strong><br>使用<strong>异或运算</strong>（相同位得0，不同位得1）。<br><img src="/blog/img/2020/03/04/异或运算.png"><br><br>由于异或运算在进行位运算时，相同为0，不同为1，所以一个整数异或他自己时等于0，也就是会互相抵消，这就意味着所有出现偶数次的整数都会相互抵消变成0，只有唯一出现奇数次数的整数会被保留下。<br>所以我们只需要遍历一次数组，让里面的每个元素进行异或运算，就能得出结果。<br>假设数组长度为n，那么该解法的时间复杂度是O(n)，空间复杂度是O(1)。  </p>
<h3 id="3-2-题目第2次扩展"><a href="#3-2-题目第2次扩展" class="headerlink" title="3.2 题目第2次扩展"></a>3.2 题目第2次扩展</h3><p>假设一个无序数组里有若干个正整数，范围是1~100，其中有98个整数出现了偶数次数，只有<strong>2个</strong> 整数出现了奇数次数，如何找出这两个奇数次的整数？  </p>
<p><strong>解题思路</strong><br>提示：<strong>分治法</strong><br>如果我们把数组分成两部分，保证每一部分都包含1个出现奇数次数的整数，这样就与上一题的情况一样了。<br>首先我们把数组元素依次进行异或运算，得到的结果是2个出现了奇数次数的整数的异或运算结果，在这个结果中至少有1个二进制位是1。  </p>
<p>解法：<br>把2个出现了奇数次的整数命名为A和B。遍历整个数组，然后依次做异或运算，进行异或运算的最终结果，等同于A和B进行异或运算的结果。在这个结果中，至少会有一个二进制位是1(如果都是0，说明A和B相等，和题目不相符)。<br>举个例子，给出一个无序数组{4,1,2,2,5,1,4,3}，所有元素进行异或运算的结果是00000110B。<br><img src="/blog/img/2020/03/04/异或运算2.png"><br><br>确定该结果中值1的某一位数字，如果00000110B的倒数第2位是1，这说明A和B对应的二进制的倒数第2位是不同的。其中必定有一个整数的倒数第2位是0，另一个整数的倒数第2位是1。<br>根据这个结论，可以把原数组按照二进制的倒数第2位的不同，分成两个部分，一部分的倒数第2位是0，另一部分的倒数第2位是1。由于A和B的倒数第2位不同，所以A被分配到其中一部分，B被分配到另一部分，绝不会出现A和B在同一部分，另一部分既没有A，也没有B的情况。<br><img src="/blog/img/2020/03/04/异或运算3.png"><br><br>这样一来就简单多了，我们的问题又回归到了上一题的情况，按照原先的异或运算法，从每一部分中找出唯一的奇数次整数即可。<br>假设数组长度为n，那么该解法的时间复杂度是O(n)。把数组分成两部分，并不需要借助额外的存储空间，完全可以在按二进制分组的同时来做异或运算，所以空间复杂度仍然是O(1)。  </p>
<p><strong>代码实现</strong>  </p>
<pre><code>public class Exercise {

    public static int[] findLostNum(int[] arr){
        //用于存储2个出现奇数次数的整数
        int[] result = new int[2];
        //第1次进行整体异或运算
        int xorResult = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            xorResult ^=arr[i];
        }
        //如果进行异或运算的运算结果为0，则说明输入的数组不符合题目要求
        if(xorResult == 0){
            return null;
        }
        //确定两个整数的不同位，以此来分组
        int separator = 1;
        while(0==(xorResult&amp;separator)){
            separator&lt;&lt;=1;
        }
        //第2次分组进行异或运算
        for (int i = 0; i &lt; arr.length; i++) {
            if(0==(arr[i]&amp;separator)){
                result[0] ^=arr[i];
            }else{
                result[1] ^=arr[i];
            }
        }
        return result;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{4,1,2,2,5,1,4,3};
        arr = findLostNum(arr);
        System.out.println(Arrays.toString(arr));
    }
}</code></pre>]]></content>
  </entry>
  <entry>
    <title>如何求解金矿问题</title>
    <url>/blog/2020/03/04/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A6%82%E4%BD%95%E6%B1%82%E8%A7%A3%E9%87%91%E7%9F%BF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>很久很久以前，有一位国王拥有5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人人数也不同。例如有的黄金储量是500kg黄金，需要5个人来挖掘；有的金矿储量是200kg，需要3个人来挖掘······<br>如果参与挖矿的工人的总数是10。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半的金矿。要求用程序求出，要想得到尽可能多的黄金，应该选择挖取那几座金矿？<br><img src="/blog/img/2020/03/04/金矿问题.png"><br>  </p>
<a id="more"></a>  

<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>这是一个典型的<strong>动态规划</strong>题目，和著名的“背包问题”类似。<br>所谓动态规划，就是把复杂的问题简化成规模较小的子问题，再从简单的子问题自底向上一步一步递推，最终得到复杂问题的最优解。  </p>
<p>首先，对于问题中的金矿采集来说，每一个金矿都存在着“挖”和“不挖”两种选择。<br>让我们假设一下，如果最后一个金矿注定不被挖掘，那么问题会转化成什么样子呢？<br>显然，问题简化成了10个工人在前4个金矿中做出最优选择。<br><img src="/blog/img/2020/03/04/金矿问题解法11.png"><br><br>相应地，假设最后一个金矿一定会被挖掘，那么问题又转化成什么样子呢？<br>由于最后一个金矿消耗了3个工人，问题简化成了7个工人在前4个金矿中做出最优选择。<br><img src="/blog/img/2020/03/04/金矿问题解法12.png"><br><br>这两种简化情况，被称为全局问题的两个<strong>最优子结构</strong> 。<br>究竟哪一种最优子结构可以通向全局最优解呢？，换句话说，最后一个金矿到底该不该挖呢？<br>那就要看<strong>10个工人在前4个金矿的收益，和7个工人在前4四个金矿金矿的收益+最后一个金矿的收益</strong>谁大谁小了。<br><img src="/blog/img/2020/03/04/金矿问题解法13.png"><br><br>同样的道理，对于前4个金矿的选择，我们还可以做进一步简化。<br>首先针对10个工人4个金矿这个子结构，第4个金矿(300kg黄金/4人)可以选择挖与不挖。根据第4个金矿的选择，问题又简化成了两种更小的子结构。<br><strong>1.10个工人在前3个金矿中做出最优选择。</strong><br><strong>2.6（10-4=6）个工人在前3个金矿中做出最优选择。</strong><br>相应地，对于7个工人4个金矿这个子结构，第4个金矿同样可以选择挖与不挖。根据第4个金矿的选择，问题也简化成了两种更小的子结构。<br><strong>1.7个工人在前3个金矿中做出最优选择。</strong><br><strong>2.3（7-4=3）个工人在前3个金矿中做出最优选择。</strong><br>……<br>就这样，问题一分为二，二分为四，一直把问题简化成在0个金矿或0个工人时的最优选择，这个收益结果显然是0，也就是问题的<strong>边界</strong> 。   </p>
<p>这就是动态规划的要点：<strong>确定全局最优解和最优子结构之间的关系，以及问题的边界。</strong><br>这个用数学公式来表达的话么就叫做<strong>状态转移方程式。</strong>  </p>
<p>我们把金矿数量设为n，工人数量设为w，金矿的含金量设为数组g[]，金矿所需开采人数设为数组p[]，设F(n,w)为n个金矿、w个工人时的最优收益函数，那么状态方程式如下：<br>&emsp;&emsp;&emsp;&emsp;<strong>F(n,w) = 0(n=0或w=0)</strong><br>问题边界，金矿数为0或工人数为0的情况。<br>&emsp;&emsp;&emsp;&emsp;<strong>F(n,w) = F(n-1,w)(n&gt;=1或w&lt;p[n-1])</strong><br>当所剩工人不够挖掘当前金矿时，只有一种最优子结构。<br>&emsp;&emsp;&emsp;&emsp;<strong>F(n,w) = max(F(n-1,w),F(n-1,w-p[n-1])+g[n-1])(n&gt;=1,w&gt;=p[n-1])</strong><br>在常规情况下，具有两种最优子结构(挖当前金矿或不挖当前金矿)。  </p>
<p><strong>代码实现</strong>  </p>
<pre><code>public class Exercise {

    /**
     * 获取金矿的最优收益
     * @param w 工人数量
     * @param n 可选金矿数
     * @param p 金矿开采所需的工人数量
     * @param g 金矿储量
     * @return
     */
    public static int getBestGoldMining(int w,int n,int[] p,int[] g){
        if(w==0 || n==0){
            return 0;
        }
        if(w&lt;p[n-1]){
            return getBestGoldMining(w,n-1,p,g);
        }
        return Math.max(getBestGoldMining(w, n-1, p, g), getBestGoldMining(w-p[n-1],n-1,p,g)+g[n-1]);
    }


    public static void main(String[] args) {
        //工人数
        int w=10;
        //金矿所需开采人数 数组
        int[] p = new int[]{5,5,3,4,3};
        //金矿的含金量 数组
        int[] g = new int[]{400,500,200,300,350};
        System.out.println(&quot;最优收益： &quot;+getBestGoldMining(w,g.length,p,g));
    }
}</code></pre><p>但是这样虽然得到了正确结果，但是你有注意到这段代码的时间复杂度吗？<br>让我们来分析一下，全局问题经过简化，会拆解成两个子结构；两个子结构再次简化，会拆解成4个更小的子结构。就像下图一样。<br><img src="/blog/img/2020/03/04/金矿问题解法1的不足.png"><br><br>你会发现这样算下来，如果金矿数量是n，工人数量充足，时间复杂度就是<strong>O(n²)！</strong>为什么会这样？<br>因为递归做了许多重复的计算，你看上图中，标位红色的方法调用是重复的。可以看到F(2,7)、F(1,7)、F(1,2)，这几个入参相同的方法都被调用了两次。<br>当金矿数为5时，重复调用的问题还不太明显，当金矿数量越多，递归层次越深，重复调用也就越来越多，这些无谓的调用必然会降低程序的性能。  </p>
<p>那么我们该如何避免这些重复调用呢？<br>这就要说到动态规划的另一个核心要点：<strong>自底向上求解。</strong>让我们来详细演示一下这种求解过程。<br>在进行求解之前，先准备一张表格，用于记录选择金矿的中间数据。<br><img src="/blog/img/2020/03/04/金矿问题解法21.png"><br><br>表格最左侧代表不同的金矿选择范围，从上到下，每增加1行，就代表多1个金矿可供选择，也就是F(n,w)函数中的n值。<br>表格的最上方代表工人数量，从1个工人到10个工人，也就是F(n,w)函数中的w值。<br>其余空白的格子，都是等待填写的，代表当给出n个金矿、w个工人时的最优收益，也就是F(n,w)的值。<br>举个例子，下面中绿色的这个格子里，应该填充的是在有5个工人的情况下，在前3个金矿可供选择时，最优的黄金收益。<br><img src="/blog/img/2020/03/04/金矿问题解法22.png"><br><br>下面我们重第1行第1列开始，尝试把空白的格子一一填满，填充的依据就是状态转移方程式。<br>对于第1行的前4个格子，由于w&lt;p[n-1]，对应的状态转移方程式如下：<br>&emsp;&emsp;&emsp;&emsp;<strong>F(n,w) = F(n-1,w)(n&gt;=1或w&lt;p[n-1])</strong><br>带入求解：<br>&emsp;&emsp;&emsp;&emsp; F(1,1) = F(1-1,1) = F(0,1) = 0<br>&emsp;&emsp;&emsp;&emsp; F(1,2) = F(1-1,2) = F(0,2) = 0<br>&emsp;&emsp;&emsp;&emsp; F(1,3) = F(1-1,3) = F(0,3) = 0<br>&emsp;&emsp;&emsp;&emsp; F(1,4) = F(1-1,4) = F(0,4) = 0<br><img src="/blog/img/2020/03/04/金矿问题解法23.png"><br><br>第1行第6个格子怎么计算呢？此时w&gt;=p[n-1]，对于如下公式：<br>&emsp;&emsp;&emsp;&emsp;<strong>F(n,w) = max(F(n-1,w),F(n-1,w-p[n-1])+g[n-1])(n&gt;1,w&gt;=p[n-1])；</strong><br>带入求解：<br>&emsp;&emsp;&emsp;&emsp; F(1,5) = max(F(1-1,5),F(1-1,5-5)+400) = max(F(0,5),F(0,0)+400) = max(0,400) = 400<br>&emsp;&emsp;&emsp;&emsp; F(1,6) = max(F(1-1,6),F(1-1,6-5)+400) = max(F(0,6),F(0,1)+400) = max(0,400) = 400<br>&emsp;&emsp;&emsp;&emsp; ······<br>&emsp;&emsp;&emsp;&emsp; F(1,10) = max(F(1-1,10),F(1-1,10-5)+400) = max(F(0,5),F(0,5)+400) = max(0,400) = 400<br><img src="/blog/img/2020/03/04/金矿问题解法24.png"><br><br>对于第2行的前4个格子，和第1行同理，由于w&lt;p[n-1]，对应的状态转移方程式如下：<br>&emsp;&emsp;&emsp;&emsp;<strong>F(n,w) = F(n-1,w)(n&gt;=1或w&lt;p[n-1])</strong><br>带入求解：<br>&emsp;&emsp;&emsp;&emsp; F(2,1) = F(2-1,1) = F(1,1) = 0<br>&emsp;&emsp;&emsp;&emsp; F(2,2) = F(2-1,2) = F(1,2) = 0<br>&emsp;&emsp;&emsp;&emsp; F(2,3) = F(2-1,3) = F(1,3) = 0<br>&emsp;&emsp;&emsp;&emsp; F(2,4) = F(2-1,4) = F(1,4) = 0<br><img src="/blog/img/2020/03/04/金矿问题解法25.png"><br><br>第2行的后6个格子，和第1行同理，此时w&gt;=p[n-1]，对应的状态转移方程式如下：<br>&emsp;&emsp;&emsp;&emsp;<strong>F(n,w) = max(F(n-1,w),F(n-1,w-p[n-1])+g[n-1])(n&gt;1,w&gt;=p[n-1])；</strong><br>带入求解：<br>&emsp;&emsp;&emsp;&emsp; F(2,5) = max(F(2-1,5),F(2-1,5-5)+500) = max(F(1,5),F(1,0)+500) = max(400,400) = 500<br>&emsp;&emsp;&emsp;&emsp; F(2,6) = max(F(2-1,6),F(2-1,6-5)+500) = max(F(1,6),F(1,1)+500) = max(400,400) = 500<br>&emsp;&emsp;&emsp;&emsp; ······<br>&emsp;&emsp;&emsp;&emsp; F(2,10) = max(F(2-1,10),F(2-1,10-5)+500) = max(F(1,5),F(1,5)+500) = max(400,400+500) = 900<br><img src="/blog/img/2020/03/04/金矿问题解法26.png"><br><br>第3行的计算方法如出一辙。<br><img src="/blog/img/2020/03/04/金矿问题解法27.png"><br><br>再接再厉，计算出第4行的答案。<br><img src="/blog/img/2020/03/04/金矿问题解法28.png"><br><br>最后，计算出第5行的结果。<br><img src="/blog/img/2020/03/04/金矿问题解法29.png"><br><br>此时，最后1行最后1个格子所填的900就是最终要求的结果，即5个金矿、10个工人的最优收益是900kg黄金。  </p>
<p>那么如何实现，在程序中我们可以用二维数组来代表所填写的表格。<br><strong>改进版代码</strong>   </p>
<pre><code>/**
 * 获取金矿的最优收益  改进版
 * @param w 工人数量
 * @param p 金矿开采所需的工人数量
 * @param g 金矿储量
 */
public static int getBestGoldMining2(int w,int[] p,int[] g){
    //1.创建表格
    int[][] arr = new int[g.length+1][w+1];
    //2.填充表格
    for (int i = 1; i &lt;= g.length; i++) {
        for (int j = 1; j &lt;= w; j++) {
            if(j&lt;p[i-1]){
                arr[i][j] = arr[i-1][j];
            }else{
                arr[i][j] = Math.max(arr[i-1][j], arr[i-1][j-p[i-1]]+g[i-1]);
            }
        }
    }
    //返回最后1个格子的值
    return arr[g.length][w];
}</code></pre><p>上面的程序使用双循环来填充一个二维数组，所以时间和空间复杂度都是<strong>O(nw)</strong>，比递归的性能好多了！<br>虽然这段代码在时间上已经没有什么可优化的了，但是在空间上还可以做一些优化。<br>想一想，在表格中除第一行之外，每一行的结果都是由<strong>上一行数据</strong>推导出来的，我们以4个金矿9个工人为例。<br><img src="/blog/img/2020/03/04/金矿问题解法3.png"><br><br>4个金矿、9个工人的最优结果，是由它的两个最优子结构，也就是3个金矿、5个工人和3个金矿、9个工人的结果推导而来的，这两个最优子结构都位于它的上一行。<br>所以，在程序中并不需要保存整个表格，无论金矿有多少座，我们只保存一行的数据即可。在计算下一行时，要从右向左统计(为什么要从右向左统计？因为如果从左向右统计，左边的数字已经改变，后面的数组统计时加的前一个数据已经是修改过的数据了，所以当然不行了)，把旧的数据一个一个替换掉。  </p>
<p><strong>优化后的代码</strong>  </p>
<pre><code>/**
 * 获取金矿的最优收益  改进版后的优化版
 * @param w 工人数量
 * @param p 金矿开采所需的工人数量
 * @param g 金矿储量
 */
public static int getBestGoldMining(int w,int[] p,int[] g){
    //1.创建当前结果
    int[] arr = new int[w+1];
    //2.填充唯一数组
    for (int i = 1; i &lt;= g.length; i++) {
        for (int j = w; j &gt;=1; j--) {
            if(j&gt;=p[i-1]){
                arr[j] = Math.max(arr[j], arr[j-p[i-1]]+g[i-1]);
            }
        }
    }
    //返回最后1个格子的值
    return arr[w];
}</code></pre><p>优化版后的代码更简洁了，而且空间复杂度也降低到了<strong>O(n)</strong> 。  </p>
]]></content>
  </entry>
  <entry>
    <title>如何实现大整数相加</title>
    <url>/blog/2020/03/03/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给出两个很大的整数，要求实现程度求出两个整数之和。   </p>
<a id="more"></a>  

<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>首先我们回顾一下小学数学课。我们是如何计算两个较大数目的加、减、乘、除的？<br>通过列竖式进行计算，就像下面这样。<br><img src="/blog/img/2020/03/03/竖式运算.png"><br><br>那么，我们为什么要列出竖式来运算呢？<br>因为对于这么大的整数，我们无法一步到位直接算出结果，所以不得不把计算过程拆解成一个一个子步骤。这对于计算机来说也是一样的。<br>程序不可能通过一条指令计算出两个大整数之和，但我们却可以把大运算拆解成若干个小运算，像小学生列竖式一样进行按为计算。<br>如果大整数超出了long类型的范围，我们如何来存储这样的整数呢？<br>这个很好解决，用数组存储即可。数组的每一个元素，对应着大整数的每一个数位。  </p>
<p>在程序中列出的”竖式”究竟是什么样子呢？我们以426 709 752 318 + 95 481 253 129 为例，来看看大整数相加的详细步骤。<br><strong>第1步</strong>，创建两个整型数组，数组长度是较大整数的位数+1。把每一个整数倒序存储到数组中，整数的个位存于数组下标为0的位置，最高位存于数组的尾部。之所以倒序存储，是因为这样更符合从左到右访问数组的习惯。<br><img src="/blog/img/2020/03/03/大整数相加1.png"><br><br><strong>第2步</strong>，创建结果数组，结果数组的长度同样是较大整数的位数+1，+1的目的很明显，是给最高位进位预留的。<br><img src="/blog/img/2020/03/03/大整数相加2.png"><br><br><strong>第3步</strong>，遍历两个数组，从左到右按照对应下标把元素两两相加，就像小学生计算竖式一样。<br>在本例中，最先相加的是数组A的第1个元素8和数组B的第1个元素9，结果是7，进位1。把7填充到result数组的对应下标位置，进位的1填充到下一个位置。<br><img src="/blog/img/2020/03/03/大整数相加3.png"><br><br>第2组相加的是数组A的第2个元素1和数组B的第2个元素2，结果是3，再加上刚才的进位1。把4填充到result数组的对应下标位置。<br><img src="/blog/img/2020/03/03/大整数相加4.png"><br><br>第3组相加的是数组A的第3个元素3和数组B的第3个元素1，结果是4。把4填充到result数组的对应下标位置。<br><img src="/blog/img/2020/03/03/大整数相加5.png"><br><br>第4组相加的是数组A的第4个元素2和数组B的第4个元素3，结果是5。把5填充到result数组的对应下标位置。<br><img src="/blog/img/2020/03/03/大整数相加6.png"><br><br>以此类推······一直把数组的所有元素都相加完毕。<br><img src="/blog/img/2020/03/03/大整数相加7.png"><br><br><strong>第4步</strong>，把result数组的全部元素再次逆序，去掉首位的0，就是最终结果。<br><img src="/blog/img/2020/03/03/大整数相加8.png"><br> </p>
<p>需要说明的是，为两个大整数建立临时数组，是一种直观的解决方案。若想节省内存空间，也可以不创建这两个临时数组。  </p>
<p><strong>代码实现</strong>  </p>
<pre><code>public class Exercise {

    public static String bigNumberSum(String bigNumberA,String bigNumberB){
        //1.把两个大整数用数组逆序存储，数组长度等于较大整数位数+1
        int maxLength = bigNumberA.length()&gt;bigNumberB.length()?bigNumberA.length():bigNumberB.length();
        int[] arrayA = new int[maxLength+1];
        for (int i = 0; i &lt; bigNumberA.length(); i++) {
            arrayA[i] = bigNumberA.charAt(bigNumberA.length()-1-i)-&apos;0&apos;;
        }
        int[] arrayB = new int[maxLength+1];
        for (int i = 0; i &lt; bigNumberB.length(); i++) {
            arrayB[i] = bigNumberB.charAt(bigNumberB.length()-1-i)-&apos;0&apos;;
        }
        //2.构建result数组，数组长度等于较大整数位数+1
        int[] result = new int[maxLength+1];
        //3.遍历数组，按位相加
        for (int i = 0; i &lt; result.length; i++) {
            int tmp = arrayA[i]+arrayB[i]+result[i];
            //判断是否进位
            if(tmp&gt;=10){
                tmp = tmp-10;
                result[i+1] = 1;
            }
            result[i] = tmp;
        }
        //4.把result数组再次逆序并转成String
        StringBuilder sb = new StringBuilder();
        //是否找到大整数的最高有效位
        boolean findFirst = false;
        for (int i = result.length-1; i &gt;=0 ; i--) {
            if(!findFirst){
                if(result[i]==0){
                    continue;
                }
                findFirst = true;
            }
            sb.append(result[i]);
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        System.out.println(bigNumberSum(&quot;426709752318&quot;,&quot;95481253129&quot;));
    }
}</code></pre><p>如果给出的最大整数的最长位数时n，那么创建数组、按位计算、结果逆序的时间复杂度各自都是O(n)，整体的时间复杂度也是<strong>O(n)</strong> 。  </p>
<p>当前的思路其实还存在一个可优化的地方。<br>我们之前把大整数按照数位来拆分的，即如果较大整数有50位，那么我们就需要创建一个长度为51的数组，数组中的每个元素存储其中一位数字。<br><img src="/blog/img/2020/03/03/大整数相加9.png"><br><br>那么我们有必要把原整数拆分的这么细吗？显然不需要，只需要拆分到可以<strong>被直接计算</strong>的程度就够了。<br>int类型的取值范围是-2 147 483 648~2 147 483 647，最多可以有10位整数。为了防止溢出，我们可以把大整数的每<strong>9</strong>位作为数组的一个元素，进行加法运算。（这里也可以使用long类型来拆分，按照int类型拆分仅仅是提供一个思路。）<br><img src="/blog/img/2020/03/03/大整数相加10.png"><br><br>如此一来，内存占用空间和运算次数，都压缩到了原来的1/9。  </p>
<p>就拿刚刚那个例子来说，如果我们拆分成3位数一组。如果第0位两个数相加的结果tmp=1001超过1000，那么结果数组第0位就存1(001)，第1位存放进位1，以此类推，等等。当把result数组逆序的时候要注意一下，第0位的数字是1，不足三位数，需要补两个0。  </p>
<p><strong>在java中，工具类BigInteger和BigDecimal的底层实现同样是把大整数拆分成数组进行运算的，和这个思路大体类似。</strong>  </p>
]]></content>
  </entry>
  <entry>
    <title>删除K个数字后的最小值</title>
    <url>/blog/2020/03/03/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E5%88%A0%E9%99%A4K%E4%B8%AA%E6%95%B0%E5%AD%97%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给出一个正数，从该整数中去掉k个数字，要求剩下的数字形成的新整数尽可能小。应该如何选取被去掉的数字？<br>其中整数的长度大于或等于k，给出的整数的大小可以超过long类型的数字范围。<br>什么意思呢？让我们举几个例子。  </p>
<a id="more"></a>  
<p>假设给出一个整数<strong>1 593 212</strong>，删去 <strong>3</strong> 个数字，新整数最小的情况是<strong>1212</strong> 。<br><img src="/blog/img/2020/03/03/删除k个数字1.png"><br><br>假设给出一个整数<strong>30 200</strong>，删去 <strong>1</strong> 个数字，新整数最小的情况是<strong>200</strong> 。<br><img src="/blog/img/2020/03/03/删除k个数字2.png"><br><br>假设给出一个整数<strong>10</strong>，删去 <strong>2</strong> 个数字（注意，这里要求删去的不是1个数字，而是2个），新整数最小的情况是<strong>0</strong> 。<br><img src="/blog/img/2020/03/03/删除k个数字3.png"><br></p>
<p>为了让新整数最小，如果你说要优先删除最大的数字，那就错了，比如下面这个例子。<br><img src="/blog/img/2020/03/03/删除k个数字4.png"><br></p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>题目要求我们删除k个数字，首先我们不妨先把问题简化一下：如果只删除一个数字，如何让新整数的值最小？<br>数字的大小固然重要，数字的位置则更加重要。<br>你想想，一个整数的最高位哪怕是只减少1，对数值的影响也是非常大的。  </p>
<p>我们来举个例子：<br>给出一个整数<strong>541 270 936</strong>，要求删去1个数字，让剩下的整数尽可能的小。<br>此时无论删除哪一个数字，最后的结果都是从9位整数变成8位整数。既然同样是8位整数，显然是应该优先把高位的数字降低，这样对新整数的值影响最大。<br><img src="/blog/img/2020/03/03/解题思路1.png"><br><br>如何把高位的数字降低呢？很简单，把<strong>原整数的所有数字从左向右进行比较，如果发现某一位数字大于它右面的数字，那么在删除该数字后，必然会使该数位的值降低</strong>，因为右面比它小的数字顶替了它的位置。<br>在上面这个例子中，数字5右侧的数字4小于5，所以删除数字5，最高位数字降低成了4。<br>第2步，重复上述操作，因为4&gt;1，所以删除数字4。<br><img src="/blog/img/2020/03/03/解题思路2.png"><br><br>第3步，重复上述操作，因为1&lt;2、2&lt;7、7&gt;0，所以被删除的数字应该是7！<br><img src="/blog/img/2020/03/03/解题思路3.png"><br></p>
<p>这里每一步都要求得到删除一个数字后的最小值，经历3次，相当于求出了删除k(k=3)个数字后的最小值。<br>像这样依次求得 <strong>局部最优解</strong> ，最终得到 <strong>全局最优解</strong> 的思想，叫做<strong>贪心算法</strong> 。  </p>
<p><strong>代码实现</strong>  </p>
<pre><code>public class Exercise {

    /**
     * 删除整数的k个数字，获得删除后的最小值
     * @param num 原数字
     * @param k 删除位数
     * @return
     */
    public static String removeKDigits(String num,int k){
        //如果删除数量等于原数字长度，直接返回0
        if(num.length() == k){
            return &quot;0&quot;;
        }
        for (int i = 0; i &lt; k; i++) {
            boolean hasCut = false;
            //从左向右遍历，找到右侧比自己数字大的数字并删除
            for (int j = 0; j &lt; num.length()-1; j++) {
                int leftNum = num.charAt(j);
                int rightNum = num.charAt(j+1);
                if(leftNum&gt;rightNum){//如果左边的数字大于右边的数字，则删除右边的数字
                    num = num.substring(0,j)+num.substring(j+1,num.length());
                    hasCut=true;
                    break;
                }
            }
            //如果没有找到想要删除的数字，则删除最后一个数字
            if(!hasCut){
                num = num.substring(0,num.length()-1);
            }
        }
        //清除左边的0
        num = removeZero(num);
        //如果num全是0被清除了，则直接返回0
        if(num.length() == 0){
            return &quot;0&quot;;
        }
        return num;
    }

    private static String removeZero(String num) {
        while(num.length()&gt;0 &amp;&amp; (num.charAt(0)-&apos;0&apos;)==0){
            num = num.substring(1);
        }
        return num;
    }

    public static void main(String[] args) {
        System.out.println(removeKDigits(&quot;1593212&quot;,3));
        System.out.println(removeKDigits(&quot;30200&quot;,1));
        System.out.println(removeKDigits(&quot;10&quot;,2));
        System.out.println(removeKDigits(&quot;541270936&quot;,3));
        System.out.println(removeKDigits(&quot;123456&quot;,3));
    }
}</code></pre><p>上面的代码使用了两层循环，外循环次数就是要删除的数字个数k，内层循环从左到右遍历所有数字。当遍历到需要删除的数字时，利用字符串的自身的方法subString()把对应的数字删除，并重新拼接字符串。<br>显然这段代码的时间复杂度是O(kn)。  </p>
<p>这段代码在功能是没有问题的，但是性能却不怎么好，主要问题在于以下两个方面。<br><strong>1.每一次内层循环都要重头开始遍历所有数字。</strong><br><strong>2.subString()方法本身性能不高。</strong>  </p>
<p>怎么优化呢？<br>我们换一个思路，以遍历数字作为外循环，以k作为内循环。<br><strong>优化版代码实现</strong>  </p>
<pre><code>public static String removeKDigits(String num,int k){
    //新整数的长度=原整数的长度-k
    int newLength = num.length()-k;
    //新整数的长度为0，直接返回0
    if(newLength == 0){
        return &quot;0&quot;;
    }
    //创建一个栈用于接收所有的数字
    char[] stack = new char[num.length()];
    int top = 0;
    for (int i = 0; i &lt; num.length(); ++i) {
        //遍历当前数字
        char c = num.charAt(i);
        //当栈顶数字大于遍历到的当前数字时，栈顶数字出栈(相当于删除数字)
        while(top&gt;0 &amp;&amp; stack[top-1]&gt;c &amp;&amp; k&gt;0){
            top -=1;
            k -=1;
        }
        //把遍历到的当前数字入栈
        stack[top++] = c;
    }
    //找到栈中第1个非零数字的位置，以此构建新的整数字符串
    int offset = 0;
    while(offset&lt;newLength &amp;&amp; stack[offset]==&apos;0&apos;){
        offset++;
    }
    return new String(stack,offset,newLength-offset);
}</code></pre><p>上面的方法只对所有数字遍历了一次，遍历的时间复杂度是O(n)，把栈转化为字符串的时间复杂度也是O(n)，所以最终的时间复杂度是<strong>O(n)。</strong><br>同时，程序中利用栈来回溯遍历过的数字及删除数字，所以程序的空间复杂度是<strong>O(n)。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>寻找全排列的下一个数</title>
    <url>/blog/2020/03/03/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AF%BB%E6%89%BE%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给出一个正整数，找出这个正整数所有数字全排列的下一个数。<br>说通俗一点就是在一个整数所包含数字的全部组合中，找到一个大于且仅大于原数的新整数。然我们来举几个例子。<br>如果输入12345，则返回12354。<br>如果输入12354，则返回12435。<br>如果输入12435，则返回12534。  </p>
<a id="more"></a>  

<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>首先我们可以知道的一点就是，如果是固定的几个数字，应该是在<strong>逆序排列</strong>的情况下最大，在<strong>顺序排列</strong>的情况下最小。<br>举一个例子。<br>给出1、2、3、4、5这几个数字。<br>最大的组合：<strong>54321</strong> 。<br>最小的组合：<strong>12345</strong> 。<br>没错，数字的顺序和逆序，是全排列中的两种极端情况。<br>那么普遍情况下，一个数和它最接近的全排列数存在什么关联呢？  </p>
<p>例如给出整数12354，它包含的数字的1、2、3、4、5，如何找到这些数字全排列之后仅大于原数的新整数呢？<br>为了和原数接近，我们需要<strong>尽量保持高位不变，低位在最小的范围内变换顺序</strong> 。<br>至于变换顺序的范围大小，取决于当前整数的<strong>逆序区域</strong> 。<br><img src="/blog/img/2020/03/03/全排列1.png"><br><br>如图所示，12354的逆序区域是最后两位，仅看这两位已经是当前的最大组合。如想最接近原数，又比原数大，必须从<strong>倒数第3位</strong>开始改变。<br>怎样改变呢？12354的倒数第3位是3，我们需要从后面的逆序区域找到大于3的最小数字，让其和3的位置进行互换。<br><img src="/blog/img/2020/03/03/全排列2.png"><br><br>互换后的临时结果是12453，倒数第3位已经确定，这个时候最后两位仍然是逆序状态。我们要把最后两位<strong>转变为顺序状态</strong>，以此保证在倒数第3位数值为4的情况下，后两位尽可能的小。<br><img src="/blog/img/2020/03/03/全排列3.png"><br><br>这样一来就得到了想要的结果<strong>12435</strong> 。  </p>
<p><strong>获得全排列下一个数的3个步骤</strong><br>1.从后向前查看逆序区域，找到逆序区域的前一位，也就是数字置换的边界。<br>2.让逆序区域的前一位和逆序区域中大于它的最小值的数字交换位置。<br>3.把原来的逆序区域转换为顺序状态。  </p>
<p><strong>代码实现</strong>  </p>
<pre><code>public class Exercise {

    public static Integer findNearestNumber(int num){
        //1.将整数按位数拆分
        int[] numbers = splitNum(num);
        //2.从后向前找查看逆序区域，找到逆序区域的前一位，也就是数字置换的边界
        int index = findTansferPoint(numbers);
        //如果数字置换边界是0，说明整个数组已经逆序，无法得到更大的相同数字组成的整数，返回null
        if(index == 0){
            return null;
        }
        //3.把逆序区域的前一位和逆序区域中刚刚大于它的数字交换位置  
        exchangeHead(numbers,index);
        //4.把原来的逆序区域转为顺序
        reverse(numbers,index);
        //5.输出数字
        return outputNum(numbers);
    }

    private static Integer outputNum(int[] numbers){
        String numStr = &quot;&quot;;
        for (int i = 0; i &lt; numbers.length; i++) {
            numStr +=numbers[i];
        }
        return Integer.valueOf(numStr);
    }

    private static void reverse(int[] numbers, int index) {
        for (int i = index,j=numbers.length-1; i&lt;j; i++,j--) {
            int temp = numbers[i];
            numbers[i] = numbers[j];
            numbers[j] = temp;
        }
    }

    private static void exchangeHead(int[] numbers, int index) {
        int head = numbers[index-1];
        for (int i = numbers.length-1; i &gt; 0 ; i--) {
            if(head &lt; numbers[i]){
                numbers[index-1] = numbers[i];
                numbers[i] = head;
                break;
            }
        }
    }

    private static int findTansferPoint(int[] numbers) {
        for (int i = numbers.length-1; i&gt;0; i--) {
            if(numbers[i]&gt;numbers[i-1]){
                return i;
            }
        }
        return 0;
    }

    private static int[] splitNum(int num){
        String numStr = String.valueOf(num);
        int[] numbers = new int[numStr.length()];
        for (int i = 0; i &lt; numStr.length(); i++) {
            numbers[i] = numStr.charAt(i)-&apos;0&apos;;
        }
        return numbers;
    }

    public static void main(String[] args) {
        Integer num = 12345;
        //打印12345之后的10个全排列整数
        for (int i = 0; i &lt; 10; i++) {
            num = findNearestNumber(num);
            System.out.println(num);
        }
    }
}</code></pre><p>这种解法拥有一个“高大上”的名字：<strong>字典序算法</strong> 。<br>该算法每个个步骤的每一步的时间复杂度都是O(n)，所以整体时间复杂度也是O(n)。  </p>
]]></content>
  </entry>
  <entry>
    <title>如何用栈实现队列</title>
    <url>/blog/2020/03/02/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A6%82%E4%BD%95%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>用栈来模拟一个队列，要求实现队列的两个基本操作：入队、出队。（提示：使用双栈）   </p>
<a id="more"></a>  

<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>队列的主要操作无非有两个：入队、出队。<br>首先假设有两个栈：栈A和栈B。在模拟入队操作时，让每一个新元素都被压入栈A当中。<br>让元素1入队。<br><img src="/blog/img/2020/03/02/栈实现队列1.png"><br><br>让元素2入队。<br><img src="/blog/img/2020/03/02/栈实现队列2.png"><br><br>让元素3入队。<br><img src="/blog/img/2020/03/02/栈实现队列3.png"><br><br>这时我们希望最先入队的元素1出队，需要怎么做呢？<br>让栈A中的所有的元素按顺序出栈，再按照出栈顺序压入栈B。这样一来，元素从栈A弹出并压入栈B的顺序是3、2、1，和当初进入栈A的顺序1、2、3是相反的。<br><img src="/blog/img/2020/03/02/栈实现队列4.png"><br><br>此时让元素1出队，也就是让元素1从栈B中弹出。<br><img src="/blog/img/2020/03/02/栈实现队列5.png"><br><br>让元素2出队。<br><img src="/blog/img/2020/03/02/栈实现队列6.png"><br></p>
<p><strong>如果这个时候又想做入栈操作了呢？</strong><br>很简单，当有新元素入队的时候，重新把元素压入栈A。<br>让元素4入队。<br><img src="/blog/img/2020/03/02/栈实现队列7.png"><br><br>此时出队操作仍然从栈B中弹出元素。<br>让元素3出队。<br><img src="/blog/img/2020/03/02/栈实现队列8.png"><br><br><strong>此时栈B已经空了，如果再想出队怎么办？</strong><br>也不难，只要A中还有元素，就像刚才一样，把栈A中的元素弹出并压入栈B即可。<br><img src="/blog/img/2020/03/02/栈实现队列9.png"><br><br>让元素4出队。<br><img src="/blog/img/2020/03/02/栈实现队列10.png"><br></p>
<p><strong>代码实现</strong>  </p>
<pre><code>public class StackQueue {

    private Stack&lt;Integer&gt; stackA = new Stack&lt;&gt;();
    private Stack&lt;Integer&gt; stackB = new Stack&lt;&gt;();

    /**
     * 入队操作
     * @param element 入队元素
     */
    public void enQueue(int element){
        stackA.push(element);
    }

    /**
     * 出队操作
     * @return 出队元素
     */
    public Integer deQueue() throws Exception{
        if(stackB.isEmpty()){
            if(stackA.isEmpty()){
                return null;
            }
            transfer();
        }
        return stackB.pop();
    }

    /**
     * 栈A元素转移到栈B
     */
    public void transfer(){
        while(!stackA.isEmpty()){
            stackB.push(stackA.pop());
        }
    }

    public static void main(String[] args) throws Exception {
        StackQueue stackQueue = new StackQueue();
        stackQueue.enQueue(1);
        stackQueue.enQueue(2);
        stackQueue.enQueue(3);
        System.out.println(stackQueue.deQueue());
        System.out.println(stackQueue.deQueue());
        stackQueue.enQueue(4);
        System.out.println(stackQueue.deQueue());
        System.out.println(stackQueue.deQueue());
    }
}</code></pre>]]></content>
  </entry>
  <entry>
    <title>无序数组排序后的最大相邻差</title>
    <url>/blog/2020/03/02/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%B8%E9%82%BB%E5%B7%AE/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>有一个无序数整型组，如何求出该数组排序后的任意两个相邻元素的最大差值？要求时间和空间复杂度尽可能低。<br>让我们来看一个例子。<br><img src="/blog/img/2020/03/02/相邻差例子.png"><br></p>
<a id="more"></a>  

<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><p>使用任意一种时间复杂度为O(nlogn)的排序算法(如快速排序)给原数组排序，然后遍历排好序的数组，并对两个相邻元素求差，最终得到最大相邻差。<br>该解法的时间复杂度是O(nlogn)，在不改变原数组的情况下，空间复杂度是O(n)。<br><strong>虽然能解决问题，但本问题的本意不是让我们来排序的。所以此方法不推荐。而且此方法还有更快的解法。</strong>  </p>
<h3 id="2-2-解法二"><a href="#2-2-解法二" class="headerlink" title="2.2 解法二"></a>2.2 解法二</h3><p>1.利用计数排序的思想，先求出原数组的最大值max与最小值min的区间长度k=(max-min+1)，以及偏移量d=min。<br>2.创建一个长度为k的新数组Array。<br>3.遍历数组，没遍历一个元素，就把新元素的数组Array对应下标的值+1。例如原数组的值为n，则将Array[n-min]的值加1.遍历结束后，Array的一部分元素值变成了1或更高的数值，一部分元素值仍然是0。<br>4.遍历新数组Array，统计出Array中最大连续出现0值的次数+1，即为相邻元素最大的差值。<br>例如给定一个无序数组{2,6,3,4,5,10,9}，处理过程如下图。<br>第1步，确定k(数组长度)和d(偏移量)。<br><img src="/blog/img/2020/03/02/解法21.png"><br><br>第2步，创建数组。<br><img src="/blog/img/2020/03/02/解法22.png"><br><br>第3步，遍历数组，对号入座。<br><img src="/blog/img/2020/03/02/解法23.png"><br><br>第4步，判断0值最多连续出现的次数，计算出最大的相邻差。<br><img src="/blog/img/2020/03/02/解法24.png"><br></p>
<p>虽然这个方法已经进步了许多，这个思路在数组元素差值不是很悬殊的时候，确实效率很高。<br>但是设想一下，如果元素组只有3个元素：1、2、1000000，那就要创建长度是1000000的数组！  </p>
<h3 id="2-3-解法三-推荐"><a href="#2-3-解法三-推荐" class="headerlink" title="2.3 解法三(推荐)"></a>2.3 解法三(推荐)</h3><p>1.利用桶排序的思想，根据原数组的长度n，创建出n个桶，每一个桶代表一个区间范围。其中第1个桶从原数组的最小值min开始，区间跨度是(max-min)/(n-1)。<br>2.遍历原数组，把原数组每一个元素插入到对应的桶中，记录每一个桶的最大和最小值。<br>3.遍历所有的桶，统计出每一个桶的最大值，和这个桶右侧非空桶的最小值的差，数值最大的差即为原数组排序后的相邻最大差值。  </p>
<p>例如给定一个无序数组{2,6,3,4,5,10,9}，处理过程如下图。<br>第1步，根据原数组，创建桶，确定每个桶的区间范围。<br><img src="/blog/img/2020/03/02/解法31.png"><br><br>第2步，遍历原数组，确定每个桶的最大值和最小值。<br><img src="/blog/img/2020/03/02/解法32.png"><br><br>第3步，遍历所有的桶，找出最大相邻差。<br><img src="/blog/img/2020/03/02/解法33.png"><br></p>
<p>这个方法不需要像标准桶排序那样给每一个桶内进行排序，只需要记录桶的最大值和最小值即可，所以时间复杂度稳定在O(n)。  </p>
<p><strong>代码示例</strong>  </p>
<pre><code>public class Test {

    public static int getSortedDistance(int[] arr){
        //1.得到无序数组的最大值和最小值
        int max = arr[0];
        int min = arr[0];
        for (int i = 1; i &lt; arr.length; i++) {
            max = Math.max(max, arr[i]);
            min = Math.min(min, arr[i]);
        }
        int d = max-min;
        //如果最大值和最小值相等，说明数组所有元素都相等，返回0
        if(d==0){
            return 0;
        }
        //2.初始化桶
        int bucketNum = arr.length;
        Bucket[] buckets = new Bucket[bucketNum];
        for (int i = 0; i &lt; buckets.length; i++) {
            buckets[i] = new Bucket();
        }
        //3.遍历原始数组，确定每个桶最大值和最小值
        for (int i = 0; i &lt; arr.length; i++) {
            //确定数组元素所归属的桶的下标
            int index = (int)((arr[i]-min)*(bucketNum-1)/d);
            if(buckets[index].max == null || (buckets[index].max&lt;arr[i])){
                buckets[index].max = arr[i];
            }
            if(buckets[index].min == null || (buckets[index].min&gt;arr[i])){
                buckets[index].min = arr[i];
            }
        }
        //4.遍历桶找到最大差值
        int leftMax = buckets[0].max;
        int maxDistance = 0;
        for (int i = 1; i &lt; buckets.length; i++) {
            //第一个桶永远不会为空，里面一定放了原数组的最小值，所以只需判断第二个桶是否为空
            if(buckets[i].min==null){
                continue;
            }
            int distance = buckets[i].min-leftMax;
            if(distance&gt;maxDistance){
                maxDistance = distance;
            }
            leftMax = buckets[i].max;
        }
        return maxDistance;
    }

    /**
     *桶
     */
    private static class Bucket{
        Integer max;
        Integer min;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{2,6,3,4,5,10,9};
        System.out.println(getSortedDistance(arr));
    }
}</code></pre><p>这里需要注意的是代码第4步：借助了临时变量leftMax，这个临时变量是用来存放上一个非空桶的最大值。如果不借助这个临时变量，把代码第4步中的int distance = buckets[i].min-leftMax;这一段代码写成int distance = buckets[i].min-buckets[i-1].max;可能会踩坑。因为你需要判断buckets[i-1]这个桶是否为空，如果为空的话还要判断buckets[i-1-1]这个桶是否为空等等，这样代码就变的复杂化了。  </p>
]]></content>
  </entry>
  <entry>
    <title>判断一个数是否为2的整数次幂</title>
    <url>/blog/2020/03/02/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA2%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E5%B9%82/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>实现一个方法，来判断一个正整数是否为2的整数次幂(如16是2的4次方，返回true；18不是2的整数次幂，则返回false)。要求性能尽可能高。 </p>
<a id="more"></a>  

<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>1.方法一：利用一个整形变量，让它从1开始不断乘以2，将每一次乘2的结果和目标整数进行比较。（不推荐，此方法的时间复杂度是O(logn)）。<br>2.方法二：将上面的乘以2改成向左位移1位。（也不推荐，虽然位移的性能比乘法高得多，但此方法的时间复杂度仍然是O(logn)）。<br>3.<strong>方法三：位运算(推荐，时间复杂度为O(1))</strong> 。<br>我们把2的整数次幂转换成二进制数，你会发现一个共同点。<br><img src="/blog/img/2020/03/02/2的整数次幂1.png"><br><br>如果一个整数是2的整数次幂，那么当它转化成二进制时，只有最高位是1，其他位都是0！<br>接下来再让这些2的整数次幂各自减1，再转化成二进制，又会是怎样的特点呢？<br><img src="/blog/img/2020/03/02/2的整数次幂2.png"><br><br>你会发现，一旦2的整数次幂一旦减1，它的二进制数字就全都变成了1！<br>我们在看看用原数值和它减1的结果进行按位与运算，也就是n&amp;(n-1)，会是什么结果呢？<br><img src="/blog/img/2020/03/02/2的整数次幂3.png"><br><br>答案很明显了，凡是2的整数次幂和它本身减1的结果进行按位与运算，结果都必然是0。反之，如果一个正数不是2的整数次幂，结果一定不是0！  </p>
<p><strong>代码示例</strong>  </p>
<pre><code>public class Test {

    public static boolean isPowerOf2(int num){
        return (num&amp;num-1)==0;
    }

    public static void main(String[] args) {
        System.out.println(isPowerOf2(8));
        System.out.println(isPowerOf2(10));
        System.out.println(isPowerOf2(16));
        System.out.println(isPowerOf2(32));
        System.out.println(isPowerOf2(64));
        System.out.println(isPowerOf2(100));
    }
}</code></pre>]]></content>
  </entry>
  <entry>
    <title>如何求出最大公约数</title>
    <url>/blog/2020/03/01/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A6%82%E4%BD%95%E6%B1%82%E5%87%BA%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>写一段代码。求出两个整数的最大公约数，要尽量优化算法的性能。  </p>
<a id="more"></a>  
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><h3 id="2-1-方法一：暴力枚举法"><a href="#2-1-方法一：暴力枚举法" class="headerlink" title="2.1 方法一：暴力枚举法"></a>2.1 方法一：暴力枚举法</h3><pre><code>public static int getCreatestCommonDivisor(int a,int b){
    int small = a&lt;b?a:b;
    int big = a&gt;b?a:b;
    if(big%small == 0){
        return small;
    }
    for (int i = small/2; i&gt;1; i--) {
        if(small%i==0 &amp;&amp; big%i==0){
            return i;
        }
    }
    return 1;
}

public static void main(String[] args) {
    System.out.println(getCreatestCommonDivisor(25, 5));
    System.out.println(getCreatestCommonDivisor(100, 80));
    System.out.println(getCreatestCommonDivisor(27, 14));
}</code></pre><p>这个解题思路十分简单，使用暴力枚举的方法，从较小的整数的一半开始，试图找到一个合适的整数i，看看这个整数能否被a和b同时整除。<br>这个方法虽然实现了所要求的的功能，但是效率不行。如果传入的整数是10 000和10 001，用这个方法就要循环10 000/2-1=4999次！  </p>
<h3 id="2-2-方法二：辗转相除法"><a href="#2-2-方法二：辗转相除法" class="headerlink" title="2.2 方法二：辗转相除法"></a>2.2 方法二：辗转相除法</h3><p>辗转相除法，又称欧几里得算法（Euclidean algorithm），该算法的目的是求出两个正整数的最大公约数。这个算法基于一个定理：<strong>两个正整数a和b(a&gt;b)，他们的最大公约数等于a除以b的余数c和b之间的最大公约数</strong> 。<br>例如10和25，25除以10商2余5，那么10和25的最大公约数，等同于10和5的最大公约数。<br>有了这条定理，求最大公约数就变的简单了。我们可以使用递归的方法把问题逐步简化。<br>首先，计算出a除以b的余数c，把问题转化成求b和c的最大公约数；然后计算出b除以c的余数d，把问题转化成求c和d的最大公约数；在计算出c除以d的余数e，把问题转化成求d和e的最大公约数······<br>以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以整除，或者其中一个数减小到1为止。  </p>
<pre><code>public static int getCreatestCommonDivisor(int a,int b){
    int small = a&lt;b?a:b;
    int big = a&gt;b?a:b;
    if(big%small == 0){
        return small;
    }
    return getCreatestCommonDivisor(big%small,small);
}</code></pre><p>这确实是辗转相除法的思路。不过有一个问题就是，当两个整数较大时，做a%b取模运算的性能会比较差。  </p>
<h3 id="2-3-方法三：更相减损术"><a href="#2-3-方法三：更相减损术" class="headerlink" title="2.3 方法三：更相减损术"></a>2.3 方法三：更相减损术</h3><p>更相减损术，出自中国古代的《九章算术》，也是一种求最大公约数的算法。古希腊人很聪明，我们炎黄子孙也不差！<br>它的原理更加简单：<strong>两个正整数a和b(a&gt;b)，它们的最大公约数等于a-b的差值c和较小数b的最大公约数</strong>。例如10和25,25减10的差是15，那么10和25的最大公约数，等同于10和15的最大公约数。<br>由此，我们同样可以通过递归来简化问题。首先计算出a和b的差值c（假设a&gt;b）,把问题转化成求b和c的最大公约数；然后计算出c和b的差值d(假设c&gt;d)，把问题转化成求b和d的最大公约数；在计算出b和d的差值e(假设b&gt;d)，把问题转化成求d和e的最大公约数······<br>以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以相等为止，最大公约数就是最终相等的这两个数的值。  </p>
<pre><code>public static int getCreatestCommonDivisor(int a,int b){
    if(a == b){
        return a;
    }
    int small = a&lt;b?a:b;
    int big = a&gt;b?a:b;
    return getCreatestCommonDivisor(big-small,small);
}  </code></pre><p>虽然更相减损术避免了大整数取模可能出现的性能问题，已经越来越接近最优解决方案了。<br>更相减损术依靠两数求差的方式来递归，运算次数肯定要远大于辗转相除法的取模方式。比如，当两数相差悬殊时，如计算10000和1的最大公约数，就要递归9999次！<br>有什么办法可以既避免大整数取模，又尽可能地减少运算次数呢？<br><strong>把辗转相除法和更相减损术的优势结合起来，在更相减损术的基础上使用位移运算</strong> 。  </p>
<h3 id="2-4-方法四：更相减损术与位移相结合"><a href="#2-4-方法四：更相减损术与位移相结合" class="headerlink" title="2.4 方法四：更相减损术与位移相结合"></a>2.4 方法四：更相减损术与位移相结合</h3><p>众所周知，位移运算的性能非常好。对于给出的正整数a和b，不难得到如下的结论。<br>(从下文开始，获取最大公约数的方法getCreatestCommonDivisor被简写成gcd。)<br><strong>当a和b均为偶数时，gcd(a,b) = 2 x gcd(a/2,b/2) = 2 x gcd(a&gt;&gt;1,b&gt;&gt;1)。</strong><br><strong>当a为偶数，b为奇数时，gcd(a,b) = gcd(a/2,b) = gcd(a&gt;&gt;1,b)。</strong><br><strong>当a为奇数，b为偶数时，gcd(a,b) = gcd(a,b/2) = gcd(a,b&gt;&gt;1)。。</strong><br><strong>当a和b均为奇数时，先利用更相减损术运算一次，gcd(a,b) = 2 x gcd(b,a-b)，此时a-b必然是偶数，然后又可以进行位移运算。</strong><br>例如计算10和25的最大公约数的步骤如下：<br>1.整数10通过位移，可以转换成求5和25的最大公约数。<br>2.利用更相减损术，计算出25-5=20，转换成求5和20的最大公约数。<br>3.整数20通过位移，可以转换成求5和10的最大公约数。<br>4.整数10通过位移，可以转换成求5和5的最大公约数。<br>5.利用更相减损术，因为两数相等，所以最大公约数是5。<br>这种方式在两数都比较小时，可能看不出计算次数的优势；当两数越大时，计算次数的减少就会越明显。<br><strong>PS:为什么当a为偶数，b为奇数时，gcd(a,b) 可以转化成求 gcd(a/2,b)的最大公约数？因为偶数和奇数的最大公约不可能是偶数，所以让a一直除以2直到它的商为奇数为止。</strong>  </p>
<pre><code>public static int getCreatestCommonDivisor(int a,int b){
    if(a == b){
        return a;
    }
    if((a&amp;1)==0 &amp;&amp; (b&amp;1)==0){
        return getCreatestCommonDivisor(a&gt;&gt;1,b&gt;&gt;1)&lt;&lt;1;
    }else if((a&amp;1)==0 &amp;&amp; (b&amp;1)==1){
        return getCreatestCommonDivisor(a&gt;&gt;1,b);
    }else if((a&amp;1)==1 &amp;&amp; (b&amp;1)==0){
        return getCreatestCommonDivisor(a,b&gt;&gt;1);
    }else{
        int small = a&lt;b?a:b;
        int big = a&gt;b?a:b;
        return getCreatestCommonDivisor(big-small,small);
    }
}</code></pre><h2 id="3-四种方法之间的时间复杂度对比"><a href="#3-四种方法之间的时间复杂度对比" class="headerlink" title="3.四种方法之间的时间复杂度对比"></a>3.四种方法之间的时间复杂度对比</h2><p>1.<strong>暴力枚举法：</strong>时间复杂度是O(min(a,b))。<br>2.<strong>辗转相除法：</strong>时间不太好计算，可以近似为O(log(max(a,b)))，但取模运算性能较差。<br>3.<strong>更相减损法：</strong>避免了取模运算，但是算法的性能不稳定，最坏的时间复杂度为O(max(a,b))。<br>4.<strong>更相减损术与位移相结合：</strong>不但避免了取模运算，而且算法性能稳定，时间复杂度为O(log(max(a,b)))。    </p>
]]></content>
  </entry>
  <entry>
    <title>最小栈的实现</title>
    <url>/blog/2020/03/01/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>实现一个栈，该栈带有出栈(pop)、入栈(push)、取最小元素(getMin)3个方法。要保证这3个方法的时间复杂度都是O(1)。<br><img src="/blog/img/2020/03/01/最小栈题目示例.png"><br></p>
<a id="more"></a>  

<h2 id="2-解题思路-采用双栈"><a href="#2-解题思路-采用双栈" class="headerlink" title="2.解题思路(采用双栈)"></a>2.解题思路(采用双栈)</h2><p>1.设原有的栈叫做栈A，此时创建一个额外的”备胎”栈B(这个栈用来存储历史最小值)，用于辅助栈A。<br><img src="/blog/img/2020/03/01/最小栈解题思路1.png"><br><br>2.当第1个元素入栈A时，让新元素也进入栈B(第1个元素入栈时，可以把它当做是一个最小值)。这个唯一的元素是栈A的当前最小值。<br><img src="/blog/img/2020/03/01/最小栈解题思路2.png"><br><br>3.之后，每当新元素进入栈A时，比较新元素和栈A当前最小值的大小，如果小于栈A当前的最小值，则让新元素进入栈B，此时栈B的栈顶元素就是栈A当前的最小值。<br><img src="/blog/img/2020/03/01/最小栈解题思路3.png"><br><br>4.每当栈A有元素出栈时，如果出栈元素是栈A当前的最小值，则让栈B的栈顶元素也出栈。此时栈B余下的栈顶元素所指向的，是栈A中第2小的元素，代替刚才的出栈元素成为栈A的当前最小值。（备胎转正）。<br><img src="/blog/img/2020/03/01/最小栈解题思路4.png"><br><br>5.当调用getMin方法时，返回栈B的栈顶所存储的值，这也是栈A的最小值。<br>显然，这个解法中进栈、出栈、取最小值的时间复杂度都是O(1)，最坏的空间复杂度是O(n)。  </p>
<p><strong>代码实现</strong>  </p>
<pre><code>public class MinStack {
    //原始栈
    Stack&lt;Integer&gt; stackA = new Stack&lt;&gt;();
    //备胎栈
    Stack&lt;Integer&gt; stackB = new Stack&lt;&gt;();

    /**
     * 入栈
     * @param element 入栈元素
     */
    public void push(int element){
        stackA.push(element);
        //如果辅助栈为空，或者新元素小于或等于辅助栈栈顶，则将新元素压入辅助栈顶
        if(stackB.isEmpty() || element&lt;=stackB.peek()){
            stackB.push(element);
        }
    }

    /**
     * 出栈
     * @throws Exception 
     */
    public int pop() throws Exception{
        if(stackA.isEmpty()){
            throw new Exception(&quot;栈为空&quot;);
        }
        Integer element = stackA.pop();
        //如果栈A的出栈元素等于栈B的栈顶元素，那么也栈B出栈
        if(element.equals(stackB.peek())){
            stackB.pop();
        }
        return element;
    }

    /**
     * 获取栈的最小元素
     * @return
     * @throws Exception
     */
    public int getMin() throws Exception{
        if(stackA.isEmpty()){
            throw new Exception(&quot;栈为空&quot;);
        }
        return stackB.peek();
    }

    public static void main(String[] args) throws Exception{
        MinStack stack = new MinStack();
        stack.push(4);
        stack.push(9);
        stack.push(7);
        stack.push(3);
        stack.push(8);
        stack.push(5);
        System.out.println(stack.getMin());
        stack.pop();
        stack.pop();
        stack.pop();
        System.out.println(stack.getMin());
    }
}</code></pre>]]></content>
  </entry>
  <entry>
    <title>如何判断链表有环</title>
    <url>/blog/2020/02/29/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>有一个单向链表，表中有可能出现”环”，就像下图这样。<br>那么，如何用程序判断该链表是否为有环链表呢？<br><img src="/blog/img/2020/02/29/如何判断链表有环.png"><br> </p>
<a id="more"></a>  

<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>首先创建两个指针p1和p2(在Java对象里就是两个对象引用)，让他们同时指向这个链表的头节点。然后开始一个大循环，再循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环。如果不同，则继续下一次循环。<br>第1步，p1和p2都指向节点5。<br><img src="/blog/img/2020/02/29/解题思路1.png"><br><br>第2步，p1指向节点3，p2指向节点7。<br><img src="/blog/img/2020/02/29/解题思路2.png"><br><br>第3步，p1指向节点7，p2指向节点6。<br><img src="/blog/img/2020/02/29/解题思路3.png"><br><br>第4步，p1指向节点2，p2指向节点1。<br><img src="/blog/img/2020/02/29/解题思路4.png"><br><br>第5步，p1指向节点6，p2也指向节点6，p1和p2所指向的节点相同，说明链表有环。<br><img src="/blog/img/2020/02/29/解题思路5.png"><br><br>这是什么原理呢？学过小学奥数的读者，可能听说过数学上的追及问题。此方法就类似于一个追及问题。<br>在一个环形跑道上。两个运动员从同一地点起跑，一个运动员速度快，另一个运动员速度慢。当两人跑了一段时间后，速度快的运动员必然会再次追上并超过速度慢的运动员，原因很简单，因为跑道是环形的。<br>假设链表的节点数量为n，该算法的时间复杂度为O(n)。除两个指针外，没有使用任何额外的存储空间，所以空间复杂度是O(1)。  </p>
<p><strong>代码实现</strong>  </p>
<pre><code>public class LinkedList {
    /**
     * 判断链表是否有环
     * @param head 链表头节点
     * @return
     */
    public static boolean isCycle(Node head){
        Node p1 = head;
        Node p2 = head;
        while(p2!=null &amp;&amp; p2.next!=null){
            p1 = p1.next;
            p2 = p2.next.next;
            if(p1 == p2){
                return true;
            }
        }
        return false;
    }

    /**
     * 链表节点
     */
    private static class Node{
        int data;
        Node next;
        public Node(int data){
            this.data=data;
        }
    }

    public static void main(String[] args) {
        Node node1 = new Node(5);
        Node node2 = new Node(3);
        Node node3 = new Node(7);
        Node node4 = new Node(2);
        Node node5 = new Node(6);
        Node node6 = new Node(8);
        Node node7 = new Node(1);
        node1.next = node2;
        node2.next = node3;
        node3.next = node4;
        node4.next = node5;
        node5.next = node6;
        node6.next = node7;
        node7.next = node4;
        System.out.println(isCycle(node1));
    }
}</code></pre><h2 id="3-问题扩展"><a href="#3-问题扩展" class="headerlink" title="3.问题扩展"></a>3.问题扩展</h2><h3 id="3-1-扩展问题1"><a href="#3-1-扩展问题1" class="headerlink" title="3.1 扩展问题1"></a>3.1 扩展问题1</h3><p>如果链表有环，如何求出环的长度？<br><img src="/blog/img/2020/02/29/如何求链环长度.png"><br><br><strong>解题思路</strong><br>当两个指针再次相遇，证明链表有环的时候，让两个指针从相遇点继续循环前进，并且统计前进的循环次数，直到两个指针第2次相遇。此时统计出来的前进次数就是环长。<br>因为指针p1每次走1步，指针p2就走2步，两者的速度差是1步。当两个指针再次相遇时，p2比p1多走了整整一圈。<br>因此，环长 = 每一次速度差 x 前进次数 = 前进次数。<br><strong>代码实现</strong> </p>
<pre><code>public static int ringLength(Node head){
    //第1次相遇后到第2次相遇时的前进次数
    int length = 0;
    //相遇次数
    int count = 0;
    Node p1 = head;
    Node p2 = head;
    while(p2!=null &amp;&amp; p2.next!=null){
        p1 = p1.next;
        p2 = p2.next.next;
        if(p1 == p2){
            count++;
        }
        //第一次相遇
        if(count == 1){
            length++;
        }
        //第二次相遇
        if(count == 2){
            break;
        }
    }
    return length*1;
}</code></pre><p>或者  </p>
<pre><code>public static int ringLength(Node head){
    //第1次相遇后到第2次相遇时的前进次数
    int length = 0;
    Node p1 = head;
    Node p2 = head;
    while(p2!=null &amp;&amp; p2.next!=null){
        p1 = p1.next;
        p2 = p2.next.next;
        if(p1 == p2){//第一次相遇
            while(p2!=null &amp;&amp; p2.next!=null){
                p1 = p1.next;
                p2 = p2.next.next;
                length ++;
                if(p1 == p2){//第二次相遇
                    return length;
                }
            }
        }
    }
    return length;
}</code></pre><h3 id="3-2-扩展问题2"><a href="#3-2-扩展问题2" class="headerlink" title="3.2 扩展问题2"></a>3.2 扩展问题2</h3><p>如果链表有环，如何求出入环节点？<br><img src="/blog/img/2020/02/29/如何求出入环节点.png"><br><br>我自己的想法是借助一个Map集合或者List集合，每遍历一个节点就判断集合里面是否包含此节点，不包含就放进集合里面去，当第2次遍历到节点2时，集合里面包含了此节点，说明节点2就是入环点。此方法的时间复杂度是O(n)，由于借助了辅助集合，所以空间复杂度是O(n)。<br>但这不是最优解，此题还有最优解，不用借助辅助集合。<br><strong>解题思路</strong><br>首先我们来做一个抽象的判断。<br><img src="/blog/img/2020/03/01/抽象示意图.png"><br><br>上面是对有环链表所做的一个抽象示意图。假设从链表头节点到入环节点的距离是D，从入环点到两个指针首次相遇点的距离是S<sub>1</sub>，从首次相遇点回到入环节点的距离是S<sub>2</sub>。  
那么当两个指针首次相遇时，各自所走的距离是多少呢？<br>指针p1一次只走1步，所走的距离是D+S<sub>1</sub> 。<br>指针p2一次走2步，多走了1整圈，所走的距离是D+S<sub>1</sub>+S<sub>2</sub>+S<sub>1</sub> = D + 2S<sub>1</sub> + S<sub>2</sub> 。<br>由于p2的速度是p1的2倍，所以所走距离也是p1的2倍，因此：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2(D+S<sub>1</sub>) = D + 2S<sub>1</sub> + S<sub>2</sub><br>等式经过整理得出：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;D = S<sub>2</sub><br>也就是说，从链表头节点到入环节点的距离，等于首次相遇点回到入环节点的距离。<br>这样一来，只需要把其中一个指针放回到头节点位置，另一个指针保持在首次相遇点，两个指针都是每次向前走1步。那么，他们最终相遇的节点，就是入环节点。<br><strong>是不是很神奇！我们现在用原题的例子来演示一下。</strong><br>首先，让指针p1回到链表头节点，指针p2保持在首次相遇点。<br><img src="/blog/img/2020/03/01/入环点1.png"><br><br>指针p1和p2各自前进1步。<br><img src="/blog/img/2020/03/01/入环点2.png"><br><br>指针p1和p2第2次前进。<br><img src="/blog/img/2020/03/01/入环点3.png"><br><br>指针p1和p2第3次前进，指向了同一个节点2，节点2正是有环链表的入环节点。<br><img src="/blog/img/2020/03/01/入环点4.png"><br>  </p>
<p><strong>代码实现</strong>   </p>
<pre><code>public static Node entryPoint(Node head){
    Node p1 = head;
    Node p2 = head;
    while(p2!=null &amp;&amp; p2.next!=null){
        p1 = p1.next;
        p2 = p2.next.next;
        if(p1 == p2){//第一次相遇
            p1 = head;//把p1节点重新指向链表头节点
            while(p2!=null){
                //将p1和p2都设置成往前走1步
                p1 = p1.next;
                p2 = p2.next;
                if(p1 == p2){//相遇时的节点即是入环节点
                    return p1;
                }
            }
        }
    }
    return null;
}</code></pre>]]></content>
  </entry>
  <entry>
    <title>面试中的算法题整理</title>
    <url>/blog/2020/02/29/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>这里整理了一些面试中可能遇到的算法题。  </p>
<a id="more"></a>  

<p><strong>传送门</strong>  </p>
<ul>
<li>1.<a href="/blog/2020/02/29/面试中的算法题/如何判断链表有环/" target="_blank">如何判断链表有环</a></li>
<li>2.<a href="/blog/2020/03/01/面试中的算法题/最小栈的实现/" target="_blank">最小栈的实现</a></li>
<li>3.<a href="/blog/2020/03/01/面试中的算法题/如何求出最大公约数/" target="_blank">如何求出最大公约数</a></li>
<li>4.<a href="/blog/2020/03/02/面试中的算法题/判断一个数是否为2的整数次幂/" target="_blank">如何判断一个数是否为2的整数次幂</a></li>
<li>5.<a href="/blog/2020/03/02/面试中的算法题/无序数组排序后的最大相邻差/" target="_blank">无序数组排序后的最大相邻差</a></li>
<li>6.<a href="/blog/2020/03/02/面试中的算法题/如何用栈实现队列/" target="_blank">如何用栈实现队列</a></li>
<li>7.<a href="/blog/2020/03/03/面试中的算法题/寻找全排列的下一个数/" target="_blank">寻找全排列的下一个数</a></li>
<li>8.<a href="/blog/2020/03/03/面试中的算法题/删除K个数字后的最小值/" target="_blank">删除k个数字后的最小值</a></li>
<li>9.<a href="/blog/2020/03/03/面试中的算法题/如何实现大整数相加/" target="_blank">如何实现大整数相加</a></li>
<li>10.<a href="/blog/2020/03/04/面试中的算法题/如何求解金矿问题/" target="_blank">如何求解金矿问题</a></li>
<li>11.<a href="/blog/2020/03/04/面试中的算法题/寻找缺失的整数/" target="_blank">寻找缺失的整数</a></li>
<li>12.<a href="/blog/2020/03/05/面试中的算法题/字符串匹配算法/" target="_blank">字符串匹配</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>面向对象基础</title>
    <url>/blog/2020/02/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1-类与实例"><a href="#1-类与实例" class="headerlink" title="1. 类与实例"></a>1. 类与实例</h2><h3 id="对象是什么？类是什么？"><a href="#对象是什么？类是什么？" class="headerlink" title="对象是什么？类是什么？"></a>对象是什么？类是什么？</h3><p>一切事物皆为对象，即所有的东西都是对象，对象就是可以看到、感觉到、听到、触摸到、尝到、或闻到的东西。准确的说，<strong>对象是一个自包含的实体，用一组可识别的特性和行为来标识。</strong>面向对象编程，英文叫<strong>Object-Oriented Programming</strong>，其实就是针对对象来进行编程的意思。  </p>
<a id="more"></a>   
<p><strong>“类”：就是具有相同的属性和功能的对象的抽象的集合</strong>，看代码：  </p>
<pre><code>public class Cat{
    public String shout(){
        return &quot;喵&quot;;
    }
}</code></pre><p>这里’class’<strong>是表示定义类的关键字</strong>，’Cat’就是类的名称，’shout’就是类的方法。  </p>
<p><strong>“实例”：就是一个真实的对象。</strong>比如我们都是’人’，而你和我其实就是’人’类的实例了。而<strong>实例化就是创建对象的过程，使用new关键字来创建</strong>。  </p>
<pre><code>private void button1_Click(Object sender,EventArgs e){
    //将Cat类实例化
    Cat cat = new Cat();
    MessageBox.Show(cat.shout());
}</code></pre><p>注意，Cat cat = new Cat();其实做了两件事。  </p>
<pre><code>//声明一个Cat对象，对象名为cat
Cat cat;
//将此cat对象实例化
cat = new Cat();</code></pre><p>Cat实例化后，等同于出生了一只小猫cat，此时就可以让小猫cat.shout()。在任何需要小猫叫的地方都可以实例化它。  </p>
<h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h2><p><strong>构造方法，又叫构造函数，其实就是对类进行初始化。构造方法与类同名，无返回值，也不需要void，在new时候调用</strong>。  
在Cat cat = new Cat();中，new后面的Cat()其实就是构造方法。<br>有些不清楚的人可能会问，在Cat类当中没有写构造方法Cat()，怎么可以调用啊？<br>实际情况是这样的，<strong>所有类都有构造方法，如果你不编码则系统默认生成空的构造方法，若你有定义的构造方法，那么默认的构造方法就会失效了</strong>。  </p>
<pre><code>public class Cat{
    //声明Cat类的私有字符串变量name
    private String name = &quot;&quot;;
    //定义Cat类的构造方法，参数是输入一个字符串
    public Cat(String name){
        //将参数赋值给私有变量
        this.name = name;
    }        

    public String shout(){
        return &quot;我的名字叫&quot;+name+&quot; 喵&quot;;
    }
}

private void button1_Click(Object sender,EventArgs e){
    //将Cat类实例化
    Cat cat = new Cat(&quot;咪咪&quot;);
    MessageBox.Show(cat.shout());
}</code></pre><h2 id="3-方法重载"><a href="#3-方法重载" class="headerlink" title="3. 方法重载"></a>3. 方法重载</h2><p>在上面的代码示例中，如果没有实现起好小猫的名字，是不能创建这个实例的，也就是不能通过Cat cat = new Cat();这种方式创建实例。怎么才能在不起名的情况下，也能创建实例？可以用<strong>方法重载</strong>。    
<strong>方法重载提供了创建同名的多个方法的能力，但这些方法需要使用不同的参数类型</strong>。并不是只有构造方法可重载，普通方法也可以重载。</p>
<pre><code>public class Cat{
    private String name = &quot;&quot;;
    public Cat(String name){
        this.name = name;
    }        
    //构造方法重载
    public Cat(){
        this.name=&quot;无名&quot;;
    }        

    public String shout(){
        return &quot;我的名字叫&quot;+name+&quot; 喵&quot;;
    }
}</code></pre><p>这样的话再通过Cat cat = new Cat();这种方式创建实例就不会报错了。而猫叫时会是’我的名字叫无名 喵’。<br>注意：<strong>方法重载时</strong>，两个方法的名字必须要<strong>方法名相同，但参数类型或个数必须要有所不同</strong>，否则重载就没有意义了。  </p>
<p>这么做的好处是：<strong>方法重载可以在不改变原有方法的基础上，新增功能</strong>。  </p>
<h2 id="4-属性与修饰符"><a href="#4-属性与修饰符" class="headerlink" title="4. 属性与修饰符"></a>4. 属性与修饰符</h2><p><strong>属性是一个方法或一对方法，但在调用它的代码看来，它是一个字段，即属性适合于以字段的方式使用方法调用的场合</strong>。这里还需要解释一下字段的意思，<strong>字段是存储类要满足其设计所需要的数据，字段是与类相关的变量</strong>。  比如刚才的Cat类中’private String name = “”;’name其实就是一个字段，它通常是私有的类变量。那么属性是什么样的呢？我们现在增加一个’猫叫次数ShoutNum’的属性。  </p>
<pre><code>//声明一个内部字段，注意是private，默认叫的次数为3
private int shoutNum=3;

//ShoutNum属性，注意是public，当中有两个方法get表示外界调用时可以得到shoutNum的值，set表示外界可以给内部的shoutNum赋值。
public void setShoutNum(int shoutNum){//shoutNum的可写属性
    this.shoutNum=shoutNum;
}

public int getShoutNum(){//shoutNum的可读属性
    return this.shoutNum;
}</code></pre><p>其中public和private都是修饰符，<strong>public表示它所修饰的类成员可以允许其他任何类来访问，俗称公有的。而private表示只允许同一个类中的成员访问，其它类包括它的子类无法访问，俗称私有的</strong>。在java语言中如果类中的成员没有加修饰符。则默认为是default，只能同一个包下面的类可以访问（不在同一个包里面的子类不能访问），还有一种修饰符是protected，类中的成员变量可以被同一个包下面的类访问以及不同包下的子类访问。<strong>通常字段都是private，即私有的变量，而属性都是public，即公有的变量</strong>。</p>
<p><strong>PS:Java中的属性(property)，通常可以理解为get和set方法，而字段(field)，通常叫做“类成员”，或 “类成员变量”，有时也叫“域”，理解为“数据成员”，用来承载数据的。</strong><br>区别开属性与字段是为了更好的实现数据安全，比如当我们想给一个类的属性赋值或者其他类用到了，就需要将这个字段设置为public，然而这样可以对字段进行任意的读写操作，非常不利于数据安全。于是就加上了属性，简单说属性实现了字段的封装，属性有get、set 方法来控制字段，该字段的属性只有set方法没有get方法，就只可以对该方法进行赋值操作，没有读操作，反之亦然。就是对对字段的操作通过属性来控制。<br><strong>注意其规则是：去掉get或set后其剩余的字符串，如果第二个字母是小写的，则把第一个字母也变成小写，否则第一个字母也不变</strong>  </p>
<h2 id="5-封装、继承、多态"><a href="#5-封装、继承、多态" class="headerlink" title="5. 封装、继承、多态"></a>5. 封装、继承、多态</h2><p>具体参考这篇<a href="/blog/2019/08/20/面向对象的三大基本特征，七大基本原则/" target="_blank">文章</a>   </p>
<h2 id="6-抽象类与接口"><a href="#6-抽象类与接口" class="headerlink" title="6.抽象类与接口"></a>6.抽象类与接口</h2><p>待定</p>
]]></content>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/blog/2020/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在访问者模式(Visitor Pattern)中，我们使用了一个访问者类，他改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已经接受访问者对象，这样对访问者对象就可以处理元素对象上的操作。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>表示一个作用于某对象结构中的个元素操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作（主要将数据结构与数据操作分离）。<br><strong>主要解决：</strong>稳定的数据结构和异变的操作耦合问题。<br><strong>何时使用：</strong>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。<br><strong>如何解决：</strong>在数据基础类里面增加一个对外提供接待访问者的接口。<br><strong>关键代码：</strong>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。<br><strong>应用实例：</strong>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。<br><strong>优点：</strong>1、符合单一职责原则。2、优秀的扩展性。3、灵活性。<br><strong>缺点：</strong>1、具体元素对访问者公布细节，违反了迪米特原则。2、具体元素变更比较困难。3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。<br><strong>使用场景：</strong>1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。<br><strong>注意事项：</strong>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/02/28/访问者模式结构图.png">  

<h2 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h2><h3 id="3-1男人和女人！"><a href="#3-1男人和女人！" class="headerlink" title="3.1男人和女人！"></a>3.1男人和女人！</h3><img src="/blog/img/2020/02/28/男人与女人1.png">   
<img src="/blog/img/2020/02/28/男人与女人2.png">   

<h3 id="3-2简单的面向对象实现！"><a href="#3-2简单的面向对象实现！" class="headerlink" title="3.2简单的面向对象实现！"></a>3.2简单的面向对象实现！</h3><p>“人”类，是”男人”和”女人”类的抽象类  </p>
<pre><code>public abstract class Person {
    protected String action;

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }
    //得到结论或反应
    public abstract void getConclusion();
} </code></pre><p>“男人”类  </p>
<pre><code>class Man extends Person{

    @Override
    public void getConclusion() {
        if(action.equals(&quot;成功&quot;)){
            System.out.println(&quot;男人&quot;+action+&quot;时，背后多半有一个伟大的女人。&quot;);
        }else if(action.equals(&quot;失败&quot;)){
            System.out.println(&quot;男人&quot;+action+&quot;时，闷头喝酒，谁也不用劝。&quot;);
        }else if(action.equals(&quot;恋爱&quot;)){
            System.out.println(&quot;男人&quot;+action+&quot;时，凡是不懂也要装懂。&quot;);
        }
    }
}</code></pre><p>“女人”类  </p>
<pre><code>class Woman extends Person{

    @Override
    public void getConclusion() {
        if(action.equals(&quot;成功&quot;)){
            System.out.println(&quot;女人&quot;+action+&quot;时，背后大多有一个不成功的男人。&quot;);
        }else if(action.equals(&quot;失败&quot;)){
            System.out.println(&quot;女人&quot;+action+&quot;时，眼泪汪汪，谁也劝不了。&quot;);
        }else if(action.equals(&quot;恋爱&quot;)){
            System.out.println(&quot;女人&quot;+action+&quot;时，遇事懂也装作不懂。&quot;);
        }
    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        List&lt;Person&gt; persons = new ArrayList&lt;&gt;();

        Person man1 = new Man();
        man1.setAction(&quot;成功&quot;);
        persons.add(man1);
        Person woman1 = new Woman();
        woman1.setAction(&quot;成功&quot;);
        persons.add(woman1);

        Person man2 = new Man();
        man2.setAction(&quot;失败&quot;);
        persons.add(man2);
        Person woman2 = new Woman();
        woman2.setAction(&quot;失败&quot;);
        persons.add(woman2);

        Person man3 = new Man();
        man3.setAction(&quot;恋爱&quot;);
        persons.add(man3);
        Person woman3 = new Woman();
        woman3.setAction(&quot;恋爱&quot;);
        persons.add(woman3);

        for (Person person : persons) {
            person.getConclusion();
        }
    }
}</code></pre><p>运行结果  </p>
<pre><code>男人成功时，背后多半有一个伟大的女人。
女人成功时，背后大多有一个不成功的男人。
男人失败时，闷头喝酒，谁也不用劝。
女人失败时，眼泪汪汪，谁也劝不了。
男人恋爱时，凡是不懂也要装懂。
女人恋爱时，遇事懂也装作不懂。</code></pre><p>虽然代码算是面向对象的编程了，但是在’男人’类和’女人’类当中的那些if······else······很是碍眼。<br>而且如果现在要增加一个’结婚’状态，需要改什么？<br>这两个类都需要增加分支判断了。怎么处理这种情况？  </p>
<h3 id="3-3用了模式的实现"><a href="#3-3用了模式的实现" class="headerlink" title="3.3用了模式的实现"></a>3.3用了模式的实现</h3><p>结构图  </p>
<img src="/blog/img/2020/02/28/男人与女人结构图.png">  

<p>‘状态’的抽象类  </p>
<pre><code>public abstract class Action {
    //得到男人结论或反应
    public abstract void getManConclusion(Man concreteElementA);
    //得到女人结论或反应
    public abstract void getWomanConclusion(Woman concreteElementB);
}</code></pre><p>‘人’的抽象类  </p>
<pre><code>public abstract class Person {
    //接受
    public abstract void accept(Action visitor);
}</code></pre><p>这里的关键就在于人就只分为男人和女人，这个性别的分类是稳定的，所以可以在状态类中，增加’男人反应’和’女人反应’两个方法，方法的个数是稳定的，不会很容易的发生变化。而’人’的抽象类中有一个抽象方法’接受’，它是用来获得’状态’对象的。每一种具体状态都继承’状态’抽象类，实现两个反应的方法。 </p>
<p>具体’状态类’  </p>
<pre><code>/成功
class Success extends Action{

    @Override
    public void getManConclusion(Man concreteElementA) {
        System.out.println(&quot;男人成功时，背后多半有一个伟大的女人。&quot;);
    }

    @Override
    public void getWomanConclusion(Woman concreteElementB) {
        System.out.println(&quot;女人成功时，背后大多有一个不成功的男人。&quot;);
    }
}

//失败
class Failing extends Action{

    @Override
    public void getManConclusion(Man concreteElementA) {
        System.out.println(&quot;男人失败时，闷头喝酒，谁也不用劝。&quot;);
    }

    @Override
    public void getWomanConclusion(Woman concreteElementB) {
        System.out.println(&quot;女人失败时，眼泪汪汪，谁也劝不了。&quot;);
    }
}

//恋爱
class Amativeness extends Action{

    @Override
    public void getManConclusion(Man concreteElementA) {
        System.out.println(&quot;男人恋爱时，凡是不懂也要装懂。&quot;);
    }

    @Override
    public void getWomanConclusion(Woman concreteElementB) {
        System.out.println(&quot;女人恋爱时，遇事懂也装作不懂。&quot;);
    }
}</code></pre><p>“男人”类和”女人”类  </p>
<pre><code>//男人
class Man extends Person{

    @Override
    public void accept(Action visitor) {
        //首先在客户程序中将具体状态作为参数传递给&quot;男人&quot;类
        //完成了一次分派，然后&quot;男人&quot;类调用作为参数的&quot;具体状态&quot;
        //中的方法&quot;男人反应&quot;，同时将自己(this)作为参数传递进去。
        //这便完成了第二次分派
        visitor.getManConclusion(this);
    }
}
//女人
class Woman extends Person{

    @Override
    public void accept(Action visitor) {
        visitor.getWomanConclusion(this);
    }
}</code></pre><p>这里需要提一下当中用到的双分派技术，首先在客户程序中将具体状态作为参数传递给”男人”类完成了一次分派，然后”男人”类调用作为参数的”具体状态”中的方法”男人反应”，同时将自己(this)作为参数传递进去。这便完成了第二次分派。双分派意味着得到执行的操作决定于请求的种类和两个接收者的类型。’接受’方法就是一个双分派的操作，它得到执行的操作不仅决定于’状态类’的具体状态，还决定于它访问’人’的类别。  </p>
<p>对象结构类 由于总是需要’男人’与’女人’在不同状态的对比，所以我们需要一个’对象结构’类来针对不同的’状态’遍历’男人’与’女人’，得到不同反应。  </p>
<pre><code>public class ObjectStructure {
    private List&lt;Person&gt; elements = new ArrayList&lt;&gt;();

    //增加
    public void attach(Person element){
        elements.add(element);
    }

    //移除
    public void detach(Person element){
        elements.remove(element);
    }

    //查看显示
    public void display(Action visitor){
        for (Person person : elements) {
            person.accept(visitor);
        }
    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        ObjectStructure o = new ObjectStructure();
        o.attach(new Man());
        o.attach(new Woman());

        //成功时的反应
        Success v1 = new Success();
        o.display(v1);

        //失败时的反应
        Failing v2 = new Failing();
        o.display(v2);

        //恋爱时的反应
        Amativeness v3 = new Amativeness();
        o.display(v3);
    }
}</code></pre><p>现在这么做的好处就是，如果我们现在要增加’结婚’的状态来考察’男人’和’女人’的反应，只需要增加一个’状态’子类，就可以在客户端调用来查看，不需要改动其他任何类的代码。  </p>
<h2 id="4-访问者模式基本代码"><a href="#4-访问者模式基本代码" class="headerlink" title="4.访问者模式基本代码"></a>4.访问者模式基本代码</h2><p>Visitor类，为该对象结构中ConcreteElement的每一个类声明一个Visit操作。  </p>
<pre><code>public abstract class Visitor {
    public abstract void visitConcreteElementA(ConcreteElementA concreteElementA);
    public abstract void visitConcreteElementB(ConcreteElementB concreteElementB);
}</code></pre><p>ConcreteVisitor1和ConcreteVisitor2类，具体的访问者，实现每个有Visitor声明的操作。每个操作实现算法的一部分，而该算法片段乃是对应于结构中对象的类。  </p>
<pre><code>class ConcreteVisitor1 extends Visitor{

    @Override
    public void visitConcreteElementA(ConcreteElementA concreteElementA) {
        System.out.println(concreteElementA.getClass().getName()+&quot; 被  &quot;+this.getClass().getName()+&quot;  访问&quot;);
    }

    @Override
    public void visitConcreteElementB(ConcreteElementB concreteElementB) {
        System.out.println(concreteElementB.getClass().getName()+&quot; 被  &quot;+this.getClass().getName()+&quot;  访问&quot;);
    }
}

class ConcreteVisitor2 extends Visitor{

    @Override
    public void visitConcreteElementA(ConcreteElementA concreteElementA) {
        System.out.println(concreteElementA.getClass().getName()+&quot; 被  &quot;+this.getClass().getName()+&quot;  访问&quot;);
    }

    @Override
    public void visitConcreteElementB(ConcreteElementB concreteElementB) {
        System.out.println(concreteElementB.getClass().getName()+&quot; 被  &quot;+this.getClass().getName()+&quot;  访问&quot;);
    }
}</code></pre><p>Element类，定义一个accept操作，它以一个访问者为参数。  </p>
<pre><code>public abstract class Element {
    //接受
    public abstract void accept(Visitor visitor);
}</code></pre><p>ConcreteElementA和ConcreteElementB类，具体元素，实现accept操作。  </p>
<pre><code>class ConcreteElementA extends Element{

    @Override
    public void accept(Visitor visitor) {
        visitor.visitConcreteElementA(this);
    }

    //其他相关方法
    public void operationA(){

    }
}

class ConcreteElementB extends Element{

    @Override
    public void accept(Visitor visitor) {
        visitor.visitConcreteElementB(this);
    }

    //其他相关方法
    public void operationB(){

    }
}</code></pre><p>ObjectStructure类，能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素。  </p>
<pre><code>public class ObjectStructure {
    private List&lt;Element&gt; elements = new ArrayList&lt;&gt;();

    //增加
    public void attach(Element element){
        elements.add(element);
    }

    //移除
    public void detach(Element element){
        elements.remove(element);
    }

    public void accept(Visitor visitor){
        for (Element person : elements) {
            person.accept(visitor);
        }
    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        ObjectStructure o = new ObjectStructure();
        o.attach(new ConcreteElementA());
        o.attach(new ConcreteElementB());

        ConcreteVisitor1 v1 = new ConcreteVisitor1();
        ConcreteVisitor2 v2 = new ConcreteVisitor2();

        o.accept(v1);
        o.accept(v2);
    }
}</code></pre><h2 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5.参考文章"></a>5.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/visitor-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/blog/2020/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>解释器模式(Interpreter Pattern)提供了评估语言的语法或表达式的方式。它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>给定一个语法，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。<br><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。<br><strong>何时使用：</strong>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。<br><strong>如何解决：</strong>构建语法树，定义终结符与非终结符。<br><strong>关键代码：</strong>构建环境类，包好解释器之外的一些全局信息，一般是HashMap。<br><strong>应用实例：</strong>1、编译器、运算表达式计算。2、浏览器解释HTML文法，转换成网页格式显示到用户面前。<br><strong>优点：</strong>1、可扩展性比较好，灵活。2、增加了新的解释表达式的方式。3、易于实现简单文法。<br><strong>缺点：</strong>1、可利用场景比较少。2、对于复杂的文法比较难维护。3、解释器模式会引起类膨胀。4、解释器模式采用递归调用方法。<br><strong>使用场景：</strong>1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。2、一些重复出现的问题可以用一种简单的语言表达式来进行表达。3、一个简单语法需要解释的场景。<br><strong>注意事项：</strong>可利用场景比较少，JAVA中如果碰到可以用expression4J代替。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/02/28/解释器模式结构图.png">  

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>AbstractExpression(抽象表达式)，声明一个抽象类，这个接口为抽象语法树中所有的节点所共享。  </p>
<pre><code>public abstract class AbstractExpression {
    public abstract void interpret(Context context);
}</code></pre><p>TerminalExpression（终结符表达式），实现与文法中的终结符相关联的解释操作。实现抽象表达式中所要求的接口，主要是一个interpret()方法。文法中每一个终结符都有一个具体终结表达式与之相对应。  </p>
<pre><code>public class TerminalExpression extends AbstractExpression {
    @Override
    public void interpret(Context context) {
        System.out.println(&quot;终端解释器&quot;);
    }
}</code></pre><p>NonterminalExpression(非终结符表达式)，为文法中的非终结符实现解释操作。对文法中每一条规则R1、R2······Rn都需要一个具体的非终结符表达式类。通过实现抽象表达式的interpret()方法实现解释操作。解释操作以递归方式调用上面所提到的代表R1、R2······Rn中各个符号的实例变量。  </p>
<pre><code>public class NonterminalExpression extends AbstractExpression {
    @Override
    public void interpret(Context context) {
        System.out.println(&quot;非终端解释器&quot;);
    }
}</code></pre><p>Context，包含解释器之外的一些全局信息  </p>
<pre><code>public class Context {

    private String input;

    public String getInput() {
        return input;
    }

    public void setInput(String input) {
        this.input = input;
    }

    private String output;

    public String getOutput() {
        return output;
    }

    public void setOutput(String output) {
        this.output = output;
    }

}</code></pre><p>客户端代码，构建表示该文法定义语言中一个特定的句子的抽象语法树。调用解释操作。  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Context c = new Context();
        List&lt;AbstractExpression&gt; list = new ArrayList&lt;&gt;();
        list.add(new TerminalExpression());
        list.add(new NonterminalExpression());
        list.add(new TerminalExpression());
        list.add(new TerminalExpression());

        for (AbstractExpression expression : list) {
            expression.interpret(c);
        }
    }
}</code></pre><p>运行结果  </p>
<pre><code>终端解释器
非终端解释器
终端解释器
终端解释器</code></pre><h2 id="4-实例-音乐解释器实现"><a href="#4-实例-音乐解释器实现" class="headerlink" title="4.实例(音乐解释器实现)"></a>4.实例(音乐解释器实现)</h2><img src="/blog/img/2020/02/28/音乐解释器1.png">  
<img src="/blog/img/2020/02/28/音乐解释器2.png">  

<p><strong>代码结构图</strong><br><img src="/blog/img/2020/02/28/音乐解释器结构图.png">  </p>
<p><strong>代码示例</strong><br>演奏内容类(Context)  </p>
<pre><code>public class PlayContext {
    private String text;

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

}</code></pre><p>表达式类(AbstractExpression)  </p>
<pre><code>public abstract class Expression {

    //解释器
    public void interpret(PlayContext context){
        if(context.getText()==null || context.getText().length()==0){
            return;
        }else{
            //此方法用于将当前的演奏文本第一条命令
            //获得命令字母和其参数值。
            //例如&quot;O 3 E 0.5 G 0.5 A 3&quot;
            //则playKey为O，而playValue为3
            String text = context.getText();
            String playKey = text.substring(0,1);
            text = text.substring(2);
            double playValue = Double.valueOf(text.substring(0,text.indexOf(&quot; &quot;)));
            //获得playKey和playValue后将其从演奏文本中移除
            //例如&quot;O 3 E 0.5 G 0.5 A 3&quot;
            //变成了&quot;E 0.5 G 0.5 A 3&quot;
            text = text.substring(text.indexOf(&quot; &quot;)+1);
            context.setText(text);

            excute(playKey,playValue);
        }
    }

    //执行
    //抽象方法&quot;执行&quot;，不同的文法子类，有不同的执行处理
    public abstract void excute(String key,double value);
}</code></pre><p>音符类(TerminalExpression)  </p>
<pre><code>public class Note extends Expression {

    @Override
    public void excute(String key, double value) {
        String note = &quot;&quot;;
        switch(key){
            case &quot;C&quot;:
                note = &quot;1&quot;;
                break;
            case &quot;D&quot;:
                note = &quot;2&quot;;
                break;
            case &quot;E&quot;:
                note = &quot;3&quot;;
                break;
            case &quot;F&quot;:
                note = &quot;4&quot;;
                break;
            case &quot;G&quot;:
                note = &quot;5&quot;;
                break;
            case &quot;A&quot;:
                note = &quot;6&quot;;
                break;
            case &quot;B&quot;:
                note = &quot;7&quot;;
                break;
        }
        System.out.print(note+&quot; &quot;);
    }
}</code></pre><p>音阶类(TerminalExpression)  </p>
<pre><code>public class Scale extends Expression {

    @Override
    public void excute(String key, double value) {
        String scale = &quot;&quot;;
        switch((int)value){
            case 1:
                scale = &quot;低音&quot;;
                break;
            case 2:
                scale = &quot;中音&quot;;
                break;
            case 3:
                scale = &quot;高音&quot;;
                break;
        }
        System.out.print(scale+&quot; &quot;);
    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Client {
    public static void main(String[] args) {
        PlayContext context = new PlayContext();
        //音乐-上海滩
        System.out.println(&quot;上海滩：&quot;);
        context.setText(&quot;O 2 E 0.5 G 0.5 A 3 E 0.5 G 0.5 D 3 E 0.5 G 0.5 A 0.5 O 3 C 1 O 2 A 0.5 G 1 C 0.5 E 0.5 D 3 &quot;);
        //下面的这一段代码可以使用简单工厂代替
        Expression expression = null;
        try {
            while(context.getText().length()&gt;0){
                String text = context.getText().substring(0,1);
                switch (text) {
                    case &quot;O&quot;://当首字母是O时，则表达式实例化为音阶
                        expression = new Scale();
                        break;
                    case &quot;C&quot;:
                    case &quot;D&quot;:
                    case &quot;E&quot;:
                    case &quot;F&quot;:
                    case &quot;G&quot;:
                    case &quot;A&quot;:
                    case &quot;B&quot;:
                    case &quot;P&quot;://当首字母是CDEFGAB，以及休止符P时，则表达式实例化为音符
                        expression = new Note();
                        break;
                }
                expression.interpret(context);
            }
        } catch (Exception e) {
            e.getStackTrace();
        }
    }
}</code></pre><p>运行结果  </p>
<pre><code>上海滩：
中音 3 5 6 3 5 2 3 5 6 高音 1 中音 6 5 1 3 2 </code></pre><h2 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5.参考文章"></a>5.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/interpreter-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/interpreter-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/blog/2020/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>享元模式(Flyweight Pattern)主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，他提供了减少对象数量从而改变所需的对象结构的方式。<br>享元模式尝试重用现有的对象，如果未找到匹配的对象，则创建新的对象。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>运算共享技术有效的支持大量细粒度的对象。<br><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重复创建。<br><strong>何时使用：</strong>1、系统中有大量对象。2、这些对象消耗大量内存。3、这些对象的状态大部分可以外部化。4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。5、系统不依赖于这些对象身份，这些对象是不可分辨的。<br><strong>如何解决：</strong>用唯一标识码判断，如果内存中有，则返回这个唯一标识码所标识的对象。<br><strong>关键代码：</strong>用HashMap存储这些对象。<br><strong>应用实例：</strong>1、JAVA中的String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。。2、数据库的数据池。<br><strong>优点：</strong>大大较少对象的创建，降低系统的内存，使效率提高。<br><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。<br><strong>使用场景：</strong>1、系统有大量相似对象。2、需要缓冲池的场景。<br><strong>注意事项：</strong>1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。2、这些类必须有一个工厂对象加以控制。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/02/28/享元模式结构图.png">  

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>Flyweight类，他是所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态。  </p>
<pre><code>public abstract class Flyweight {
    public abstract void operation(int extrinsicstate);
}</code></pre><p>ConcreteFlyweight是继承Flyweight超类或实现Flyweight接口，并为内部状态增加存储空间。  </p>
<pre><code>public class ConcreteFlyweight extends Flyweight{

    @Override
    public void operation(int extrinsicstate) {
        System.out.println(&quot;具体Flyweight：  &quot;+extrinsicstate);
    }

}</code></pre><p>UnsharedConcreteFlyweight是指那些不需要共享的Flyweight子类。因为Flyweight接口共享成为可能，但它并不强制共享。  </p>
<pre><code>public class UnsharedConcreteFlyweight extends Flyweight{

    @Override
    public void operation(int extrinsicstate) {
        System.out.println(&quot;不共享的具体Flyweight：  &quot;+extrinsicstate);
    }

}</code></pre><p>FlyweightFactory，是一个享元工厂，用来创建并管理Flyweight对象。它主要用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。  </p>
<pre><code>public class FlyweightFactory {

    private Hashtable&lt;String, Object&gt; flyweights = new Hashtable&lt;&gt;();

    //初始化工厂时，先生成三个实例(可以不用在此初始化实例)
    public FlyweightFactory(){
        flyweights.put(&quot;X&quot;, new ConcreteFlyweight());
        flyweights.put(&quot;Y&quot;, new ConcreteFlyweight());
        flyweights.put(&quot;Z&quot;, new ConcreteFlyweight());
    }

    //根据客户端请求，获得已生成的实例，如果不存在则创建一个
    public Flyweight getFlyweight(String key){
        if(!flyweights.containsKey(key) || flyweights.get(key)==null){
            Flyweight flyweight = new ConcreteFlyweight();
            flyweights.put(key, flyweight);
        }
        return (Flyweight)flyweights.get(key);
    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        //外部代码状态
        int extrinsicstate = 22;

        FlyweightFactory f = new FlyweightFactory();

        Flyweight fx = f.getFlyweight(&quot;X&quot;);
        fx.operation(--extrinsicstate);

        Flyweight fy = f.getFlyweight(&quot;Y&quot;);
        fy.operation(--extrinsicstate);

        Flyweight fz = f.getFlyweight(&quot;Z&quot;);
        fz.operation(--extrinsicstate);

        Flyweight fa = f.getFlyweight(&quot;A&quot;);
        fa.operation(--extrinsicstate);

        UnsharedConcreteFlyweight uf = new UnsharedConcreteFlyweight();
        uf.operation(--extrinsicstate);
    }
}</code></pre><p>运行结果  </p>
<pre><code>具体Flyweight：  21
具体Flyweight：  20
具体Flyweight：  19
具体Flyweight：  18
不共享的具体Flyweight：  17</code></pre><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/flyweight-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/flyweight-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/blog/2020/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>中介者模式(Mediator Pattern)又叫做调停者模式，是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互交互，从而使其耦合松散，而且可以独立的改变他们之间的交互。<br><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得复杂很多，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。<br><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。<br><strong>如何解决：</strong>将上述与网状结构分离为星型结构。<br><strong>关键代码：</strong>对象Colleague之间的通信封装到一个类中单独处理。<br><strong>应用实例：</strong>1、中国加入WTO之前是各个国家相互贸易，结构复杂，现在是各个国家通过WTO来相互贸易。2、机场调度系统。3、MVC框架，其中C（控制器）就是M（模型）和V（视图）的中介者。<br><strong>优点：</strong>1、降低了类的复杂度，将一对多转换成了一对一。2、各个类之间的解耦。3、符合迪米特原则。<br><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。<br><strong>使用场景：</strong>1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。<br><strong>注意事项：</strong>不应当在职责混乱的时候使用。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/02/28/中介者模式结构图.png">  

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>Mediator类 抽象中介者类  </p>
<pre><code>public abstract class Mediator {

    //定义一个抽象的发送消息方法，得到同事对象和发送信息
    public abstract void send(String message,Colleague colleague);
}</code></pre><p>Colleague类 抽象同事类  </p>
<pre><code>public abstract class Colleague {

    protected Mediator mediator;
    //构造方法，得到中介者对象
    public Colleague(Mediator mediator){
        this.mediator=mediator;
    }
}</code></pre><p>ConcreteMediator类 具体中介者类  </p>
<pre><code>public class ConcreteMediator extends Mediator {

    private ConcreteColleague1 colleague1;
    private ConcreteColleague2 colleague2;

    //需要了解所有的具体同事类
    public void setColleague1(ConcreteColleague1 colleague1){
        this.colleague1=colleague1;
    }

    public void setColleague2(ConcreteColleague2 colleague2){
        this.colleague2=colleague2;
    }

    @Override
    public void send(String message, Colleague colleague) {
        if(colleague == colleague1){
            colleague2.Notify(message);
        }else{
            colleague1.Notify(message);
        }
    }

}</code></pre><p>ConcreteColleague1和ConcreteColleague2等各种同事对象  </p>
<pre><code>public class ConcreteColleague1 extends Colleague{

    public ConcreteColleague1(Mediator mediator) {
        super(mediator);
    }

    //发送消息时通常是中介者发送出去的
    public void send(String message){
        mediator.send(message, this);
    }

    public void Notify(String message){
        System.out.println(&quot;同事1得到消息  &quot;+message);
    }
}

class ConcreteColleague2 extends Colleague{

    public ConcreteColleague2(Mediator mediator) {
        super(mediator);
    }
    //发送消息时通常是中介者发送出去的
    public void send(String message){
        mediator.send(message, this);
    }

    public void Notify(String message){
        System.out.println(&quot;同事2得到消息  &quot;+message);
    }
}</code></pre><p>客户端调用  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        ConcreteMediator m = new ConcreteMediator();
        //让两个具体同事认识中介者对象
        ConcreteColleague1 c1 = new ConcreteColleague1(m);
        ConcreteColleague2 c2 = new ConcreteColleague2(m);
        //让中介者认识各个具体同事类对象
        m.setColleague1(c1);
        m.setColleague2(c2);

        //具体同事类对象发送都是通过中介者转发
        c1.send(&quot;吃过饭了吗？&quot;);
        c2.send(&quot;没有，你打算请客？&quot;);
    }
}</code></pre><p>运行结果  </p>
<pre><code>同事2得到消息  吃过饭了吗？
同事1得到消息  没有，你打算请客？</code></pre><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/mediator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/mediator-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>职责链模式</title>
    <url>/blog/2020/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>职责链模式又称责任链模式(Chain Responsibility Pattern)为请求创建了一个接收对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计属于行为型模式。<br>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，以此类推。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户端只需要把请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。<br><strong>何时使用：</strong>在处理消息的时候以过滤很多道。<br><strong>如何解决：</strong>拦截的类都实现统一接口。<br><strong>关键代码：</strong>Handler里面聚合它自己，在HandlerRequest里判断是否合适，如果没达到条件则向下传递，向谁传递之前set进去。<br><strong>应用实例：</strong>1、红楼梦中的”击鼓传花”。2.JS中的事件冒泡。3、JAVA中Apache Tomcat对Encoding的处理，Struts2的拦截器，jsp servlet的Filter。<br><strong>优点：</strong>1、降低耦合度。它将请求的发送者和接收者解耦。2、简化了对象。使得对象不需要知道链的结构。3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态的新增或者删除责任。4、增加新的请求处理很方便。<br><strong>缺点：</strong>1、不能保证请求一定被接收。2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。3、可能不容易观察运行时的特征，有碍于除错。<br><strong>使用场景：</strong>1、有多个对象可以处理同一请求，具体哪个对象处理该请求由运行时刻自动确定。2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。3、可动态指定一组对象处理请求。<br><strong>注意事项：</strong>在JAVA WEB中遇到很多应用。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/02/27/职责链模式结构图.png">  

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>Handler类，定义一个处理请示的接口  </p>
<pre><code>public abstract class Handler {

    protected Handler successor;

    //设置继任者
    public void setSuccessor(Handler successor){
        this.successor=successor;
    }

    //处理请求的抽象方法
    public abstract void handlerRequest(int request);
}</code></pre><p>ConcreteHandler类，具体处理者，处理它所负责的请求，可以访问它的继任者，如果可处理该请求，就处理之，否则就将该请求转发给它的继任者。  </p>
<pre><code>//ConcreteHandler1，当请求数在0到10之间则有权处理，否则转到下一位。
public class ConcreteHandler1 extends Handler{

    @Override
    public void handlerRequest(int request) {
        //0到10处理该请求
        if(request&gt;=0 &amp;&amp; request&lt;10){
            System.out.println(this.getClass().getName()+&quot;处理请求&quot;+request);
        }else if(successor != null){
            //转移到下一位
            successor.handlerRequest(request);
        }
    }

}

//ConcreteHandler2，当请求数在10到20之间则有权处理，否则转到下一位。
class ConcreteHandler2 extends Handler{

    @Override
    public void handlerRequest(int request) {
        //10到20处理该请求
        if(request&gt;=10 &amp;&amp; request&lt;20){
            System.out.println(this.getClass().getName()+&quot;处理请求&quot;+request);
        }else if(successor != null){
            //转移到下一位
            successor.handlerRequest(request);
        }
    }

}

//ConcreteHandler3，当请求数在20到30之间则有权处理，否则转到下一位。
class ConcreteHandler3 extends Handler{

    @Override
    public void handlerRequest(int request) {
        //20到30处理该请求
        if(request&gt;=20 &amp;&amp; request&lt;30){
            System.out.println(this.getClass().getName()+&quot;处理请求&quot;+request);
        }else if(successor != null){
            //转移到下一位
            successor.handlerRequest(request);
        }
    }

}</code></pre><p>客户端代码，向链上的具体处理者对象提交请求。  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Handler h1 = new ConcreteHandler1();
        Handler h2 = new ConcreteHandler2();
        Handler h3 = new ConcreteHandler3();
        //设置职责链的上家和下家
        h1.setSuccessor(h2);
        h2.setSuccessor(h3);

        int request = (int)(Math.random()*30);
        h1.handlerRequest(request);
    }
}</code></pre><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/blog/2020/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>命令模式(Command Pattern)是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传递给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化：对请求排队或记录请求日志，以及支持可撤销的操作。<br><strong>主要解决：</strong>在软件系统中，行为请求者与实现者通常是一种紧耦合关系，但某些场合，比如需要对行为进行记录、撤销或重做、事物等处理时，这种无法抵御变化的紧耦合设计就不太合适。<br><strong>何时使用：</strong>在某些场合，比如需要对行为进行’记录、撤销/重做、事物’等处理，这种无法抵御变化的紧耦合设计是不合适的。在这种情况下，如何将’行为请求者’与’行为实现者’解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。<br><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。<br><strong>关键代码：</strong>定义三个角色：1、received真正的命令执行对象2、Command 3、invoker使用命令对象的入口。<br><strong>应用实例：</strong>struts1中的action核心控制器ActionServlet只有一个，相当于invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的Command。<br><strong>优点：</strong>1、降低了系统的耦合度。2、新的命令可以很容易添加到系统中去。<br><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。<br><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如：1、GUI中的每一个按钮都是一条命令。2、模拟CMD。<br><strong>注意事项：</strong>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/02/27/命令模式结构图.png">  

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>Command类，用来声明执行操作的接口(也就是命令)  </p>
<pre><code>public abstract class Command {
    protected Receiver receiver;

    public Command(Receiver receiver){
        this.receiver=receiver;
    }

    public abstract void execute();
}</code></pre><p>ConcreteCommand类，将一个接收者对象绑定于一个动作，调用接接收者相应的操作，以实现execute。  </p>
<pre><code>public class ConcreteCommand extends Command{

    public ConcreteCommand(Receiver receiver) {
        super(receiver);
    }

    @Override
    public void execute() {
        receiver.action();
    }

}</code></pre><p>Invoker类，要求该命令执行这个请求。  </p>
<pre><code>//可以增加对命令的撤销/重做等功能，代码略
public class Invoker {
    private Command command;
    //多个命令请求
    //private List&lt;Command&gt; commandList;

    public void setCommand(Command command){
        this.command=command;
    }

    public void executeCommand(){
        command.execute();
    }
}</code></pre><p>Receiver类，知道如何实施与执行一个请求相关的操作，任何类都可能作为一个接收者。  </p>
<pre><code>public class Receiver {

    public void action(){
        System.out.println(&quot;执行请求！&quot;);
    }
}</code></pre><p>客户端代码，创建一个具体的命令对象并设定它的接收者。  </p>
<pre><code>public class Client {
    public static void main(String[] args) {
        Receiver receiver = new Receiver();
        Command command = new ConcreteCommand(receiver);
        Invoker invoker = new Invoker();

        invoker.setCommand(command);
        invoker.executeCommand();
    }
}</code></pre><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/command-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/command-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/blog/2020/02/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>桥接(Bridge)模式是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它是通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。<br>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类，这两种类型的类可被结构化改变而互不影响。  </p>
<a id="more"></a>  
<h2 id="1-凭什么你的游戏我不可以玩"><a href="#1-凭什么你的游戏我不可以玩" class="headerlink" title="1.凭什么你的游戏我不可以玩"></a>1.凭什么你的游戏我不可以玩</h2><img src="/blog/img/2020/02/26/凭什么你的游戏我不可以玩1.png">   
<img src="/blog/img/2020/02/26/凭什么你的游戏我不可以玩2.png">   

<h2 id="2-紧耦合的程序演化"><a href="#2-紧耦合的程序演化" class="headerlink" title="2.紧耦合的程序演化"></a>2.紧耦合的程序演化</h2><p>上面的对话蕴含了两种完全不同的思维方式：手机硬件软件和PC硬件软件。<br>现在我们来看个例子：现在有一个N品牌手机，它有一个小游戏，我要玩游戏，程序如何写？<br>第1步：先写一个次品牌的游戏类<br>第2步：再用客户端调用即可  </p>
<p>游戏类  </p>
<pre><code>//N品牌的手机中的游戏
public class HandsetGame{
    public void run(){
        System.out.println(&quot;运行N品牌手机游戏&quot;);
    }
}  </code></pre><p>客户端代码  </p>
<pre><code>HandsetGame game = new HandsetGame();
game.run();</code></pre><p>很好，现在又有一个M品牌的手机，也有小游戏，客户端也可以调用，如何做？<br>可以知道现在有两个品牌，都有游戏，从面向对象的思想来说，应该有一个父类”手机品牌游戏”，然后让N和M品牌的手机游戏都继承于它。所以基本代码如下：<br>手机游戏类  </p>
<pre><code>public class HandsetGame{
    public void run(){}
}</code></pre><p>M品牌手机游戏和N品牌手机游戏  </p>
<pre><code>public class HandsetMGame extends HandsetGame{
    @Override
    public void run(){
        System.out.println(&quot;运行M品牌手机游戏&quot;);
    }
}

class HandsetNGame extends HandsetGame{
    @Override
    public void run(){
        System.out.println(&quot;运行N品牌手机游戏&quot;);
    }
}</code></pre><p>然后，由于手机都需要通讯录功能，于是N品牌和M品牌都增加了通讯录的增删改查功能。又如何处理？<br>这里开始就变得稍微有点麻烦了，那就意味着，父类应该是’手机品牌’，下有’手机品牌M’和’手机品牌N’，每个子类下各有’通讯录’和’游戏’子类。<br>代码结构图如下<br><img src="/blog/img/2020/02/26/手机品牌结构图1.png">  </p>
<p>手机类  </p>
<pre><code>public class HandsetBrand {
    public void run() {}
}  </code></pre><p>手机品牌N和手机品牌M类  </p>
<pre><code>//手机品牌M
class HandsetBrandM extends HandsetBrand{

}
//手机品牌N
class HandsetBrandN extends HandsetBrand{

}</code></pre><p>下属各自通讯录类和游戏类  </p>
<pre><code>//手机品牌M的游戏
class HandsetBrandMGame extends HandsetBrandM{
    @Override
    public void run() {
        System.out.println(&quot;运行M品牌手机游戏&quot;);
    }
}
//手机品牌N的游戏
class HandsetBrandNGame extends HandsetBrandN{
    @Override
    public void run() {
        System.out.println(&quot;运行N品牌手机游戏&quot;);
    }
}
//手机品牌M的通讯录
class HandsetBrandMAddressList extends HandsetBrandM{
    @Override
    public void run() {
        System.out.println(&quot;运行M品牌手机通讯录&quot;);
    }
}
//手机品牌N的通讯录
class HandsetBrandNAddressList extends HandsetBrandN{
    @Override
    public void run() {
        System.out.println(&quot;运行N品牌手机通讯录&quot;);
    }
}</code></pre><p>客户端调用代码  </p>
<pre><code>public static void main(String[] args) {
    HandsetBrand ab;
    ab = new HandsetBrandMAddressList();
    ab.run();

    ab = new HandsetBrandMGame();
    ab.run();

    ab = new HandsetBrandNAddressList();
    ab.run();

    ab = new HandsetBrandNGame();
    ab.run();
}</code></pre><p>现在我们需要在每个品牌都增加一个MP3音乐播放功能，怎么做？<br>在每个品牌下面都增加一个子类。<br>其实这两个子类差别并不大，但是由于目前程序限制，现在因为品牌不同，增加功能就必须要这样的。<br>那么现在又来一家新的手机品牌’S’，它也有游戏、通讯录、MP3音乐播放功能，又如何处理？<br>如果在增加’手机品牌S’类和三个下属功能子类。这好像有点麻烦了。<br>如果后续还需要再增加’输入法’功能、’拍照’功能，再增加’L品牌’、’X品牌’那你的类如何写？<br>你可能会想到下面这种方式：<br><img src="/blog/img/2020/02/26/手机品牌结构图2.png"><br>但实际问题还是没有得到解决，要是增加手机功能或是增加品牌都会产生很大的影响。<br>问题出在哪？<br>其实大部分人刚开始学会用面向对象的继承时，感觉它既新颖又功能强大，所以只要可以用，就都用上继承。这就好比是’有了新锤子，所有的东西看上去都成了钉子’。但事实上，很多情况用继承会带来麻烦。比如，<strong>对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须被重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性</strong>。  
在上面的继承结构中，如果不断的增加新的品牌或新功能，类会越来越多的。<br>其实在面向对象设计中，我们还有一个很重要的设计原则，那就是<strong>合成/聚合复用原则</strong>。即优先使用对象合成/聚合，而不是类继承。  </p>
<h2 id="3-合成-聚合复用原则"><a href="#3-合成-聚合复用原则" class="headerlink" title="3.合成/聚合复用原则"></a>3.合成/聚合复用原则</h2><p><strong>合成/聚合复用原则(CAPP)</strong>，尽量使用合成/聚合，尽量不要使用类继承。<br>合成(Composition，也有翻译成组合)和聚合(Aggregation)都是关联的特殊种类。<strong>聚合表示一种弱的’拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的’拥有’关旭，体现了严格的部分和整体的关系，部分和整体的生命周期一样</strong>。比方说，大雁有两个翅膀，翅膀与大雁是部分和整体的关系，并且它们的生命周期是相同的，于是大雁和翅膀是合成关系。而大雁是群居动物，所以每只大雁都是属于一个雁群，一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。<br><img src="/blog/img/2020/02/26/大雁关系图.png"><br>合成/聚合复用原则的好处是，<strong>优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物</strong>。  
就像刚才的例子，我们要学会用对象的职责，而不是结构来考虑问题。其实答案就在之前我们聊到的手机与PC电脑的差别上。<br>上面的例子中手机是不同的品牌公司，各自做自己的软件，就像我们现在设计的一样，而PC却是硬件厂商做硬件，软件厂商做软件，组合起来才是可以用的机器。<br>我们这个例子中其实是应该有个’手机品牌’抽象类和’手机软件’抽象类，让不同的品牌和功能分别继承于它们，这样要增加新的产品或新的功能都不用影响其他类了。  </p>
<p>结构图<br><img src="/blog/img/2020/02/26/手机品牌结构图3.png"><br>还有个问题，手机品牌和手机软件之间的关系呢？<br>应该是手机品牌包含有手机软件，但是软件并不是品牌的一部分，所以它们之间是聚合关系。  </p>
<p>结构图<br><img src="/blog/img/2020/02/26/手机品牌结构图4.png"><br>接下来就是代码实现了。  </p>
<h2 id="4-松耦合的程序"><a href="#4-松耦合的程序" class="headerlink" title="4.松耦合的程序"></a>4.松耦合的程序</h2><p>手机软件抽象类  </p>
<pre><code>//手机软件
public abstract class HandsetSoft {
    public abstract void run();
}  </code></pre><p>游戏、通讯录等具体类</p>
<pre><code>//手机游戏
class HandsetGame extends HandsetSoft{
    @Override
    public void run() {
        System.out.println(&quot;运行手机游戏&quot;);
    }
}
//手机通讯录
class HandsetAddressList extends HandsetSoft{
    @Override
    public void run() {
        System.out.println(&quot;运行手机通讯录&quot;);
    }
}</code></pre><p>手机品牌类  </p>
<pre><code>//手机品牌
public abstract class HandsetBrand {
    protected HandsetSoft soft;

    //设置手机软件
    public void setHandsetSoft(HandsetSoft soft){
        this.soft=soft;
    }

    //运行
    public abstract void run();
}</code></pre><p>品牌N品牌M具体类  </p>
<pre><code>//手机品牌N
class HandsetBrandN extends HandsetBrand{
    @Override
    public void run() {
        soft.run();
    }
}
//手机品牌M
class HandsetBrandM extends HandsetBrand{
    @Override
    public void run() {
        soft.run();
    }
}</code></pre><p>客户端调用代码  </p>
<pre><code>public class Client {
    public static void main(String[] args) {
        HandsetBrand ab;
        ab = new HandsetBrandN();

        ab.setHandsetSoft(new HandsetGame());
        ab.run();

        ab.setHandsetSoft(new HandsetAddressList());
        ab.run();

        ab = new HandsetBrandM();

        ab.setHandsetSoft(new HandsetGame());
        ab.run();

        ab.setHandsetSoft(new HandsetAddressList());
        ab.run();
    }
}</code></pre><p>现在代码是不感觉好多了。现在如果要增加一个功能，比如MP3音乐播放功能，那么只要增加这个类就好了。不会影响其他任何类。类的个数增加也只是一个。 </p>
<pre><code>//手机MP3播放
class HandsetMP3 extends HandsetSoft{
    @Override
    public void run() {
        System.out.println(&quot;运行手机MP3播放&quot;);
    }
} </code></pre><p>如果是增加S品牌，只需要增加一个品牌子类就可以了。个数也是一个，不会影响其他类的改动。  </p>
<pre><code>//手机品牌S
class HandsetBrandS extends HandsetBrand{
    @Override
    public void run() {
        soft.run();
    }
}</code></pre><p>这显然也符合了我们之前的一个设计原则——<strong>开放-封闭原则</strong>。  
所以说盲目的使用继承当然会造成麻烦，其本质原因是：继承是一种强耦合的结构。父类变，子类就必须要变。所以我们在用继承时，一定要在是’is-a’的关系时在考虑使用，而不是任何时候去使用。<br>之所以要讲这个例子，是为了引申到一个设计原则——桥接模式，刚才的那个结构图中，两个抽象类之间是不是有一条线，就像一座桥。  </p>
<h2 id="5-桥接模式"><a href="#5-桥接模式" class="headerlink" title="5.桥接模式"></a>5.桥接模式</h2><p><strong>桥接模式(Bridge)</strong>，将抽象部分与它的实现部分分离，使它们都可以独立的变化。<br><strong>什么叫抽象与它的实例分离，这并不是说，让抽象类与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象</strong>。就刚才的例子而言，就像是让’手机’既可以是按照品牌来分类，也可以按照功能来分类。  </p>
<p>按品牌分类实现结构图<br><img src="/blog/img/2020/02/26/手机品牌结构图1.png">   </p>
<p>按软件分类实现结构图<br><img src="/blog/img/2020/02/26/手机品牌结构图2.png"> </p>
<p>由于实现的方式有多种，桥接模式的核心意图就是把这些实现独立出来，让它们各自的变化。这就使得每种实现的变化不会影响其他实现，从而达到应对变化的目的。<br><img src="/blog/img/2020/02/26/手机品牌结构图4.png">   </p>
<h2 id="6-桥接模式基本代码"><a href="#6-桥接模式基本代码" class="headerlink" title="6.桥接模式基本代码"></a>6.桥接模式基本代码</h2><img src="/blog/img/2020/02/26/桥接模式结构图.png">

<p>Implementor类  </p>
<pre><code>public abstract class Implementor {
    public abstract void operation();
}</code></pre><p>ConcreteImplementorA和ConcreteImplementorB等派生类  </p>
<pre><code>class ConcreteImplementorA extends Implementor{
    @Override
    public void operation() {
        System.out.println(&quot;具体实现A的方法执行&quot;);
    }
} 
class ConcreteImplementorB extends Implementor{
    @Override
    public void operation() {
        System.out.println(&quot;具体实现B的方法执行&quot;);
    }
} </code></pre><p>Abstraction类  </p>
<pre><code>public class Abstraction {
    protected Implementor implementor;

    public void setImplementor(Implementor implementor){
        this.implementor=implementor;
    }

    public void operation(){
        implementor.operation();
    }
}</code></pre><p>RefinedAbstraction类  </p>
<pre><code>class RefinedAbstraction extends Abstraction{
    @Override
    public void operation() {
        super.operation();
    }
}</code></pre><p>客户端实现  </p>
<pre><code>public class Client {
    public static void main(String[] args) {
        Abstraction ab = new RefinedAbstraction();

        ab.setImplementor(new ConcreteImplementorA());
        ab.operation();

        ab.setImplementor(new ConcreteImplementorB());
        ab.operation();
    }
}</code></pre><p>PS:桥接模式所说的’将抽象与它的实现部分分离’，不太好理解，我们可以这么理解就是<strong>实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让他们独立变化，减少它们之间的耦合</strong>。 </p>
<h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7.其他"></a>7.其他</h2><p><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。<br><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。<br><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。<br><strong>关键代码：</strong>抽象类依赖实现类。<br><strong>应用实例：</strong>1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。<br><strong>优点：</strong>1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。<br><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。<br><strong>使用场景：</strong>1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。<br><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。  </p>
<h2 id="8-参考文章"><a href="#8-参考文章" class="headerlink" title="8.参考文章"></a>8.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/bridge-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/bridge-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/blog/2020/02/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>迭代器模式(Iterator Pattern)是Java和.Net编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。<br>迭代器模式属于行为型模式。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。<br><strong>主要解决：</strong>不同的方式来遍历整个聚合对象。<br><strong>何时使用：</strong>遍历一个聚合对象。<br><strong>如何解决：</strong>把元素之间游走的责任交给迭代器，而不是聚合对象。<br><strong>关键代码：</strong>定义接口：hasNext，next。<br><strong>应用实例：</strong>JAVA中的iterator。<br><strong>优点：</strong>1、他支持以不同的方式来遍历一个聚合对象。2、迭代器简化了聚合类。3、在同一个聚合上可以有多个遍历。4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。<br><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这个在一定程度上增加了系统的复杂性。<br><strong>使用场景：</strong>1、访问一个聚合对象的内容而无须暴露它的内部表示。2、需要为聚合对象提供多种遍历方式。3、为遍历不同的聚合结构提供一个统一的接口。<br><strong>注意事项：</strong>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/02/26/迭代器模式UML类图.png"> 

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>Iterator迭代器抽象类  </p>
<pre><code>public abstract class Iterator {
    //用于定义得到开始对象        
    public abstract Object first();
    //得到下一个对象
    public abstract Object next();
    //判断是否到结尾，也就是判断是否还有下一个元素
    public abstract boolean isDone();//hasNext
    //得到当前对象
    public abstract Object currentItem();
} </code></pre><p>Aggregate聚集抽象类  </p>
<pre><code>public abstract class Aggregate {
    //创建迭代器
    public abstract Iterator createIterator();
}</code></pre><p>ConcreteIterator具体迭代器类，继承Iterator  </p>
<pre><code>public class ConcreteIterator extends Iterator{
    //定义了一个具体聚集对象
    private ConcreteAggregate aggregate;
    private int current = 0;

    //初始化时将具体的聚集对象传入
    public ConcreteIterator(ConcreteAggregate aggregate){
        this.aggregate=aggregate;
    }

    //得到聚集的第一个对象
    @Override
    public Object first() {
        return aggregate.getItems().get(0);
    }

    //得到聚集的下一个对象
    @Override
    public Object next() {
        Object ret = null;
        current++;
        if(current &lt; aggregate.count()){
            ret = aggregate.getItems().get(current);
        }
        return ret;
    }

    //判断当前是否遍历到结尾，到结尾返回true
    @Override
    public boolean isDone() {
        return current&gt;=aggregate.count()?true:false;
    }

    //返回当前的聚集对象
    @Override
    public Object currentItem() {
        return aggregate.getItems().get(current);
    }
}</code></pre><p>ConcreteAggregate具体聚集类 继承Aggregate  </p>
<pre><code>public class ConcreteAggregate extends Aggregate{

    //声明一个List泛型变量，用于存放聚合对象
    private List&lt;Object&gt; items = new ArrayList&lt;&gt;();

    @Override
    public Iterator createIterator() {
        return new ConcreteIterator(this);
    }

    //返回聚集总个数
    public int count(){
        return items.size();
    }

    public List&lt;Object&gt; getItems() {
        return items;
    }

    public void insert(Object o) {
        this.items.add(o);
    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        ConcreteAggregate aggregate = new ConcreteAggregate();
        aggregate.insert(&quot;大鸟&quot;);
        aggregate.insert(&quot;小菜&quot;);
        aggregate.insert(&quot;行李&quot;);
        aggregate.insert(&quot;老外&quot;);        
        aggregate.insert(&quot;公交内部员工&quot;);
        aggregate.insert(&quot;小偷&quot;);
        ConcreteIterator iterator = new ConcreteIterator(aggregate);
        Object item = iterator.first();
        //从第一个乘客开始
        while(!iterator.isDone()){
            //对面前的乘客告知买票
            System.out.println(iterator.currentItem()+&quot; 请买车票!&quot;);
            //下一乘客
            iterator.next();
        }
    }
}</code></pre><p>运行结果  </p>
<pre><code>大鸟 请买车票!
小菜 请买车票!
行李 请买车票!
老外 请买车票!
公交内部员工 请买车票!
小偷 请买车票!</code></pre><p><strong>为什么要用具体的迭代器ConcreteIterator来实现抽象的Iterator呢？而不直接访问ConcreteIterator呢？</strong><br>这里体现了一个迭代器的好处，就是<strong>当你需要对聚集有多种方式遍历时，可以考虑用迭代器模式</strong>，事实上我们不一定要从前向后遍历，也可以从后向前遍历等等，这个时候我们只需要在写一个具体的迭代器类实现抽象的Iterator，再对其部分操作进行修改就行了。  </p>
<h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/iterator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/iterator-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>排序算法之基数排序</title>
    <url>/blog/2020/02/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>基数排序（radix sort）属于”分配式排序”（distribution sort），又称”桶子法”（bucket sort或bin sort），顾名思义，它是透过键值的部分资讯，将要排序的元素分配至某些”桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。  </p>
<a id="more"></a>  
<p><strong>基本解法</strong><br>以LSD为例，假设原来有一串数值如下所示：<br>73, 22, 93, 43, 55, 14, 28, 65, 39, 81<br>第1步：首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：<br><img src="/blog/img/2020/02/24/基数排序1.png"><br><br>第2步：接下来讲这些桶子中的数值重新串接起来，称为以下的数列：<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39<br>接下来在进行分配一次，这次是根据十位数来分配：<br><img src="/blog/img/2020/02/24/基数排序2.png"><br><br>第3步：接下来讲这些桶子中的数值重新串起来，成为一下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至到最高位为止。<br>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式正好与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并到一个数组中，而是在每个”桶子”中建立”子桶”，将每个桶子中的数值按照下一位的值分配到”子桶”中。在进行完最低位数的分配后在合并回单一的数组中。<br><strong>效率分析</strong><br>时间效率：设待排序列为n个记录，d个关键码(也就是最高位数)，关键码的取值范围为radix(可以指桶子数，0~9，一般就是10)，则进行链式基数排序的时间复杂度为O(d(n+radix))，其中，一趟分配时间复杂度为O(n)，一趟收集时间复杂度为O(radix)，共进行d趟分配和收集。<br>空间效率：需要2<em>radix个指向队列的辅助空间，以及用于静态链表的n个指针。<br>*</em>实现方法**  
最高位优先(Most Significant Digit first)法，简称MSD法：先按k1排序分组，同一组中记录，关键码k1相等，再对各组按k2排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有序序列。<br>最低位优先(Least Significant Digit first)法，简称LSD法：先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。    、</p>
<p><strong>LSD代码实现</strong>  </p>
<pre><code>public class RadixSort {

    public static void sort(int[] arr){
        //获取最高位数,也就是需要进行多少轮的收集排序
        int d = getMaxDigit(arr);
        //控制键值排序依据在哪一位
        int k = 1;
        int n = 1;
        int m = 0;
        //初始化桶子,数组的第一维表示可能的余数0-9
        int[][] tmp = new int[10][arr.length];
        //数组order[i]用来表示该位是i的数的个数
        int[] order = new int[10];
        while(k&lt;=d){
            for (int i = 0; i &lt; arr.length; i++) {
                int lsd = (arr[i]/n)%10;
                tmp[lsd][order[lsd]] = arr[i];
                order[lsd]++;
            }
            for (int i = 0; i &lt; 10; i++) {
                if(order[i]!=0){
                    for (int j = 0; j &lt; order[i]; j++) {
                        arr[m++] = tmp[i][j];
                    }
                    order[i]=0;
                }
            }
            m = 0;
            k++;
            n *=10;
        }
    }

    //获取最高位数
    public static int getMaxDigit(int[] arr){
        int max = arr[0];
        for (int i = 0; i &lt; arr.length; i++) {
            max = Math.max(max, arr[i]);
        }
        int d = 1;
        while(max/10&gt;0){
            d++;
            max/=10;
        }
        return d;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{73, 22, 93, 43, 55, 14, 28, 65, 39, 81};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}</code></pre><p><strong>MSD法</strong><br>以序列：15 ,  225,  105,  378,  334,   921,  32,  31为例，从最高位百位依次入桶，只有105有百位，其他百位按0算；检测每个桶中的数据。当桶中的元素个数多于1个的时候，要对这个桶递归进行下一位的分组。<br><img src="/blog/img/2020/02/25/基数排序MSD法图解.png"><br>  </p>
<p><strong>代码示例（略复杂）</strong>  </p>
<pre><code>/**
 * MSD法
 * @param arr 原始数组
 * @param m   原始数组需要被覆盖的起始位置(下标)
 * @param d   控制键值排序依据在哪一位
 * @param newArr 子序列
 * @return    原始数组被覆盖后的结束位置(下标)
 */
public static int msdSort(int[] arr,int m,int d,int[] newArr){
    if(d == 0){//一般来说当d=1时，也就是排序依据在个位时，就已经有序了，当出现了d=0的情况时，说明出现了重复数据
        for (int i = 0; i &lt; newArr.length; i++) {
            arr[m++] = newArr[0];
        }
        return m;
    }
    //获取数组中最长元素长度
    int k = new Double(Math.pow(10, d - 1)).intValue();
    //初始化桶子,数组的第一维表示可能的余数0-9
    int[][] tmp = new int[10][newArr.length];
    //数组order[i]用来表示该位是i的数的个数
    int[] order = new int[10];
    for (int i = 0; i &lt; newArr.length; i++) {
        int msd = (newArr[i]/k)%10;
        tmp[msd][order[msd]]=newArr[i];
        order[msd]++;
    }
    for (int i = 0; i &lt; 10; i++) {
        if(order[i]==1){
            arr[m++] = tmp[i][0];
        }else if(order[i]&gt;1){
            int[] arr2 = new int[order[i]];
            for (int j = 0; j &lt; order[i]; j++) {
                arr2[j] = tmp[i][j];
            }
            //进行递归操作，d-1的意思是告诉方法下一次要进行比较的位置
            m = msdSort(arr,m,d-1,arr2);
        }
    }
    return m;
}

//获取最高位数
public static int getMaxDigit(int[] arr){
    int max = arr[0];
    for (int i = 0; i &lt; arr.length; i++) {
        max = Math.max(max, arr[i]);
    }
    int d = 1;
    while(max/10&gt;0){
        d++;
        max/=10;
    }
    return d;
}

public static void main(String[] args) {
    int[] arr = new int[]{15,225,105,378,334,921,32,31};
    msdSort(arr,0,getMaxDigit(arr),arr);
    System.out.println(Arrays.toString(arr));
    arr = new int[]{15,225,105,378,334,921,32,15};
    msdSort(arr,0,getMaxDigit(arr),arr);
    System.out.println(Arrays.toString(arr));
}</code></pre><p>输出结果  </p>
<pre><code>[15, 31, 32, 105, 225, 334, 378, 921]
[15, 15, 32, 105, 225, 334, 378, 921]</code></pre>]]></content>
  </entry>
  <entry>
    <title>排序算法之桶排序</title>
    <url>/blog/2020/02/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>桶排序同样是一种线性时间的排序算法。类似于计数排序所创建的统计数组，桶排序需要创建若干个桶来协助排序。  </p>
<a id="more"></a>  
<p>桶排序中所谓的”桶”是什么？<br>每一个桶(bucket)代表一个区间范围，里面可承载一个或多个元素（其实可以把计数排序当做桶排序的一种特殊情况，把计数排序当成每个桶里只有一个元素的情况）。<br>假设有一个非整数数列如下：<br>4.5，0.84，3.25，2.18，0.5<br>让我们看看桶排序的工作原理。<br>桶排序的第1步，就是创建这些桶，并确定每一个桶的区间范围。<br><img src="/blog/img/2020/02/24/桶排序1.png"><br><br>具体需要建立多少个桶，如何确定桶的区间范围，有很多种不同的方式。我们这里创建的桶数量等于原始数列的原始数量，除最后一个桶只包含数列最大值外，前面各个桶的区间按照比例来确定。<br>&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;区间跨度 = （最大值-最小值）/（桶数量 - 1）<br>第2步，遍历原始数列，把元素对号入座放入各个桶中。<br><img src="/blog/img/2020/02/24/桶排序2.png"><br><br>第3步，对每个桶内部的元素分别进行排序（显然，只有第1个桶需要排序）。<br><img src="/blog/img/2020/02/24/桶排序3.png"><br><br>第4步，遍历所有的桶，输出所有元素。<br>0.5，0.84，2.18，3.15，4.5<br>到此为止，排序结束。  </p>
<p><strong>代码实现</strong>  </p>
<pre><code>public class BucketSort {

    public static double[] sort(double[] arr){
        //1.确定最大值最小值,并算出差值
        double min = arr[0];
        double max = arr[0];
        for (int i = 1; i &lt; arr.length; i++) {
            min = Math.min(min, arr[i]);
            max = Math.max(max, arr[i]);
        }
        double d = max-min;
        //2.初始化桶
        int bucketNum = arr.length;
        ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = new ArrayList&lt;&gt;(bucketNum);
        //这里得注意一下，bucketNum ≠ bucketList.size()，
        //在没有add数据之前bucketList.size()=0，因为new ArrayList&lt;&gt;(bucketNum)只是初始化该集合的初始容量是多大，
        //但实际上里面还没有存放数据，所以size=0
        //只有当add(1)时，size=1；所以不能使用条件i&lt;bucketList.size()
        for (int i = 0; i &lt; bucketNum; i++) {
            bucketList.add(new LinkedList&lt;Double&gt;());
        }
        //3.遍历原始数组，将每个元素放入桶中 （其中区间跨度 k= d/(bucketNum-1) 所属区间s = arr[i]/k）
        for (int i = 0; i &lt; arr.length; i++) {
            int num = (int)((arr[i]-min)*(bucketNum-1)/d);
            bucketList.get(num).add(arr[i]);
        }
        //4.对每个桶内部进行排序
        for (int i = 0; i &lt; bucketList.size(); i++) {
            //JDK底层采用了归并排序或归并排序的优化版
            Collections.sort(bucketList.get(i));
        }
        //5.输出全部元素
        double[] sortedArray = new double[arr.length];
        int index = 0;
        for (LinkedList&lt;Double&gt; list : bucketList) {
            for (Double element : list) {
                sortedArray[index++] = element;
            }
        }
        return sortedArray;
    }

    public static void main(String[] args) {
        double[] arr = new double[]{4.5,0.84,3.25,2.18,0.5};
        arr = sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}</code></pre><p>在上述代码中，所有的桶都保存在ArrayList集合中，每一个桶都被定义成一个链表(LinkedList<double>)，这样便于在尾部插入元素，不会打乱相同数字的前后顺序，然后采用jdk的集合工具类Collections.sort来对桶内部的元素进行排序，Collections.sort底层采用的是归并排序或Timesort，可以把他当做成一种时间复杂度为O(nlogn)的排序，而<strong>归并是一种稳定的排序方法</strong>。所以说桶排序也属于<strong>稳定排序</strong>。  </double></p>
<p><strong>桶排序的时间复杂度</strong><br>假设原始数列有n个元素，分为n个桶。<br>下面逐步来分析一下算法复杂度。<br>第1步，求数列最大、最小值，运算量为n。<br>第2步，创建桶空间，运算量为n。<br>第3步，把原始数列的元素分配到各个桶中，运算量为n。<br>第4步，在每个桶内部做排序，在元素分布相对均匀的情况下，所有桶的运算量之和为n。<br>第5步，输出排序序列，运算量为n。<br>因此，桶排序的总体时间复杂度为O(n)。<br>至于空间复杂度就很容易得到了，同样是O(n)。  </p>
<p>桶排序的性能并非绝对稳定。如果元素分布极不均衡，在极端的情况下，第一个桶中有n-1个元素，最后一个桶中有1个元素。此时的时间复杂度将退化为O(nlogn)，而且还白白创建了许多空桶。<br><img src="/blog/img/2020/02/24/桶排序4.png"><br><br>所有说，并没有绝对好的算法，也没有绝对不好的算法，关键是要看具体的场景。  </p>
]]></content>
  </entry>
  <entry>
    <title>排序算法之计数排序</title>
    <url>/blog/2020/02/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>无论是冒泡排序还是快速排序，都是基于<strong>元素之间的比较</strong>来进行排序的。但是有一些特殊的排序并不基于元素比较，如<strong>计数排序、桶排序、基数排序。</strong><br>这里我们要讲的就是计数排序，以计数排序来说，这种排序算法是利用数组下标来确定元素的正确位置的。  </p>
<a id="more"></a>  
<p>假设数组中有20个随机整数，取值范围为0~10，要求用最快的速度把这20个整数从小到大进行排序。<br>考虑到只能从0、1、2、3、4、5、6、7、8、9、10这11个数中取值，取值范围有限。所以，可以根据有限的范围，建立一个长度为11的数组，数组下标从0到10，元素初始值全为0。<br><img src="/blog/img/2020/02/22/计数排序1.png"><br><br>假设这20个随机整数的值如下所示。<br>9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9，7，9<br>下面就开始遍历这个无序的随机序列，每一个整数按照基本其值对号入座，同时，对应数组下标整数是9，那么数组下标为9的元素加1。<br>例如第一个整数是9，那么对应的数组下标为9的元素加1。<br><img src="/blog/img/2020/02/22/计数排序2.png"><br><br>第2个整数是3，那么数组下标为3的元素加1。<br><img src="/blog/img/2020/02/22/计数排序3.png"><br><br>继续遍历数列并修改数组…..<br>最终，当数列遍历完毕时，数组的状态如下。<br><img src="/blog/img/2020/02/22/计数排序4.png"><br><br>该数组每一个下标位置的值代表数列中对应整数出现的次数。<br>有了这个统计结果，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次。<br>0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10<br>显然，现在输出的数列已经有序的了。  </p>
<p><strong>实现代码</strong>  </p>
<pre><code>public class CountSort {

    public static int[] sort(int[] arr){
        //1.得到数组的最大值
        int max = arr[0];
        for (int i = 0; i &lt; arr.length; i++) {
            if(max&lt;arr[i]){
                max = arr[i];
            }
        }
        //2.根据最大值确定统计数组的长度
        int[] tmp = new int[max+1];
        //3.遍历数列，填充统计数组
        for (int i = 0; i &lt; arr.length; i++) {
            tmp[arr[i]]++;
        }
        //4.遍历统计数组，输出结果
        arr = new int[arr.length];
        int index = 0;
        for (int i = 0; i &lt; tmp.length; i++) {
            for (int j = 0; j &lt; tmp[i]; j++) {
                arr[index++] = i;
            }
        }
        return arr;
    }

    public static void main(String[] args) {
        int[] arr=new int[]{9,3,5,4,9,1,2,7,8,1,3,6,5,3,4,0,10,9,7,9};
        arr = sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}</code></pre><p>这段代码在开头有一个步骤，就是求数列的最大整数max。后面创建的统计数组tmp，长度是max+1，以此来保证数组的最后一个下标是max。  </p>
<p><strong>计数排序优化</strong><br>上面的例子中我们以数列中的最大值来决定统计数组的长度，其实并不严谨。例如下面的数列。<br>95，94，91，98，99，90，99，93，91，92<br>这个数列的最大值是99，最小值是90，如果创建长度为100的数组，那么前面从0到89的空间位置就都浪费了！<br>这个时候就不再是以<strong>输入数列的最大值+1</strong>作为统计数组的长度，而是以<strong>数列最大值-数列最小值+1</strong>作为统计数组的长度。同时，数列的最小值作为一个偏移量，用于统计数组中的下标。<br>以刚才的数列为例，统计数组的长度为99-90+1=10，偏移量等于数列的最小值90。<br>对于第1个整数95，对应的统计数组下标是95-90=5，如图所示。<br><img src="/blog/img/2020/02/22/计数排序5.png"><br><br><strong>代码示例</strong>  </p>
<pre><code>public static int[] sort(int[] arr){
    //1.得到数组的最大值和最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 0; i &lt; arr.length; i++) {
        if(max&lt;arr[i]){
            max = arr[i];
        }
        if(min&gt;arr[i]){
            min = arr[i];
        }
    }
    //2.根据最大值确定统计数组的长度
    int[] tmp = new int[max-min+1];
    //3.遍历数列，填充统计数组
    for (int i = 0; i &lt; arr.length; i++) {
        tmp[arr[i]-min]++;
    }
    //4.遍历统计数组，输出结果
    arr = new int[arr.length];
    int index = 0;
    for (int i = 0; i &lt; tmp.length; i++) {
        for (int j = 0; j &lt; tmp[i]; j++) {
            arr[index++] = min+i;
        }
    }
    return arr;
}</code></pre><p><strong>计数排序再优化</strong><br>是的，上面的例子确实对计数排序进行了优化。此外，朴素版的计数排序只是简单的按照数组的下标输出元素值，并没有真正给原始数列进行排序。<br>如果只是单纯的给整数排序，这样做并没有问题。但如果在现实业务里，例如给学生的考试分数进行排序，遇到相同的分数就会分不清谁是谁。<br>什么意思？看下面这个例子。<br><img src="/blog/img/2020/02/22/分数.png"><br><br>给出一个学生表，要求按成绩从高到低进行排序，如果成绩相同，则遵循表固有顺序。<br>那么，当我们填充统计数组以后，只知道有两个成绩并列为95分的同学，却不知道哪一个是小红，哪一个是小绿。<br><img src="/blog/img/2020/02/22/分数2.png"><br><br>怎么办？<br>仍然以刚才的学生成绩表为例，将之前的统计数组变形成下面的样子。<br><img src="/blog/img/2020/02/22/分数3.png"><br><br>这样加的目的，是让统计数组存储元素的元素值，等于相应整数的最终排序位置的序号。例如下标是9的元素值为5，代表原始数列的整数9，最终的排序在第5位。<br>接下来，创建输出数组sortedArray，长度和输入数列一致。然后从后向前遍历输入数列。<br>第1步，遍历成绩表最后一行的小绿同学的成绩。<br>小绿的成绩是95分，找到sortedArray下标是5的元素，值是4，代表小绿的成绩排名位置在第4位。<br>同时，给countArray下标是5的元素值减1，从4变成3，代表下次再遇到95分的成绩时，最终排名是第3。<br><img src="/blog/img/2020/02/22/分数4.png"><br><br>第2步，遍历成绩表倒数第2行的小白同学的成绩。<br>小白的成绩是94分，找到sortedArray下标是4的元素，值是2，代表小绿的成绩排名位置在第2位。<br>同时，给countArray下标是4的元素值减1，从2变成1，代表下次再遇到94分的成绩时(实际上已经遇不到了)，最终排名是第1。<br><img src="/blog/img/2020/02/22/分数5.png"><br><br>第3步，遍历成绩表倒数第3行的小红同学的成绩。<br>小白的成绩是95分，找到sortedArray下标是5的元素，值是3，代表小红的成绩排名位置在第3位(最初是4，减1变成了3)，代表小红的成绩排名位置在第3位。<br>同时，给countArray下标是5的元素值减1，从3变成2，代表下次再遇到95分的成绩时(实际上已经遇不到了)，最终排名是第2。<br><img src="/blog/img/2020/02/22/分数6.png"><br><br>这样一来，同样是95分的小红和小绿就能够清楚地排出顺序了，也正因为此，优化版本的计数排序属于<strong>稳定排序</strong>。  
后面的推理过程以此类推。<br><strong>代码示例</strong>  </p>
<pre><code>public static int[] sort(int[] arr){
    //1.得到数组的最大值和最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 0; i &lt; arr.length; i++) {
        if(max&lt;arr[i]){
            max = arr[i];
        }
        if(min&gt;arr[i]){
            min = arr[i];
        }
    }
    //2.创建统计数组并统计对应元素的个数
    int[] countArray = new int[max-min+1];
    for (int i = 0; i &lt; arr.length; i++) {
        countArray[arr[i]-min]++;
    }
    //3.统计数组变形
    for (int i = 0; i &lt; countArray.length-1; i++) {
        countArray[i+1] = countArray[i+1]+countArray[i];
    }
    //4.倒序遍历原始数组，从统计数组找到正确的位置，输出到结果数组
    int[] srotedArray = new int[arr.length];
    for (int i = arr.length-1; i &gt;=0; i--) {
        srotedArray[countArray[arr[i]-min]-1] = arr[i];
        countArray[arr[i]-min]--;
    }
    return srotedArray;
}</code></pre><p>代码第1、2、4步都涉及遍历原始数列，运算量都是n，第3步遍历统计数组，运算量是m，所以总体运算量是3n+m，去掉系数，时间复杂度是O（n+m）。<br>至于空间复杂度，如果不考虑结果数组，只考虑统计数组大小的话，空间复杂度是O(m)。  </p>
<p>虽然统计数组很强大，但是有局限性。<br><strong>1.当数列最大值和最小值差距过大时，并不适合计数排序。</strong><br>例如给你20个随机整数，范围在0到1亿之间。<br><strong>2.当数列元素不是整数时，也不适合用计数排序。</strong><br>例如25.213或0.000001这样的数字，无法创建对应的统计数组。<br>对于折现局限性，另一种线性时间排序算法做出了弥补，这种排序算法叫做<strong><a href="/blog/2020/02/22/排序算法之桶排序/" target="_blank">桶排序</a></strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>为什么建堆的时间复杂度是O(n)?</title>
    <url>/blog/2020/02/22/%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<p>我们通过画图来理解，来推算建堆的时间复杂度。  </p>
<a id="more"></a>  
<p>构件二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质就是让所有非叶子节点依次“下沉”。详情见<a href="/blog/2020/01/03/二叉堆/" target="_blank">二叉堆</a>中的构建二叉堆小节，这里就不做过多讲述了。  </p>
<p>现如下有一颗深度为4的树:<br><img src="/blog/img/2020/02/22/二叉堆.png"><br>  </p>
<p>我们首先从最后一个非叶子节点开始作比较，也就是倒数第二层最右边的节点开始。这一层的节点都要执行子节点的比较然后交换(如果顺序是对的就不用交换了)。倒数第三层呢？则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换等等。我们现在来推导一下比较次数：  </p>
<p>倒数第2层(也就是第3层)：有2<sup>(3-1)=2</sup>=4个节点(其中3表示当前层数)，需要比较2<sup>(3-1)=2</sup>x(4-3)=4(该节点下的子树深度=树高-当前层数)次。<br>倒数第3层(也就是第2层)：有2<sup>(2-1)=1</sup>=2个节点，需要比较2<sup>(2-1)=1</sup>x(4-2)=4次。<br>倒数第4层(也就是第1层)：有2<sup>(1-1)=0</sup>=1个节点，需要比较2<sup>(1-1)=0</sup>x(4-1)=3次。  </p>
<p>那么现在假设树高h，i表示当前层数，那么每一层的时间计算为S=2<sup>(i-1)</sup>x(h-i)。2<sup>(i-1)</sup> 表示该层上有多少个元素(跟堆的重建过程不一样的是，这里对每一层的元素都要进行交换的操作。但是对于堆的重建，只需要选择一个分支进行比较)，( h - i) 表示子树上要比较的次数，如果在最差的条件下，就是比较次数后还要交换；因为这个是常数，所以提出来后可以忽略。<br>所以：<br>S = 2<sup>(h-2)</sup>x1 + 2<sup>(h-3)</sup>x2+…..+2<sup>0</sup>x(h-1) ① ===&gt; （因为叶子层不用交换，所以i从 h-1 开始到 1；（h-2）怎么来的？因为最后一个非叶子节点在h-1层，而h-1层的节点个数为2<sup>(h-1-1)</sup>）  
通过观察公式可知，该求和公式为等差数列和等比数列的乘积，因此用错位想减发求解，给公式左右两侧同时乘以2，可知：<br>2S =  2<sup>(h-1)</sup>x1 + 2<sup>(h-2)</sup>x2+…..+2<sup>1</sup>x(h-1)②<br>②式-①式得：<br>S = 2<sup>(h-1)</sup> + 2<sup>(h-2)</sup> + 2^<sup>(h-3)</sup> ….. + 2 - (h-1)<br>除最后一项外，就是一个等比数列了，直接用求和公式：<br><img src="/blog/img/2020/02/21/等比数列求和.jpg"><br><br>得到结果：<br>S = 2<sup>h</sup>-2-（h-1）=  2<sup>h</sup>-h-1；因为具有n个元素的平衡二叉树，树高为㏒n，所以把h=logn带入式子中可以得出结果：<br>S = n - logn -1，所以时间复杂度为：O(n)（堆的初始化过程）  </p>
]]></content>
  </entry>
  <entry>
    <title>排序算法之堆排序</title>
    <url>/blog/2020/02/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>&#8195;&#8195;堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。  </p>
<a id="more"></a>  
<p>&#8195;&#8195;在前面的数据结构中，我们讲过<a href="/blog/2020/01/03/二叉堆/" target="_blank">二叉堆</a>的特性。<br>&#8195;&#8195;<strong>1.最大堆的堆顶是整个堆中的最大元素。</strong><br>&#8195;&#8195;<strong>2.最小堆的堆顶是整个堆中的最小元素。</strong>  </p>
<p>&#8195;&#8195;以最大堆为例，例如删除一个最大堆的堆顶(并不是完全删除，而是根据末尾的节点交换位置)，经过自我调整，第2大的元素就会被交换上来，称为最大堆的新堆顶。<br><img src="/blog/img/2020/02/21/堆排序1.png"><br><br>&#8195;&#8195;正如上图所示，当我们删除值为10的堆顶节点，经过调节，值为9的新节点就会顶替上来；当我们删除值为9的堆顶节点，经过调节，值为8的新节点就会顶替上来…….<br>&#8195;&#8195;由于二叉堆的这个特性，我们每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么我们只要反复删除堆顶，反复调节二叉堆，所得到的集合就成为了一个有序集合，过程如下：<br>&#8195;&#8195;删除节点9，节点8成为新堆顶：<br><img src="/blog/img/2020/02/21/堆排序2.png"><br><br>&#8195;&#8195;删除节点8，节点7成为新堆顶：<br><img src="/blog/img/2020/02/21/堆排序3.png"><br><br>&#8195;&#8195;删除节点7，节点6成为新堆顶：<br><img src="/blog/img/2020/02/21/堆排序4.png"><br><br>&#8195;&#8195;<strong>中间步骤略…..</strong><br>&#8195;&#8195;最后删除节点3，节点2成为新堆顶：<br><img src="/blog/img/2020/02/21/堆排序5.png"><br></p>
<p>&#8195;&#8195;到此为止，我们原本的最大堆已经变成了一个从小到大的有序集合。之前说过二叉堆实际存储在数组当中，数组中的元素排列如下：<br><img src="/blog/img/2020/02/21/堆排序6.png"><br></p>
<p>&#8195;&#8195;由此，可以归纳出堆排序的排序算法。<br>&#8195;&#8195;<strong>1.把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。</strong><br>&#8195;&#8195;<strong>2.循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。</strong>  </p>
<p>&#8195;&#8195;<strong>那么有人会疑惑为什么不使用小堆排升序呢？</strong><br>&#8195;&#8195;我们再想想：首先使用堆排序主要是用堆顶元素，如果使用小堆排升序，此时堆顶的元素是最小的，当我们取出堆顶元素时，此时小根堆的性质就变了，那么下次就找不到第二小的元素了，还要重新建堆。所以不能使用小堆排升序。有兴趣的可以自己来画图走一走。  </p>
<p>&#8195;&#8195;<strong>堆排序代码实现</strong>  </p>
<pre><code>public class HeapSort {

    public static void sort(int[] arr){
        //1.构建最大堆
        for (int i = (arr.length-2)/2; i&gt;=0 ; i--) {
            downAdjust(arr,i,arr.length);
        }
        System.out.println(Arrays.toString(arr));
        //2.循环删除堆顶元素，移到尾部集合，调整产生新的堆顶
        for (int i = arr.length-1; i &gt;0; i--) {
            int top = arr[0];
            arr[0] = arr[i];
            arr[i] = top;
            //下沉调整最大堆
            downAdjust(arr,0,i);
        }


    }

    /**
     * 下沉节点 （构建最大堆）
     * @param arr 待调整的堆
     * @param parentIndex 要&quot;下沉&quot;的父节点
     * @param length 堆的有效长度
     */
    public static void downAdjust(int[] arr,int parentIndex,int length){
        int childrenIndex = 2*parentIndex+1;
        int tmp = arr[parentIndex];
        while(childrenIndex&lt;length){
            if(childrenIndex+1&lt;length &amp;&amp; arr[childrenIndex]&lt;arr[childrenIndex+1]){
                childrenIndex = childrenIndex+1;
            }
            if(tmp&gt;arr[childrenIndex]){
                break;
            }
            arr[parentIndex] = arr[childrenIndex];
            parentIndex = childrenIndex;
            childrenIndex = 2*parentIndex+1;
        }
        arr[parentIndex] = tmp;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{1,3,2,6,5,7,8,9,10,0};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}</code></pre><p>&#8195;&#8195;<strong>时间复杂度</strong><br>&#8195;&#8195;二叉堆的节点下沉调整（downAdjust方法）是堆排序算法的基础，这个调节操作的时间复杂度是O(logn)。<br>&#8195;&#8195;再来回顾一下堆排序的算法步骤：<br>&#8195;&#8195;1.把无序数组构成二叉堆。这一步的的时间复杂度是<strong>O(n)。（<a href="/blog/2020/02/22/建堆的时间复杂度/" target="_blank">为什么建堆的时间复杂度是O(n)?</a>）</strong><br>&#8195;&#8195;2.循环删除堆顶元素，并将该元素移动到集合尾部，调整堆产生新的堆顶。这一步需要进行n-1次循环，每次循环调用一次downAdjust方法，所以第2步的计算规模是（n-1）x logn，时间复杂度为<strong>O(nlogn)。</strong><br>&#8195;&#8195;两个步骤是并列的关系，所以整体时间复杂度是<strong>O(nlogn)。</strong>  </p>
<p>&#8195;&#8195;<strong>与快速排序相比有什么区别和联系？</strong><br>&#8195;&#8195;首先相同点是，快速排序和堆排序的平均时间复杂度都是O(nlogn)，并且都是不稳定排序。至于不同点，快速排序的最坏时间复杂度是O(n²)，而堆排序的最坏时间复杂度是稳定在O(nlogn)。<br>&#8195;&#8195;快速排序的递归和非递归方法的平均空间复杂度都是O(logn),而堆排序的空间复杂度是O(1)。  </p>
]]></content>
  </entry>
  <entry>
    <title>排序算法之归并排序</title>
    <url>/blog/2020/02/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>&#8195;&#8195;归并排序(Merge sort)是建立在归并操作上的一种有效的排序算法，该算法是采用分治算法(Divide and Conquer)的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合成一个有序表，称为二路归并。<strong>归并是一种稳定的排序方法</strong>。  </p>
<a id="more"></a>  
<p>&#8195;&#8195;<strong>归并操作(meger)</strong>，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。<br>&#8195;&#8195;如　设有数列{6，202，100，301，38，8，1}<br>&#8195;&#8195;初始状态：6,202,100,301,38,8,1<br>&#8195;&#8195;第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；<br>&#8195;&#8195;第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；<br>&#8195;&#8195;第三次归并后：{1,6,8,38,100,202,301},比较次数：4；<br>&#8195;&#8195;总的比较次数为：3+4+4=11；<br>&#8195;&#8195;逆序数为14；  </p>
<p>&#8195;&#8195;<strong>1.图示过程</strong><br>&#8195;&#8195;<strong>(1) 归并排序的流程</strong><br><img src="/blog/img/2020/02/21/归并排序1.png"><br><br>&#8195;&#8195;<strong>(2) 合并两个有序数组的流程</strong><br><img src="/blog/img/2020/02/21/归并排序2.png"><br><br>&#8195;&#8195;<strong>2.动图演示</strong><br><img src="/blog/img/2020/02/21/归并排序动图.gif"><br><br>&#8195;&#8195;<strong>3.工作原理</strong><br>&#8195;&#8195;第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>&#8195;&#8195;第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>&#8195;&#8195;第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>&#8195;&#8195;重复步骤3直到某一指针超出序列尾<br>&#8195;&#8195;将另一序列剩下的所有元素直接复制到合并序列尾  </p>
<p>&#8195;&#8195;<strong>4.比较</strong><br>&#8195;&#8195;归并排序是稳定的排序.即相等的元素的顺序不会改变.如输入记录 1(1) 3(2) 2(3) 2(4) 5(5) (括号中是记录的关键字)时输出的 1(1) 2(3) 2(4) 3(2) 5(5) 中的2 和 2 是按输入的顺序.这对要排序数据包含多个信息而要按其中的某一个信息排序,要求其它信息尽量按输入的顺序排列时很重要。归并排序的比较次数小于快速排序的比较次数，移动次数一般多于快速排序的移动次数。  </p>
<p>&#8195;&#8195;<strong>5.代码实现</strong>  </p>
<pre><code>public class MegerSort {

    public static void sort(int[] arr,int left,int right){
        if(left == right){
            return;
        }
        int mid = (left+right)/2;
        sort(arr,left,mid);
        sort(arr,mid+1,right);
        meger(arr,left,mid,right);
    }

    public static void meger(int[] arr, int left, int mid, int right) {
        int[] tmp = new int[right-left+1];
        int p1 = left;
        int p2 = mid+1;
        int i = 0;
        // 比较左右两部分的元素，哪个小，把那个元素填入tmp中
        while(p1&lt;=mid &amp;&amp; p2&lt;=right){
            tmp[i++]=(arr[p1]&lt;arr[p2])?arr[p1++]:arr[p2++];
        }
        // 将左边剩余的归并
        while(p1&lt;=mid){
            tmp[i++] = arr[p1++];
        }
        // 将右边剩余的归并
        while(p2&lt;=right){
            tmp[i++] = arr[p2++];
        }
        // 把最终的排序的结果复制给原数组
        for (i = 0; i &lt; tmp.length; i++) {
            arr[left+i] = tmp[i];
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[]{5,4,7,9,3,8,2,1};
        sort(arr,0,arr.length-1);
        System.out.println(Arrays.toString(arr));
    }

}</code></pre><p>&#8195;&#8195;<strong>6.复杂度</strong><br>&#8195;&#8195;时间复杂度：O(nlogn)<br>&#8195;&#8195;空间复杂度：O(N)，归并排序需要一个与原数组相同长度的数组做辅助来排序<br>&#8195;&#8195;稳定性：归并排序是稳定的排序算法，tmp[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];这行代码可以保证当左右两部分的值相等的时候，先复制左边的值，这样可以保证值相等的时候两个元素的相对位置不变。  </p>
<p>&#8195;&#8195;归并排序比较占用内存，但却是一种效率高且稳定的算法。<br>&#8195;&#8195;改进归并排序在归并时先判断前段序列的最大值与后段序列最小值的关系再确定是否进行复制比较。如果前段序列的最大值小于等于后段序列最小值，则说明序列可以直接形成一段有序序列不需要再归并，反之则需要。所以在序列本身有序的情况下时间复杂度可以降至O(n)。</p>
<p>&#8195;&#8195;<strong>7.参考文章</strong><br>&#8195;&#8195; <a href="https://www.jianshu.com/p/33cffa1ce613" target="_blank" rel="noopener">https://www.jianshu.com/p/33cffa1ce613</a><br>&#8195;&#8195; <a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015?fr=aladdin</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>排序算法之快速排序</title>
    <url>/blog/2020/02/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="1-1-初识快速排序"><a href="#1-1-初识快速排序" class="headerlink" title="1.1 初识快速排序"></a>1.1 初识快速排序</h2><p>&#8195;&#8195;快速排序(Quicksort)是对<a href="/blog/2020/01/08/排序算法之冒泡排序/" target="_blank">冒泡排序</a>的一种改进。所以快速排序也属于<strong>交换排序</strong>，通过元素之间的比较和交换位置来达到排序的效果。  </p>
<a id="more"></a>  
<p>&#8195;&#8195;不同的是，冒泡排序在每一轮中只把1个元素冒泡到数列的一端，而快速排序则<strong>在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列的一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分</strong>。  </p>
<p><img src="/blog/img/2020/02/18/快速排序.png"><br><br>&#8195;&#8195;这种思路就叫作<strong>分治法</strong>。  </p>
<p>&#8195;&#8195;每次把数列分成两部分，究竟有什么好处呢？<br>&#8195;&#8195;假如给出一个8个元素的数列，一般情况下，使用冒泡排序需要比较7轮，每一轮把一个元素移动到数列的一端，时间复杂度是O(n²)。<br>&#8195;&#8195;而快速排序的流程是什么样子呢？  </p>
<p><img src="/blog/img/2020/02/18/快速排序流程.png"><br><br>&#8195;&#8195;如图所示，在分治法的思想下，原素列在每一轮中都被拆分成两部分，每一部分在下一轮又被分别被拆分成两部分，直到不可再分为止。<br>&#8195;&#8195;每一轮的比较和交换，需要把数组全部元素都遍历一遍，时间复杂度是O(n)。这样的遍历一共需要多少轮呢？假如元素个数是n，那么平均情况下需要logn轮，因此快速排序算法总体的平均时间复杂度是<strong>O(nlogn)</strong>。</p>
<h2 id="1-2-基准元素的选择"><a href="#1-2-基准元素的选择" class="headerlink" title="1.2 基准元素的选择"></a>1.2 基准元素的选择</h2><p>&#8195;&#8195;基准元素，英文pivot，在分治过程中，以基准元素为中心，把其他元素移动到它的左右两边。<br>那么如何选择基准元素呢？<br>&#8195;&#8195;最简单的方式是选择数列的第一个元素。<br><img src="/blog/img/2020/02/18/基准元素选择1.png"><br><br>&#8195;&#8195;这种选择在绝大多数情况下是没有问题的。但是，假如有一个原本逆序的数列，期望排序成顺序数列，那么会出现什么情况呢？<br><img src="/blog/img/2020/02/18/逆序数列排序.png"><br><br>&#8195;&#8195;你会发现数列并没有被分成两半，每一轮都只确定了基准元素的位置。<br>&#8195;&#8195;在这种情况下数列的第1个元素要么是最小值，要么是最大值，根本无法发挥分治法的优势。<br>&#8195;&#8195;在这种极端的情况下，快速排序需要进行n轮，时间复杂度退化成了O(n²)。  </p>
<p>&#8195;&#8195;那么，该怎么避免这种情况的发生呢？<br>&#8195;&#8195;<strong>第一种：三者取中。将序列首、尾和中间位置上的记录进行比较，选择三者中值作为基准关键字。</strong><br>&#8195;&#8195;<strong>第二种：取left和right之间的一个随机数m(left&lt;m&lt;right)，用n[m]作为基准关键字。采用这种方法得到的快速排序一般称为随机的快速排序。</strong><br>&#8195;&#8195;所以，虽然快速排序的平均时间复杂度是<strong>O(nlogn)</strong>，但最坏情况下的时间复杂度是<strong>O(n²)</strong>。  </p>
<p>&#8195;&#8195;在后文中，为了简化步骤，省去了随机选择基准元素的过程，直接把首元素作为基准元素。  </p>
<h2 id="1-3-元素的交换"><a href="#1-3-元素的交换" class="headerlink" title="1.3 元素的交换"></a>1.3 元素的交换</h2><p>&#8195;&#8195;选定了基准元素以后，我们要做的就是把其他的元素中小于基准元素的都交换到基准元素的一边，大于基准元素的都交换到基准元素另一边。<br>&#8195;&#8195;具体怎么操作？有两种方法。<br>&#8195;&#8195;<strong>1.双边循环法</strong><br>&#8195;&#8195;<strong>2.单边循环法</strong><br>&#8195;&#8195;给出原始数列如下，要求对其从小到大进行排序。<br><img src="/blog/img/2020/02/19/原始数列.png"><br></p>
<h3 id="1-3-1-双边循环法"><a href="#1-3-1-双边循环法" class="headerlink" title="1.3.1 双边循环法"></a>1.3.1 双边循环法</h3><p>&#8195;&#8195;首先，选定基准元素pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素。<br><img src="/blog/img/2020/02/19/双边循环1.png"><br><br>&#8195;&#8195;接下里进行<strong>第1次循环</strong>，从right指针开始，让指针所指向的元素和基准元素做比较。如果<strong>大于或等于</strong>pivot，则指针向<strong>左</strong>移动；如果<strong>小于</strong>pivot，则right指针停止移动，切换到<strong>left</strong>指针。  </p>
<p>&#8195;&#8195;在当前数列中，1&lt;4，所以right指针停止移动，切换到left指针，进行下一步行动。  </p>
<p>&#8195;&#8195;轮到left指针行动，让指针所指向的元素和基准元素作比较。如果<strong>小于或等于</strong>pivot，则指针向<strong>右</strong>移动；如果<strong>大于</strong>pivot，则left指针停止移动。  </p>
<p>&#8195;&#8195;由于left开始指向的是基准元素，判定肯定相等，所以left右移1位。<br><img src="/blog/img/2020/02/19/双边循环2.png"><br><br>&#8195;&#8195;由于7 &gt; 4，left指针在元素7的位置停下。这时，让<strong>left和right指针所指向的元素进行交换</strong>。  
<img src="/blog/img/2020/02/19/双边循环3.png"><br><br>&#8195;&#8195;接下来进行<strong>第2次循环</strong>，重新切换到right指针，向左移动。right指针先移动到8,8&gt;4，继续左移。由于2&lt;4，停止在2的位置。<br>&#8195;&#8195;按照这个思路，后续步骤如图所示。<br><img src="/blog/img/2020/02/19/双边循环4.png"><br></p>
<p>&#8195;&#8195;<strong>双边循环法实现的快速排序代码展示，代码使用了递归的方式。</strong>  </p>
<pre><code>public class QuickSort {

    public static void sort(int[] arr,int startIndex,int endIndex){
        //递归结束条件，startIndex&gt;=endIndex时
        if(startIndex&gt;=endIndex){
            return;
        }
        //得到基准元素的位置
        int pivotIndex = partition(arr,startIndex,endIndex);
        //根据基准元素，分成两部分进行递归排序
        sort(arr,startIndex,pivotIndex-1);
        sort(arr,pivotIndex+1,endIndex);
    }

    /**
     * 分治（双边循环法）
     * @param arr 带交换的数组
     * @param startIndex 起始下标
     * @param endIndex 结束下标
     */
    private static int partition(int[] arr, int startIndex, int endIndex) {
        //取第一个位置(也可以选择随机位置)的元素作为基准元素
        int pivot = arr[startIndex];
        int left = startIndex;
        int right = endIndex;
        while(left!=right){
            //控制right指针比较并左移
            while(left&lt;right &amp;&amp; arr[right]&gt;pivot){
                right--;
            }
            //控制left指针比较并右移
            while(left&lt;right &amp;&amp; arr[left]&lt;=pivot){
                left++;
            }
            //交换left和right指针所指向的元素
            if(left&lt;right){
                int tmp = arr[left];
                arr[left]=arr[right];
                arr[right]=tmp;
            }
        }
        //pivot和指针重合点交换
        arr[startIndex] = arr[left];
        arr[left]= pivot;
        return left;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{4,7,6,5,3,2,8,1};
        sort(arr,0,arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
}</code></pre><p>关于基准元素选择的优化  </p>
<pre><code>public static int partition2(int[] arr, int startIndex, int endIndex) {
    //三数取中间值
    int mid = startIndex + (endIndex-startIndex)/2;
    if(arr[mid]&gt;arr[endIndex]){
        swap(arr,mid,endIndex);
    }
    if(arr[startIndex]&gt;arr[endIndex]){
        swap(arr,startIndex,endIndex);
    }
    if(arr[mid]&gt;arr[startIndex]){
        swap(arr,mid,startIndex);
    }
    int pivot = arr[startIndex];
    int left = startIndex;
    int right = endIndex;

    //略(代码同上面)

    return left;
}

//交换位置
public static void swap(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j]; 
    arr[j] = tmp;
}</code></pre><h3 id="1-3-2-单边循环法"><a href="#1-3-2-单边循环法" class="headerlink" title="1.3.2 单边循环法"></a>1.3.2 单边循环法</h3><p>&#8195;&#8195;双边循环法从数组的两边交替遍历元素，虽然更加直观，但是代码实现相对繁琐。而单边循环法简单得多，只从数组的一边对元素进行遍历和交换。我们来看一下详细过程。<br>&#8195;&#8195;给出原始数列如下，要求从小到大进行排序。<br><img src="/blog/img/2020/02/19/原始数列2.png"><br><br>&#8195;&#8195;开始和双边循环法相似，首先选定基准元素pivot。同时，设置一个mark指针指向数列起始位置，这个mark代表<strong>小于基准元素的区域边界</strong>。  
<img src="/blog/img/2020/02/19/单边循环1.png"><br><br>&#8195;&#8195;接下来，从基准元素的下一个位置开始遍历数组。<br>&#8195;&#8195;如果遍历到的元素大于基准元素，就继续往后遍历。<br>&#8195;&#8195;如果遍历到的元素小于基准元素，则需要做两件事：第一，把mark指针右移一位，因为小于pivot的区域边界增大了1；其二，让最新遍历到的元素和mark指针所在位置的元素交换位置，因为最新遍历到的元素归属于小于pivot的区域。<br>&#8195;&#8195;首先遍历到元素7,7&gt;4，所以继续遍历。<br><img src="/blog/img/2020/02/19/单边循环2.png"><br><br>&#8195;&#8195;接下来遍历到的是元素3,3&lt;4，所以mark指针右移1位。<br><img src="/blog/img/2020/02/19/单边循环3.png"><br><br>&#8195;&#8195;随后让元素3和mark指针所在位置的元素交换，因为元素3归属于小于pivot的区域。<br><img src="/blog/img/2020/02/19/单边循环4.png"><br><br>&#8195;&#8195;按照这个思路，继续遍历，后续步骤如图所示。<br><img src="/blog/img/2020/02/19/单边循环5.png"><br><br>&#8195;&#8195;<strong>单边循环法实现的快速排序代码展示</strong>  </p>
<pre><code>public class QuickSort {

    public static void sort(int[] arr,int startIndex,int endIndex){
        //递归结束条件，startIndex&gt;=endIndex时
        if(startIndex&gt;=endIndex){
            return;
        }
        //得到基准元素的位置
        int pivotIndex = partition(arr,startIndex,endIndex);
        //根据基准元素，分成两部分进行递归排序
        sort(arr,startIndex,pivotIndex-1);
        sort(arr,pivotIndex+1,endIndex);
    }

    /**
     * 分治（单边循环法）
     * @param arr 带交换的数组
     * @param startIndex 起始下标
     * @param endIndex 结束下标
     */
    private static int partition(int[] arr, int startIndex, int endIndex) {
        //取第一个位置(也可以选择随机位置)的元素作为基准元素
        int pivot = arr[startIndex];
        int mark = startIndex;
        for(int i=startIndex+1;i&lt;=endIndex;i++){
            if(arr[i]&lt;pivot){
                mark++;
                int tmp = arr[mark];
                arr[mark] = arr[i];
                arr[i] = tmp;
            }
        }
        //遍历结束
        arr[startIndex] = arr[mark];
        arr[mark] = pivot;
        return mark;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{4,7,6,5,3,2,8,1};
        sort(arr,0,arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
}</code></pre><p>&#8195;&#8195;可以很明显的看出，partition方法只要一个大循环就搞定了，的确比双边循环法简单多了。  </p>
<h2 id="1-4-非递归实现"><a href="#1-4-非递归实现" class="headerlink" title="1.4 非递归实现"></a>1.4 非递归实现</h2><p>&#8195;&#8195;<strong>绝大多数的递归逻辑，都可以用<span style="font-size:20px;color:blue;">栈</span>的方式来代替。</strong><br>&#8195;&#8195;代码中一层一层的方法调用，本身就使用了一个方法调用栈。每次进入一个新的方法，就相当于入栈，每次有方法返回，就相当于出栈。<br>&#8195;&#8195;所以，可以把原本的递归实现转化成一个栈的实现，在栈中存储每一次方法调用的参数。<br><img src="/blog/img/2020/02/19/栈实现快速排序.png"><br><br>具体代码展示   </p>
<pre><code>public class QuickSort {

    public static void sort(int[] arr,int startIndex,int endIndex){
        Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = new Stack&lt;&gt;();
        //整个数列的起止下标，以哈希形式入栈
        Map&lt;String, Integer&gt; rootParam = new HashMap&lt;&gt;();
        rootParam.put(&quot;startIndex&quot;, startIndex);
        rootParam.put(&quot;endIndex&quot;, endIndex);
        quickSortStack.push(rootParam);

        //循环结束条件，栈为空时
        while(!quickSortStack.isEmpty()){
            Map&lt;String, Integer&gt; param = quickSortStack.pop();
            int pivotIndex = partition(arr,param.get(&quot;startIndex&quot;),param.get(&quot;endIndex&quot;));
            //根据基准元素分成两部分，把每一部分的起止上下标入栈
            if(param.get(&quot;startIndex&quot;) &lt; pivotIndex-1){
                Map&lt;String, Integer&gt; leftParam = new HashMap&lt;&gt;();
                leftParam.put(&quot;startIndex&quot;, startIndex);
                leftParam.put(&quot;endIndex&quot;, pivotIndex-1);
                quickSortStack.push(leftParam);
            }
            if(param.get(&quot;endIndex&quot;) &gt; pivotIndex+1){
                Map&lt;String, Integer&gt; rightParam = new HashMap&lt;&gt;();
                rightParam.put(&quot;startIndex&quot;, pivotIndex+1);
                rightParam.put(&quot;endIndex&quot;, endIndex);
                quickSortStack.push(rightParam);
            }
        }
    }

    /**
     * 分治（单边循环法）
     * @param arr 带交换的数组
     * @param startIndex 起始下标
     * @param endIndex 结束下标
     */
    private static int partition(int[] arr, int startIndex, int endIndex) {
        //取第一个位置(也可以选择随机位置)的元素作为基准元素
        int pivot = arr[startIndex];
        int mark = startIndex;
        for(int i=startIndex+1;i&lt;=endIndex;i++){
            if(arr[i]&lt;pivot){
                mark++;
                int tmp = arr[mark];
                arr[mark] = arr[i];
                arr[i] = tmp;
            }
        }
        //遍历结束
        arr[startIndex] = arr[mark];
        arr[mark] = pivot;
        return mark;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{4,7,6,5,3,2,8,1};
        sort(arr,0,arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
}</code></pre><p><strong>PS:快速排序属于不稳定排序。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>排序算法之希尔排序</title>
    <url>/blog/2020/02/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>希尔排序(Shell Sort)是<a href="/blog/2020/02/12/排序算法之插入排序/" target="_blank">插入排序</a>的一种又称为”缩小增量排序”(Diminishing Increment Sort)，是直接插入排序算法的一种高效的改进。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。<br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。  </p>
<a id="more"></a>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。<br>2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。  </p>
<p><strong>如果说插入排序是在小规模数据下或者基本有序的情况下比较高效，也就意味着它对数据规模稍微较大并且无序的情况下时排序效率比较低，而希尔排序的出现正是为了解决这个问题。(希尔排序对中等规模数据的性能表现还不错)</strong>  </p>
<p><strong>给定实例的shell排序的排序过程</strong><br>假设待排序文件有10个记录，其关键字分别是：<br>49，38，65，97，76，13，27，49，55，04。<br>增量序列的取值依次为：<br>5，2，1<br><img src="/blog/img/2020/02/18/希尔排序图解.png"><br> </p>
<p><strong>算法分析</strong><br>&#8195;&#8195;不需要大量的辅助空间，和归并排序一样容易实现。希尔排序是基于插入排序的一种算法， 在此算法基础之上增加了一个新的特性，提高了效率。希尔排序的时间的时间复杂度为O(n<sup>3/2</sup>)，希尔排序时间复杂度的下界是n*log2n。希尔排序没有快速排序算法快 O(n(logn))，因此<b>中等大小规模表现良好</b>，对规模非常大的数据排序不是最优选择。但是比O(n²)复杂度的算法快得多。并且希尔排序非常容易实现，算法代码短而简单。 此外，希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序在最坏的情况下执行的效率会非常差。专家们提倡，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法. 本质上讲，希尔排序算法是直接插入排序算法的一种改进，减少了其复制的次数，速度要快很多。 原因是，当n值很大时数据项每一趟排序需要移动的个数很少，但数据项的距离很长。当n值减小时每一趟需要移动的数据增多，此时已经接近于它们排序后的最终位置。 正是这两种情况的结合才使希尔排序效率比插入排序高很多。Shell算法的性能与所选取的分组长度序列有很大关系。只对特定的待排序记录序列，可以准确地估算关键词的比较次数和对象移动次数。想要弄清关键词比较次数和记录移动次数与增量选择之间的关系，并给出完整的数学分析，今仍然是数学难题。</p>
<p><strong>希尔排序的复杂度和增量序列是相关的</strong><br>{1,2,4,8,…}这种序列并不是很好的增量序列，使用这个增量序列的时间复杂度（最坏情形）是O(n^2)<br>Hibbard提出了另一个增量序列{1,3,7，…,2^k-1}，这种序列的时间复杂度(最坏情形)为O(n^1.5)<br>Sedgewick提出了几种增量序列，其最坏情形运行时间为O（n^1.3）,其中最好的一个序列是{1,5,19,41,109,…}  </p>
<p><strong>代码展示</strong><br><strong>希尔排序</strong>代码示例如下： </p>
<pre><code>public class ShellSort {

    public static void sort(int[] arr){
        for (int step = arr.length/2; step &gt; 0;step/=2) {
            insertSort(arr,step);//这个循环里其实就是一个插入排序
        }
    }

    public static void insertSort(int[] arr,int step){
        int temp,j;
        for (int i = step; i &lt; arr.length; i++) {
            j = i-step;
            temp = arr[i];
            while(j&gt;=0 &amp;&amp; temp&lt;arr[j]){
                arr[j+step] = arr[j];
                j-=step;
            }
            arr[j+step] = temp;
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[]{49,38,65,97,76,13,27,49,55,04};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

}</code></pre><p><strong>参考文章</strong><br><a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin</a><br><a href="https://blog.csdn.net/qq_39207948/article/details/80006224" target="_blank" rel="noopener">https://blog.csdn.net/qq_39207948/article/details/80006224</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/blog/2020/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>组合模式(Composite Pattern)，又叫部分整体模式，是用于把一组相似的对象当做一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，他创建了对象组的树形结构。<br>这种模式创建了一个包含自己对象组的类，该类提供了修改相同对象组的方式。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。<br><strong>何时使用：</strong>1、你想表示对象的部分-整体层次结构(树形结构)。2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。<br><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。<br><strong>关键代码：</strong>树枝内部组合该接口，并且含有内部属性List，里面放Component。<br><strong>应用实例：</strong>1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。2、在JAVA AWT和SWING中，对于Button和Checkbox是树叶，Container是树枝。<br><strong>优点：</strong>1、高层模块调用简单。2、节点自由增加。<br><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。<br><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。<br><strong>注意事项：</strong>定义时为具体类。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/02/18/组合模式结构图.png">  

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>Component为组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明接口用于访问和管理Component的子部件。  </p>
<pre><code>public abstract class Component {

    protected String name;

    public Component(String name){
        this.name=name;
    }

    //通常都用add和remove方法来提供增加或移除树枝的功能
    public abstract void add(Component c);
    public abstract void remove(Component c);
    public abstract void display(int depth);
}</code></pre><p>Leaf在组合中表示叶节点对象，叶节点没有子节点。  </p>
<pre><code>public class Leaf extends Component{

    public Leaf(String name) {
        super(name);
    }

    /**
     * 由于叶子节点没法再增加分支和树叶，所以add和remove方法实现它没有意义，
     * 但这样做可以消除叶节点和枝节点在抽象层次的区别，它们具备完全一致的接口
     */
    @Override
    public void add(Component c) {
        System.out.println(&quot;Cannot add to a leaf&quot;);
    }

    @Override
    public void remove(Component c) {
        System.out.println(&quot;Cannot remove to a leaf&quot;);
    }

    @Override
    public void display(int depth) {
        //叶节点的具体方法，次数是显示其名称和级别
        StringBuffer b = new StringBuffer();
        for (int i = 0; i &lt; depth; i++) {
            b.append(&quot;-&quot;);
        }
        System.out.println(b.toString()+name);
    }


}</code></pre><p>Composite定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件相关的操作，比如增加add和删除remove。  </p>
<pre><code>public class Composite extends Component{

    //一个子对象集合用来存储其下属的枝节点和叶节点
    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();

    public Composite(String name) {
        super(name);
    }

    @Override
    public void add(Component c) {
        children.add(c);
    }

    @Override
    public void remove(Component c) {
        children.remove(c);
    }

    @Override
    public void display(int depth) {
        //显示其枝节点名称，并对其下级进行遍历
        StringBuffer b = new StringBuffer();
        for (int i = 0; i &lt; depth; i++) {
            b.append(&quot;-&quot;);
        }
        System.out.println(b.toString()+name);
        for (Component component : children) {
            component.display(depth+2);
        }
    }

}</code></pre><p>客户端代码，能通过Component接口操作组合部件的对象。  </p>
<pre><code>public class Client {
    public static void main(String[] args) {
        //生成树根root，根上长出两个叶LeafA 和 Leaf B
        Composite root = new Composite(&quot;root&quot;);
        root.add(new Leaf(&quot;Leaf A&quot;));
        root.add(new Leaf(&quot;Leaf B&quot;));

        //根上长出分支Composite X，分支上也有两叶Leaf XA 和 Leaf XB
        Composite x = new Composite(&quot;Composite X&quot;);
        x.add(new Leaf(&quot;Leaf XA&quot;));
        x.add(new Leaf(&quot;Leaf XB&quot;));
        root.add(x);

        //在Composite X上再长出分支Composite XY，分支上也有两叶Leaf XYA和Leaf XYB
        Composite xy = new Composite(&quot;Composite XY&quot;);
        xy.add(new Leaf(&quot;Leaf XYA&quot;));
        xy.add(new Leaf(&quot;Leaf XYB&quot;));
        x.add(xy);

        //树根又长出两叶Leaf C和Leaf D，可惜Leaf D没长牢，被风吹走了
        root.add(new Leaf(&quot;Leaf C&quot;));
        Leaf d = new Leaf(&quot;Leaf D&quot;);
        root.add(d);
        root.remove(d);

        //显示大树的样子
        root.display(1);
    }
}</code></pre><p>结果显示  </p>
<pre><code>-root
---Leaf A
---Leaf B
---Composite X
-----Leaf XA
-----Leaf XB
-----Composite XY
-------Leaf XYA
-------Leaf XYB
---Leaf C</code></pre><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/composite-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/composite-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/blog/2020/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录属于行为型模式。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。<br><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。<br><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。<br><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。<br><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。<br><strong>应用实例：</strong>1、后悔药。2、打游戏时的存档。3、Windows里的ctrl+z。4、IE中的后退。5、数据库的事务管理。<br><strong>优点：</strong>1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史的状态。2、实现了信息的封装，使得用户不需要关心状态的保存细节。<br><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。<br><strong>使用场景：</strong>1、需要保存/恢复数据的相关状态场景。2、提供一个可回滚的操作。<br><strong>注意事项：</strong>1、为了符合迪米特法则，还要增加一个管理备忘录的类。2、为了节约内存，可以使用原型+备忘录模式。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/02/17/备忘录模式结构图.png">  

<p>&#8195;&#8195;<strong>Originator（发起人）</strong>：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可以使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。<br>&#8195;&#8195;<strong>Memento（备忘录）</strong>：负责创建Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。<br>&#8195;&#8195;<strong>Caretaker（管理者）</strong>：负责保存好备忘录Memento，不能对备忘录的内容进行操作或者检查。  </p>
<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>发起人（Originator）类  </p>
<pre><code>public class Originator {

    //需要保存的属性，可能有多个
    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    //创建备忘录，将当前需要保存的信息导入并实例化出一个Memento对象
    public Memento createMemento(){
        return new Memento(state);
    } 

    //恢复备忘录，将Memento导入并将相关数据恢复
    public void setMemento(Memento memento){
        this.state = memento.getState();
    }

    //显示数据
    public void show(){
        System.out.println(&quot;state=&quot;+ this.state);
    }
}</code></pre><p>备忘录（Memento）类  </p>
<pre><code>public class Memento {

    private String state;

    //构造方法，将相关数据导入
    public Memento(String state) {
        this.state=state;
    }

    //需要保存的数据属性，可以是多个
    public String getState(){
        return this.state;
    }
}</code></pre><p>管理者（Caretaker）类  </p>
<pre><code>public class Caretaker {

    private Memento memento;

    //得到备忘录
    public Memento getMemento() {
        return memento;
    }
    //设置备忘录
    public void setMemento(Memento memento) {
        this.memento = memento;
    }



}</code></pre><p>客户端代码  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Originator o = new Originator();
        //Originator初始状态，状态属性为&quot;On&quot;
        o.setState(&quot;On&quot;);
        o.show();

        Caretaker c = new Caretaker();
        //保存状态时，由于有了很好的封装，可以隐藏Originator的实现细节
        c.setMemento(o.createMemento());

        //Originator改变了状态属性为&quot;Off&quot;
        o.setState(&quot;Off&quot;);
        o.show();

        //恢复原初始状态
        o.setMemento(c.getMemento());
        o.show();
    }
}</code></pre><p>输出结果  </p>
<pre><code>state=On
state=Off
state=On</code></pre><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/memento-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/memento-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/blog/2020/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>&#8195;&#8195;适配器模式(Adapter Pattern)是作为两个不兼容接口之间的桥梁。这种类型的设计模式属于结构型模式，他结合了两个独立接口的功能。<br>&#8195;&#8195;这种模式涉及一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。<br><strong>何时使用：</strong>1、系统需要现有的类，而此类的接口不符合系统的需要。2、想要建立一个可以重复使用的类，用于一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口）。<br><strong>如何解决：</strong>继承或依赖（推荐）。<br><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。<br><strong>应用实例：</strong>1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。3、在LINUX上运行WINDOWS程序。4、JAVA中的jdbc。<br><strong>优点：</strong>1、可以让任何两个没有关联的类一起运行。2、提高了类的复用。3、增加了类的透明度。4、灵活性好。<br><strong>缺点：</strong>1、过多的使用适配器，会让系统非常凌乱不易整体进行把握。比如明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果出现太多这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。2、由于JAVA最多继承一个类，所以最多只能适配一个适配者类。<br><strong>使用场景：</strong>有动机的修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。<br><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/02/17/适配器模式结构图.png">  

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>Target(这是客户端所期待的接口，目标可以是具体的或抽象的类，也可以是接口)代码如下：  </p>
<pre><code>public class Target {

    public void request(){
        System.out.println(&quot;普通请求&quot;);
    }

}</code></pre><p>Adaptee(需要适配的类)代码如下：  </p>
<pre><code>public class Adaptee {

    public void specificRequest(){
        System.out.println(&quot;特殊请求&quot;);
    }
}</code></pre><p>Adapter(通过在内部包装一个Adaptee对象，把源接口转换成目标接口)代码如下：   </p>
<pre><code>public class Adapter extends Target{

    //建立一个私有的Adaptee对象
    private Adaptee adaptee = new Adaptee();

    public void request(){
        //这样就可以把表面上调用request()方法变成实际调用specificRequest()
        adaptee.specificRequest();
    }
}</code></pre><p>客户端代码如下：  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Target target = new Adapter();
        target.request();
    }
}</code></pre><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/adapter-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/adapter-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>排序算法之插入排序</title>
    <url>/blog/2020/02/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>插入排序(Insertion sort)是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法————插入排序，算法适用于少量数据的排序，时间复杂度O(n²)。是稳定的排序方法。插入算法要把排序的数组分成两个部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外(让数组多一个空间才有插入的位置)，而第二部分就只包含这一个元素(即待插入元素)。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。  </p>
<a id="more"></a>  
<p>插入排序包含：直接插入排序、折半插入排序（二分插入排序）和链表插入排序。  </p>
<h2 id="1-直接插入排序"><a href="#1-直接插入排序" class="headerlink" title="1.直接插入排序"></a>1.直接插入排序</h2><p><img src="/blog/img/2020/02/12/直接插入排序.png"><br>  </p>
<p><strong>代码展示</strong><br><strong>直接插入排序</strong>代码示例如下： </p>
<pre><code>public static void sort(int[] arr){
    int j,target;
    //假定第一个元素被放到了正确的位置上
    //这样，仅需遍历1 - (n-1)轮
    for (int i = 1; i &lt; arr.length; i++) {
        j = i;
        target = arr[i];
        while(j&gt;0 &amp;&amp; target&lt;arr[j-1]){
            arr[j]=arr[j-1];
            j--;
        }
        arr[j]=target;
    }
}</code></pre><p>算法分析<br>1.当初始序列为正序时，只需要外循环n-1次，每次进行一次比较。无需移动元素。此时比较次数(C<sub>min</sub>)和移动次数(M<sub>min</sub>)达到最小值。<br>C<sub>min</sub> = n-1;<br>M<sub>min</sub> = 0；<br>此时时间复杂度为O(n)。<br>2.当初始序列为反序时，需要外循环n-1次，每次排序中待插入的元素都要和[0,i-1]中的i个元素进行比较且要将这i个元素后移i次，再加上target=arr[i]与arr[j]=target的两次移动，每趟移动次数为i+2，此时比较次数和移动次数达到最大值。<br>C<sub>max</sub> = 1+2+…+(n-1) = n(n-1)/2=O(n²);<br>M<sub>max</sub> = （1+2）+ （2+2）+…..+（n-1+2）=（n-1）(n+4)/2=O(n²)；<br>3.在直接插入排序中只使用了i，j，tartget这三个辅助元素，与问题规模无关，空间复杂度为O(1)。<br>4.相同元素的相对位置不变，如果两个元素相同，插入元素放在相同元素后面。是一种稳定排序。  </p>
<h2 id="2-折半插入排序"><a href="#2-折半插入排序" class="headerlink" title="2.折半插入排序"></a>2.折半插入排序</h2><p><strong>原理：</strong>折半插入算法是对直接插入排序算法的改进，排序原理同直接插入排序算法。<br><strong>算法思想：</strong><br>折半排序利用二分法的思想，在一个有序的序列中，找到新元素在该序列中的位置，然后插入。如图1所示，共有n个元素，前i个元素已经是有序序列，现在要将第i个元素插入其中。折半插入排序需要做两步工作：找到待插入元素的位置、插入。<br><img src="/blog/img/2020/02/14/折半插入排序1.png"><br><br>首先要定义两个指针(不是语法里面的指针，是下标的意思)low和high用于寻找a[i]的插入位置，low指向a[0]，high指向a[i-1]，中点mid=(low+high)/2。<br><img src="/blog/img/2020/02/14/折半插入排序2.png"><br><br>如图2所示二分法的思想是，比较a[i]与a[mid]的大小，若a[i]&gt;a[mid]，说明a[i]的位置应该在mid ~ high之间，将区间[low,high]缩短为[mid+1,high]，令指针low=mid+1；若a[i]&lt;=a[mid]，说明a[i]的位置应该在low ~ mid之间，将区间压缩为[low,mid-1]，令指针high=mid-1。每次折半之后，a[i]的位置应该在[low,high]之间。 </p>
<p>如此循环，low与high渐渐靠近，直到low&gt;high跳出循环，a[i]的位置找到，low即为a[i]应该放置的位置。 </p>
<p>找到a[i]的位置之后进行插入，先将a[low] ~ a[i-1]这些元素向后平移一个元素的位置，然后将a[i]放到low位置。  </p>
<p><strong>代码展示</strong><br><strong>折半插入排序</strong>代码示例如下： </p>
<pre><code>public static void sort(int[] arr){
    int low,high,mid,temp;
    for (int i = 1; i &lt; arr.length; i++) {//开始 以a[0]作为有序序列，从a[1]开始找到当前元素a[i]应该放置的位置 
        low = 0;
        high = i-1;
        temp = arr[i];
        while(low&lt;=high){//二分思想循环寻找a[i]的位置 
            mid = (low+high)/2;
            if(arr[mid]&lt;arr[i]){
                low = mid+1;//low指针增加
            }else{
                high = mid-1;//high指针减小 
            }
        }
        for (int j = i; j &gt; low; j--) {//将元素向后平移
            arr[j] = arr[j-1];
        }
        arr[low] = temp;//将元素temp = a[i] 放置到low位置 
    }
}</code></pre><p><strong>算法分析：</strong>一个细节：为什么内层的循环while(low&lt;=high){…}结束之后以low作为a[i]应该放置的位置?<br><strong>第一种情况：a[mid] &lt; a[i] &lt;=  a[high]：</strong><br>第N-2步时，mid=(low+high)/2，如果a[i]&gt;a[mid]，low=mid+1，这样就到了第N-1步，low与high重合，high=mid-1，这样就到了第N步，high&lt;low，退出循环，此时位置high就是第N-2步的位置mid，所以此时，a[high]&lt;a[i]&lt;=a[low]，所以low就是a[i]应该放置的位置。<br><img src="/blog/img/2020/02/14/折半插入排序3.png"><br><br><strong>第二种情况：a[low] &lt;=  a[i] &lt;  a[mid]：</strong><br> 第N-2步，mid=(low+high) / 2，如果a[i] &lt;= a[mid]，high = mid-1，这样就到了第N-1步，low与high重合，mid=(low+high)/2=low=high，由于a[i]&gt;a[low]=a[mid]，所以low=mid+1，这样就到了第N步，high&lt;low，退出循环，此时位置low就是第N-2步的位置mid，那么此时，a[high]&lt;a[i]&lt;=a[low]，所以low就是a[i]应该放置的位置。<br><img src="/blog/img/2020/02/14/折半插入排序4.png"><br>  </p>
<h2 id="3-链表插入排序（单链表）"><a href="#3-链表插入排序（单链表）" class="headerlink" title="3.链表插入排序（单链表）"></a>3.链表插入排序（单链表）</h2><p>顾名思义对链表进行插入排序。<br>1.链表无法像数组一样随机访问，对于每个节点，需从头遍历获取合适位置。<br>2.因为需要调换节点的位置，需要基于节点的前导节点进行操作，因此需要为原始链表创建一个虚拟头节点，左右原始头节点的前导节点。  </p>
<p><strong>代码展示</strong><br><strong>链表插入排序</strong>代码示例如下： </p>
<pre><code>//定义三个指针 pre, cur, lat
//pre    cur    lat
// h  -&gt;  4  -&gt;  2  -&gt;  5  -&gt;  3  -&gt;  null
public class ListInsertSort {
    public static Node sort(Node head){
        Node h = new Node(Integer.MIN_VALUE);//创建一个虚拟的头节点，作为原始头节点的前导节点，便于后面的操作，该虚拟有节点的值最小
        h.next=head;
        Node pre = h;
        Node cur = head;
        Node lat;
        while(cur!=null){
            lat = cur.next; // 记录下一个要插入排序的值
            if(lat!=null &amp;&amp; lat.data&lt;cur.data){// 只有 cur.next 比 cur 小才需要向前寻找插入点
                // 寻找插入点，从 pre 开始遍历 （每次都是头节点 h 开始向后遍历，因为单向链表是无法从后往前遍）
                while (pre.next != null &amp;&amp; pre.next.data &lt; lat.data) { // 如果当前节点的值小于要插入排序的值
                    pre = pre.next; // 继续向后移动
                }
                // 找到要插入的位置，此时 pre 节点后面的位置就是 lat 要插入的位置
                // 交换 pre 跟 lat 节点需要一个 temp 节点来临时保存下插入位置 node 后 next
                Node tmp = pre.next;
                // 在 pre 节点后面插入
                pre.next=lat;
                // 此时 cur 节点还是 pre 所在的节点，所以其 next 要指向插入节点 lat 指向的 next
                cur.next = lat.next;
                // 插入lat节点后，把记录的原先插入位置后续的 next 节点传给它
                lat.next=tmp;
                // 由于每次都是从前往后找插入位置，但是单向链表是无法从后往前遍历，所以需要每次插入完成后要让 pre 复位
                pre = h;
            }else{
                // 到这直接把 cur 指针指向到下一个
                cur = lat;
            }
        }
        return h.next;
    }

    public static void print(Node node){
        while(node!=null){
            System.out.print(node.data+&quot; &quot;);
            node = node.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Node head = new Node(4);
        head.next = new Node(2);
        head.next.next = new Node(5);
        head.next.next.next = new Node(3);
        ListInsertSort.print(head);
        head = sort(head);
        ListInsertSort.print(head);
    }
}

class Node{
    int data;
    Node next;
    public Node(int data){
        this.data=data;
    }
}</code></pre><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992?fr=aladdin</a><br><a href="https://www.jianshu.com/p/7cf0656e76dd" target="_blank" rel="noopener">https://www.jianshu.com/p/7cf0656e76dd</a><br><a href="https://www.cnblogs.com/sunbines/p/9158757.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunbines/p/9158757.html</a><br><a href="https://www.cnblogs.com/tensory/p/6590799.html" target="_blank" rel="noopener">https://www.cnblogs.com/tensory/p/6590799.html</a><br><a href="https://www.jianshu.com/p/9dc6511be2e6" target="_blank" rel="noopener">https://www.jianshu.com/p/9dc6511be2e6</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>排序算法之选择排序</title>
    <url>/blog/2020/02/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理是：<strong>第一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小(最大)元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零</strong>。选择排序时不稳定的排序方法。  </p>
<a id="more"></a>
<p><strong>动图演示</strong><br><img src="/blog/img/2020/02/10/选择排序.gif"><br>  </p>
<p><strong>算法性能</strong><br>1.时间复杂度<br>选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。<br>比较次数O(n<sup>2</sup>），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+…+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。<br>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。<br>2.稳定性<br>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。   </p>
<p><strong>代码展示</strong><br><strong>选择排序</strong>代码示例如下：  </p>
<pre><code>public static void sort(int[] arr){
    //总共要经过 N-1 轮比较
    for (int i = 0; i &lt; arr.length-1; i++) {
        int min = i;
        //每轮需要比较的次数 N-i
        for (int j = i+1; j &lt; arr.length; j++) {
            if(arr[min]&gt;arr[j]){
                min = j;//记录目前能找到的最小值元素的下标
            }
        }
        //将找到的最小值和i位置所在的值进行交换
        if(i!=min){
            int temp = arr[min];
            arr[min]=arr[i];
            arr[i]=temp;
        }
    }
}</code></pre>]]></content>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/blog/2020/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在状态模式(State Pattern)中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。<br>在状态模式中，我们创表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>允许对象在内部状态发生改变时改变他的行为，对象看起来好像修改了它的类。<br><strong>主要解决：</strong>对象的行为依赖于它的状态(属性)，并且可以根据它的状态改变而改变它的相关行为。<br><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。<br><strong>如何解决：</strong>将各种具体的状态类抽象出来。<br><strong>关键代码：</strong>通常命令模式的接口只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除if…else等条件选择语句。<br><strong>应用实例：</strong>1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。2、曾侯乙编钟中，’钟是抽象接口’，’钟A’等是具体状态，’曾侯乙编钟’是具体环境(Context)。<br><strong>优点：</strong>1、将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。2、将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易的增加新的状态和转换。说白了，这样做的目的就是为了消除庞大的条件分支语句，状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖。<br><strong>缺点：</strong>1、状态模式的使用必然会增加系统类和对象的个数。2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源代码。<br><strong>使用场景：</strong>1、行为随状态改变而改变的场景。2、条件、分支语句的代替者。<br><strong>注意事项：</strong>在行为受到约束的时候使用状态模式，而且状态不超过5个。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/02/10/状态模式结构图.png">  

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>State类，抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为。  </p>
<pre><code>public abstract class State {
    public abstract void handle(Context context);
}</code></pre><p>ConcreteSate类，具体状态，每一个子类实现一个与Context的一个状态相关的行为。  </p>
<pre><code>public class ConcreteStateA extends State{

    @Override
    public void handle(Context context) {
        context.setState(new ConcreteStateB());//设置ConcreteStateA的下一个状态是ConcreteStateB
    }

}

class ConcreteStateB extends State{

    @Override
    public void handle(Context context) {
        context.setState(new ConcreteStateA());//设置ConcreteStateB的下一个状态是ConcreteStateA
    }

}</code></pre><p>Context类，维护一个ConcreteState子类的实例，这个实例定义当前的状态。  </p>
<pre><code>public class Context {

    private State state;

    public Context(State state){//定义Context的初始状态
        this.state=state;
    }

    public State getState() {
        return state;
    }

    public void setState(State state) {
        this.state = state;
        System.out.println(&quot;当前状态：&quot;+state);
    }

    public void request(){
        state.handle(this);//对请求做处理并且指向下一个状态
    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Context c =new Context(new ConcreteStateA());

        //不断请求同时更改状态
        c.request();
        c.request();
        c.request();
        c.request();
    }
}</code></pre><p>输出结果  </p>
<pre><code>当前状态：设计模式.状态模式.ConcreteStateB@15db9742
当前状态：设计模式.状态模式.ConcreteStateA@6d06d69c
当前状态：设计模式.状态模式.ConcreteStateB@7852e922
当前状态：设计模式.状态模式.ConcreteStateA@4e25154f</code></pre><h2 id="4-与策略模式的区别"><a href="#4-与策略模式的区别" class="headerlink" title="4.与策略模式的区别"></a>4.与策略模式的区别</h2><p>在行为类设计模式中，状态模式和<a href="/blog/2019/09/09/设计模式/策略模式/" target="_blank">策略模式</a>是亲兄弟，两者非常相似，两个模式的实现类图基本一致。  </p>
<p><strong>策略模式：</strong>策略模式的客户端必须对所有的策略类相当了解，明确在当前场景下各种策略的利弊，权衡当前场景下应该使用哪种策略，也就是说策略类对客户端是暴露的。<br><strong>状态模式：</strong>状态模式依赖于其状态的变化时其内部的行为发生变化，将动作委托到代表当前状态的对象，对外表现为类发生了变化。    </p>
<h2 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5.参考文章"></a>5.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/state-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/state-pattern.html</a><br><a href="https://www.cnblogs.com/m7777/p/7723879.html" target="_blank" rel="noopener">https://www.cnblogs.com/m7777/p/7723879.html</a><br><a href="https://www.cnblogs.com/pokid/p/10474340.html" target="_blank" rel="noopener">https://www.cnblogs.com/pokid/p/10474340.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/blog/2020/01/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>建造者模式(Builder Pattern)使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，他提供了一种创建对象的最佳方式。<br>一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。  </p>
<a id="more"></a>  
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>将一个复杂的结构与其表示相分离，使得同样的构建过程可以创建不同的表示。<br><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。<br><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。<br><strong>如何解决：</strong>将变与不变分离开。<br><strong>关键代码：</strong>建造者：创建和提供实例，导演(指挥者类)：管理建造出来的实例的依赖关系。<br><strong>应用实例：</strong>1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的“套餐”。2、JAVA中的StringBuilder。<br><strong>优点：</strong>1、建造者独立，易扩展。2、便于控制细节风险。<br><strong>缺点：</strong>1、产品必须有共同点，范围有限制。2、如内部变化复杂，会有很多的建造类。<br><strong>使用场景：</strong>1、需要生成的对象具有复杂的内部结构。2、需要生成的对象内部属性本身相互依赖。<br><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2020/01/23/建造者模式结构图.png">  

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>Prodcut类——产品类，由多个部件组成。  </p>
<pre><code>public class Product {
    List&lt;String&gt; parts = new ArrayList&lt;&gt;();

    /**
     * 添加产品部件
     * @param part
     */
    public void add(String part){
        parts.add(part);
    }

    /**
     * 列举所有产品
     */
    public void show(){
        System.out.println(&quot;产品 创建 ----&quot;);
        for (String part : parts) {
            System.out.println(part);
        }
    }
}</code></pre><p>Builder类——抽象建造者类，确定产品由两个部件partA和partB组成，并声明一个得到产品建造后结果的方法getResult。  </p>
<pre><code>public abstract class Builder {
    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract Product getResult();
}</code></pre><p>ConcreteBuilder1类——具体建造者类。  </p>
<pre><code>public class ConcreteBuilder1 extends Builder{

    Product product = new Product();

    @Override
    public void buildPartA() {
        product.add(&quot;部件A&quot;);
    }

    @Override
    public void buildPartB() {
        product.add(&quot;部件B&quot;);
    }

    @Override
    public Product getResult() {
        return product;
    }

}</code></pre><p>ConcreteBuilder2类——具体建造者类。  </p>
<pre><code>public class ConcreteBuilder2 extends Builder {

    Product product = new Product();

    @Override
    public void buildPartA() {
        product.add(&quot;部件X&quot;);
    }

    @Override
    public void buildPartB() {
        product.add(&quot;部件Y&quot;);
    }

    @Override
    public Product getResult() {
        return product;
    }

}</code></pre><p>Director——指挥者类。  </p>
<pre><code>public class Director {

    //用来指挥建造过程
    public void construct(Builder builder){
        builder.buildPartA();
        builder.buildPartB();
    }
}</code></pre><p>客户端代码，客户不需要知道具体的建造过程。  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Director director = new Director();
        Builder b1 = new ConcreteBuilder1();
        Builder b2 = new ConcreteBuilder2();
        //指挥者用ConcreteBuilder1的方法来构建产品
        director.construct(b1);
        Product p1 = b1.getResult();
        p1.show();
        //指挥者用ConcreteBuilder2的方法来构建产品
        director.construct(b2);
        Product p2 = b2.getResult();
        p2.show();
    }
}</code></pre><p>输出结果  </p>
<pre><code>产品 创建 ----
部件A
部件B
产品 创建 ----
部件X
部件Y</code></pre><p><strong>PS:</strong>所以说，<strong>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方法时适用的模式。</strong>  </p>
<h2 id="4-建造者模式之链式写法-推荐"><a href="#4-建造者模式之链式写法-推荐" class="headerlink" title="4.建造者模式之链式写法(推荐)"></a>4.建造者模式之链式写法(推荐)</h2><p>链式写法是在原型基础上做优化，有些时候Builder的创建部分有默认值，或者不需要的情况下，而产生的不同的product，通过以上方式，就需要修改Director类个Builder类，再或者根据不同的创建顺序，生成不同的结果，也需要修改Director类。Director似乎显得很不稳定和多余。可以通过Builder自身的调用逻辑来生成Product，即链式调用。<br>实体Product类  </p>
<pre><code>public class Product {

    private String partA;
    private String partB;

    public Product(Builder builder){
        this.partA = builder.partA;
        this.partB = builder.partB;
    }

    public String getPartA() {
        return partA;
    }

    public void setPartA(String partA) {
        this.partA = partA;
    }

    public String getPartB() {
        return partB;
    }

    public void setPartB(String partB) {
        this.partB = partB;
    }

    public static Builder newBuilder(){
        return new Builder();
    }

    @Override
    public String toString() {
        return &quot;Product [partA=&quot; + partA + &quot;, partB=&quot; + partB + &quot;]&quot;;
    }

    public static final class Builder{
        private String partA;
        private String partB;

        public Builder buildPartA(String partA){
            this.partA = partA;
            return this;
        }

        public Builder buildPartB(String partB){
            this.partB = partB;
            return this;
        }

        public Product build(){
            return new Product(this);
        }

    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Product product = new Product.Builder()
                .buildPartA(&quot;部件A&quot;)
                .buildPartB(&quot;部件B&quot;)
                .build();
        System.out.println(product.toString());
    }
}</code></pre><p><strong>总结：</strong>  </p>
<ul>
<li>Director角色并非多余，能把复杂的Product创建过程对外隐藏，使Builder部件和创建过程分离，各方易于扩展，降低了耦合度。  </li>
<li>链式写法较多用于<strong>通过链式调用分部组装对象</strong>，本质还是创建一个对象。 </li>
<li>在组装过程中的<strong>算法是多变的</strong>，每一步的调用次数、调用顺序都可能会影响最终结果。而组件的装配方式是<strong>稳定不变的</strong>,每个调用算法都是独立影响最终变化的。  </li>
</ul>
<h2 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5.参考文章"></a>5.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/builder-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/builder-pattern.html</a><br><a href="https://www.jianshu.com/p/8481e9094ec5" target="_blank" rel="noopener">https://www.jianshu.com/p/8481e9094ec5</a><br><a href="https://www.jianshu.com/p/8e871becd9cf" target="_blank" rel="noopener">https://www.jianshu.com/p/8e871becd9cf</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/blog/2020/01/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>再讲外观模式之前，我们先讲点其他的。<br>炒过股票的朋友应该都清楚，炒股是一门技术活，涉及的专业知识也比较深。一般刚入股市的新手其实都不会炒股票，一般都是跟风选股或者凭感觉选股。自己的钱买了股票后，股票天天都在变化，非常关心的很，特别是刚开始，都希望能涨涨涨，尽管不现实，不过赚钱的人还是有的。不过一打开股票软件，一千多只股票，红红绿绿，又是指数大盘，又是个股K线指标，一下又说基本面如何如何重要，一下又说什么有题材可以赚大钱，头晕眼花，迷茫困惑呀。  </p>
<a id="more"></a>
<p>特别是新股民在没有足够了解证券知识的情况下去炒股，基本是亏钱的。毕竟要学习的东西实在太多了，不具备这些知识就很难做好。这是有人就会想“要是有懂行的人帮帮忙就好了”。  </p>
<p>没错，确实有“人”能帮忙，那就是——基金。它就是你的帮手。它将投资者分散的资金集中起来，交给专业的人士进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者投资者所有，管理机构收取一定的托管管理费用。由于基金会买几十支好的股票，不会因为某个股票的大跌而影响收益，尽管每个人的钱不多，但大家放在一起，反而容易达到好的投资效果。我们需要做的只是选对基金与基金管理人！  </p>
<p>但是自己做股票就不一样了，承担的风险就变大了。因为我们需要自己去了解股票的各种信息，需要预测它的未来，还要买入和卖出，非专业人士是很难做到的。专业的基金经理人相对专业，所以不容易像散户那么盲目。  </p>
<p>大家想想，投资者买股票，做不好的原因是什么？这和我们软件开发中的什么类似？而投资者去买基金，基金经理人用这些钱做投资，然后大家获利，又体现了什么？  </p>
<p><strong>耦合性过高</strong>，由于投资者对众多股票的联系太多，反而不利于操作，这在软件中是不是就称为<strong>耦合性过高</strong>。而有了基金以后，变成用户只需要和基金打交道，关心基金的上涨和下跌就够了，而实际上的操作是基金经理人在与上千只股票和其他投资品打交道。  </p>
<p>回到正题，我之所以讲这么多股票与基金的东西，其实是因为这里提到了一个在面向对象开发当中用的非常多的一个设计模式——外观模式(Facade Pattern)。  </p>
<p>为了讲清它，我们先试着把股民炒股票的代码写出来。<br><strong>股民炒股代码</strong><br>代码结构图<br><img src="/blog/img/2020/01/09/股民炒股结构图.png"><br>具体股票、国债、房产类  </p>
<pre><code>//股票1
public class Stock1 {
    //卖股票
    public void sell(){
        System.out.println(&quot;卖出股票&quot;);
    }
    //买股票
    public void buy(){
        System.out.println(&quot;买入股票&quot;);
    }
}
//股票2
class Stock2 {
    //代码类似股票1，略
}
//股票3
class Stock3 {
    //代码类似股票1，略
}
//国债1
class NationalDebt1{
    //代码类似股票1，略
}
//房地产1
class Realty1{
    //代码类似股票1，略
}</code></pre><p>客户端调用  </p>
<pre><code>public static void main(String[] args) {
    Stock1 gu1 = new Stock1();
    Stock2 gu2 = new Stock2();
    Stock3 gu3 = new Stock3();
    NationalDebt1 nd1 = new NationalDebt1();
    Realty1 rt1 = new Realty1();

    //用户需要了解股票、国债、房产情况，需要参与这些项目的具体买和卖。耦合性很高。
    gu1.buy();
    gu2.buy();
    gu3.buy();
    nd1.buy();
    rt1.buy();

    gu1.sell();
    gu2.sell();
    gu3.sell();
    nd1.sell();
    rt1.sell();
}</code></pre><p><strong>那么我们现在增加基金类代码，又该如何做？</strong><br>代码结构图<br><img src="/blog/img/2020/01/09/基金结构图.png"><br>基金类如下  </p>
<pre><code>//基金类
public class Fund {
    Stock1 gu1;
    Stock2 gu2;
    Stock3 gu3;
    NationalDebt1 nd1;
    Realty1 rt1;

    public Fund(){
         gu1 = new Stock1();
         gu2 = new Stock2();
         gu3 = new Stock3();
         nd1 = new NationalDebt1();
         rt1 = new Realty1();
    }

    public void buyFund(){
        gu1.buy();
        gu2.buy();
        gu3.buy();
        nd1.buy();
        rt1.buy();
    }

    public void sellFund(){
        gu1.sell();
        gu2.sell();
        gu3.sell();
        nd1.sell();
        rt1.sell();
    }
}</code></pre><p>客户端调用  </p>
<pre><code>public static void main(String[] args) {
    Fund jijin = new Fund();
    //基金购买
    jijin.buyFund();
    //基金赎回
    jijin.sellFund();
    //此时用户不需要了解股票，甚至可以对股票一无所知，所以买了基金就回家睡觉，一段时间后在赎回就可以大把数钱。
    //参与股票的具体买卖都由基金公司完成。客户端的代码就非常简洁明了
}</code></pre><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式又称门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计属于结构型模型，它向现有的系统添加一个接口，来隐藏系统的复杂性。<br>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>为子系统的一组接口提供一个一致的界面，外观模式定义了一个高层结构，这个接口使得这一子系统更加容易使用。<br><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。<br><strong>何时使用：</strong>1、客户端不需要知道系统内部的复杂联系，整个系统只需要提供一个”接待员”即可。2、定义系统的入口。<br><strong>如何解决：</strong>客户端不与系统耦合，外观类与系统耦合。<br><strong>关键代码：</strong>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。<br><strong>应用实例：</strong>1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。2、JAVA的三层开发模式。<br><strong>优点：</strong>1、减少系统相互依赖。2、提高灵活性 。3、提高了安全性。<br><strong>缺点：</strong>不符合开闭原则，如果需要改东西很麻烦，继承重写都不合适。<br><strong>使用场景：</strong>1、为复杂的模块或子系统提供外界访问的模块。2、子系统相对独立。3、预防低水平人员带来的风险。<br><strong>注意事项：</strong>在层次化结构中，可以使用外观模式定义系统中每一层的入口。 </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><h3 id="2-1-UML类图"><a href="#2-1-UML类图" class="headerlink" title="2.1 UML类图"></a>2.1 UML类图</h3><img src="/blog/img/2020/01/09/外观模式结构图.png">   

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>四个子系统的类  </p>
<pre><code>public class SubSystemOne {
    public void methodOne(){
        System.out.println(&quot;子系统方法一&quot;);
    }
}
class SubSystemTwo {
    public void methodTwo(){
        System.out.println(&quot;子系统方法二&quot;);
    }
}
class SubSystemThree {
    public void methodThree(){
        System.out.println(&quot;子系统方法三&quot;);
    }
}
class SubSystemFour {
    public void methodFour(){
        System.out.println(&quot;子系统方法四&quot;);
    }
}</code></pre><p>外观类  </p>
<pre><code>//外观类，它需要了解所有的子系统的方法和属性，进行组合，以备外界调用
public class Facade {
    SubSystemOne one;
    SubSystemTwo two;
    SubSystemThree three;
    SubSystemFour four;

    public Facade(){
        one = new SubSystemOne();
        two = new SubSystemTwo();
        three = new SubSystemThree();
        four = new SubSystemFour();
    }

    public void methodA(){
        System.out.println(&quot;方法组A() ----&quot;);
        one.methodOne();
        two.methodTwo();
        four.methodFour();
    }
    public void methodB(){
        System.out.println(&quot;方法组B() ----&quot;);
        two.methodTwo();
        three.methodThree();
    }
}</code></pre><p>客户端调用  </p>
<pre><code>public class Client {
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.methodA();
        facade.methodB();
        //由于facade的作用，客户端可以根本不知3个子系统类的存在
    }
}</code></pre><p>对于面向对象有一定基础的朋友，即使没听过外观模式，也完全有可能在很多时候使用它，外观模式很完美的体现了依赖倒转原则和迪米特法则（最少知道原则）的思想，所以是非常常用的模式之一。  </p>
<h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/facade-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/facade-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>排序算法之鸡尾酒排序</title>
    <url>/blog/2020/01/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>冒泡排序的每一个元素都可以像小气泡一样，根据自身的大小，一点一点地向着数组一侧移动。算法的每一轮都是<strong>从左到右来比较元素，进行单向的位置交换。</strong><br>那么鸡尾酒排序做了怎样的优化呢？<br>鸡尾酒排序的元素比较和交换过程是<strong>双向</strong>的。  </p>
<a id="more"></a>   
<p>现有一个无序数列{2,3,4,5,6,7,8,1}，希望对其进行从小到大的排序。<br>让我来看下鸡尾酒排序的详细过程。<br><strong>第1轮（和冒泡排序一样，8和1交换）</strong><br><img src="/blog/img/2020/01/09/鸡尾酒排序1.png"><br><br><strong>第2轮</strong><br>此时开始不一样了，我们反过来<strong>从右往左</strong>比较进行交换。<br><img src="/blog/img/2020/01/09/鸡尾酒排序2.png"><br><br><strong>第3轮（虽然实际上已经有序，但是流程并没有结束）</strong><br>在鸡尾酒排序的第3轮，需要重新<strong>从左向右</strong>比较并进行交换。<br>1和2比较，位置不变；2和3比较，位置不变……6和7比较，位置不变。<br>没有元素进行位置交换，证明已经有序，排序结束。<br>这就是鸡尾酒排序的思路。排序过程就像摆钟一样，第1轮从左向右，第2轮从右向左，第3轮从左向右…..。</p>
<p>代码示例  </p>
<pre><code>public static void sort(int[] arr){
    int tmp = 0;
    for (int i = 0; i &lt; arr.length/2; i++) {
        //有序标记，每一轮的初始值都是true
        boolean isSorted = true;
        //奇数轮，从左向右比较交换
        for (int j = i; j &lt; arr.length-i-1; j++) {
            if(arr[j+1]&lt;arr[j]){
                tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
                //如果有值交换，所以不是有序的，标记为false
                isSorted = false;
            }
        }
        if(isSorted){
            break;
        }
        //在偶数轮之前，将isSorted重新标记为true
        isSorted = true;
        //偶数轮，从右向左开始交换  arr.length-i-2 = arr.length-1-(i+1)
        for (int j = arr.length-i-2; j &gt; i; j--) {
            if(arr[j]&lt;arr[j-1]){
                tmp = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = tmp;
                //如果有值交换，所以不是有序的，标记为false
                isSorted = false;
            }
        }
        if(isSorted){
            break;
        }
    }
}</code></pre><p>PS:之前将冒泡排序时，有一种针对有序区的优化，鸡尾酒排序能否能用到呢？<br>答案：可以！<br>具体代码示例  </p>
<pre><code>public static void sort(int[] arr){
    int tmp = 0;
    //有序边界
    int sortBorder = arr.length-1;
    //最后一次元素交换的位置
    int pos = 0;
    for (int i = 0; i &lt; arr.length/2; i++) {
        //有序标记，每一轮的初始值都是true
        boolean isSorted = true;
        //奇数轮，从左向右比较交换
        for (int j = i; j &lt; sortBorder; j++) {
            if(arr[j+1]&lt;arr[j]){
                tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
                //如果有值交换，所以不是有序的，标记为false
                isSorted = false;
                //把无序数列的边界更新为最后一次交换元素的位置
                pos = j;
            }
        }
        if(isSorted){
            break;
        }
        //下一次比较到记录位置即可
        sortBorder = pos;
        //在偶数轮之前，将isSorted重新标记为true
        isSorted = true;
        //偶数轮，从右向左开始交换
        for (int j = sortBorder; j &gt; i; j--) {
            if(arr[j]&lt;arr[j-1]){
                tmp = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = tmp;
                //如果有值交换，所以不是有序的，标记为false
                isSorted = false;
            }
        }
        if(isSorted){
            break;
        }
    }
}</code></pre><p>鸡尾酒排序的优点与缺点：<br>优点：能够在特定条件下，减少排序的回合数；<br>缺点：代码量几乎增加了一倍。  </p>
<p>使用场景：<strong>大部分元素已经有序</strong>的情况。</p>
]]></content>
  </entry>
  <entry>
    <title>排序算法之冒泡排序</title>
    <url>/blog/2020/01/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>冒泡排序的英文名是<strong>bubble sort</strong>，它是一种基础的<strong>交换排序</strong>。  
大家都喝过汽水，汽水中常常有许多小小的气泡哗啦哗啦飘到上面来。这是因为组成小气泡的二氧化碳比水轻，所以小气泡可以一点一点的向上浮动。<br>冒泡排序之所以叫冒泡排序，正是因为这种排序算法的每一个元素都可以向小气泡一样，根据自身大小，一点一点的向着数组的一侧移动。<br>按照冒泡排序的思想，我们要<strong>把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换他们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。</strong></p>
<a id="more"></a>
<p>例如有一个由8个数字组成的无序数列{5,8,6,3,9,2,1,7}，希望按从小到大的顺序对其排序。<br>详细步骤如下：<br><img src="/blog/img/2020/01/08/冒泡排序1.png"><br><br>这样一来，元素9最为最大的元素，就像汽水一样”漂”到了最右侧。当然这只是第一轮排序结束了。数列最右侧元素9的位置可以认为是一个有序区域，有序区域目前只有1个元素。  </p>
<p>接下来我们进行第2轮排序。<br><img src="/blog/img/2020/01/08/冒泡排序2.png"><br><br>后续的交换细节，不详细描述了，第3轮到第7轮的状态如下。<br><img src="/blog/img/2020/01/08/冒泡排序3.png"><br><br>至此为止，所有元素都是有序的了，这就是冒泡排序的整体思路。<br>冒泡排序是一种<strong>稳定排序</strong>，值相等的元素并不会打乱原本的顺序。由于该排序算法的每一轮都要遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂度是O(n<sup>2</sup>)。  </p>
<p><strong>冒泡排序第1版</strong>代码示例如下：  </p>
<pre><code>public class BubbleSort {

    public static void sort(int[] arr){
        for (int i = 0; i &lt; arr.length-1; i++) {
            for (int j = 0; j &lt; arr.length-i-1; j++) {
                int temp = 0;
                if(arr[j]&gt;arr[j+1]){
                    temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[]{5,8,6,3,9,2,1,7};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

}</code></pre><p>代码非常简单，使用双循环进行排序。外循环控制所有的回合，内部循环实现每一轮的冒泡处理，先进行元素比较，在进行元素交换。  </p>
<p><strong>冒泡排序的优化</strong>  </p>
<p><img src="/blog/img/2020/01/08/冒泡排序优化1.png"><br><br>从上图可以看出，很明显经过第6轮排序后，整个数列已经是有序的了。可是排序算法仍然兢兢业业地继续执行了第7轮排序。<br>在这种情况下，如果能判断出数列已经有序，并做出标记，那么剩下的几轮排序就不必执行了，可以提前结束工作。  </p>
<p><strong>冒泡排序第2版</strong>代码示例如下：  </p>
<pre><code>public static void sort(int[] arr){
    for (int i = 0; i &lt; arr.length-1; i++) {
        //有序标记，每一轮初始值都是true
        boolean isSorted = true;
        for (int j = 0; j &lt; arr.length-i-1; j++) {
            int temp = 0;
            if(arr[j]&gt;arr[j+1]){
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                //如果有值交换，所以不是有序的，标记为false
                isSorted = false;
            }
        }
        if(isSorted){
            break;
        }
    }
}</code></pre><p><strong>这只是冒泡排序的优化的第一步，我们还可以进一步来提升它的性能。</strong><br>为了说明这个问题，这次以一个新的数列为例。<br><img src="/blog/img/2020/01/08/冒泡排序优化2.png"><br><br>这个数列的特点是前半部分元素（3、4、2、1）无序，后半部分元素（5、6、7、8）按升序排列，并且后半部分元素中的最小值也大于前半部分元素的最大值。<br>下面按照冒泡排序的思路来进行排序，看一看具体效果。<br><strong>第1轮</strong><br><img src="/blog/img/2020/01/08/冒泡排序优化3.png"><br><br>元素4和5比较，发现4小于5，所以位置不变。<br>…..<br>元素7和8比较，发现7小于8，所以位置不变。<br>第1轮结束，数列有序区包含1个元素。<br><img src="/blog/img/2020/01/08/冒泡排序优化4.png"><br><br><strong>第2轮</strong><br>元素3和2比较，发现3大于2，所以3和2交换。<br><img src="/blog/img/2020/01/08/冒泡排序优化5.png"><br><br>元素3和4比较，发现3小于4，所以位置不变。<br>……<br>元素6和7比较，发现6小于7，所以位置不变。<br>第2轮结束，数列的有序区包含2个元素。<br><img src="/blog/img/2020/01/08/冒泡排序优化6.png"><br><br>到这里你就会发现，其实右面的许多元素已经是有序的了，可是每一轮还是白白地比较了许多次。<br><strong>这个问题的关键点在于对数列有序区的界定。</strong><br>按照现有的逻辑，有序区的长度和排序的轮数是相等的。例如第1轮排序过后的有序区长度1，第2轮排序过后的有序区长度是2…..<br>实际上，数列真正的有序区可能会大于这个长度，如上述例子中在第2轮排序时，后面5个元素实际上都已经属于排序区了。后面很多元素的比较都是没有意义的。<br>那么，该如何避免这种情况呢？我们可以在每一轮排序后，记录下来最后一次元素交换的位置，该位置即为无序数列的边界，再往后就是有序区了。  </p>
<p><strong>冒泡排序第3版</strong>代码示例如下：  </p>
<pre><code>public static void sort(int[] arr){
    //最后一个交换位置元素的下标
    int pos=0;
    //无序数列的边界，每次比较只需要比到这里为止
    int sortBoder = arr.length-1;
    for (int i = 0; i &lt; arr.length-1; i++) {
        //有序标记，每一轮初始值都是true
        boolean isSorted = true;
        for (int j = 0; j &lt; sortBoder; j++) {
            int temp = 0;
            if(arr[j]&gt;arr[j+1]){
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                //如果有值交换，所以不是有序的，标记为false
                isSorted = false;
                //把无序数列的边界更新为最后一次交换元素的位置
                pos = j;
            }
        }
        if(isSorted){
            break;
        }
        sortBoder = pos;//下一次比较到记录位置即可
    }
}    </code></pre><p>其实这仍然不是最优的，还有一种排序算法叫做<strong><a href="/blog/2020/01/08/排序算法之鸡尾酒排序/" target="_blank">鸡尾酒排序</a></strong>，是基于冒泡排序的一种升级排序法。</p>
]]></content>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/blog/2020/01/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>按时间复杂度的不同，主流的排序算法可分为3大类。  </p>
<a id="more"></a>
<p><strong>1.时间复杂度为O(n<sup>2</sup>)的排序算法</strong>  </p>
<ul>
<li><a href="/blog/2020/01/08/排序算法之冒泡排序/" target="_blank">冒泡排序</a>  </li>
<li><a href="/blog/2020/02/10/排序算法之选择排序/" target="_blank">选择排序</a>  </li>
<li><a href="/blog/2020/02/12/排序算法之插入排序/" target="_blank">插入排序</a>  </li>
<li><a href="/blog/2020/02/18/排序算法之希尔排序/" target="_blank">希尔排序</a>(希尔排序比较特殊，它的性能略优于O(n<sup>2</sup>)，但又比不上O(logn),暂且把它归入本类)  </li>
</ul>
<p><strong>2.时间复杂度为O(nlogn)的排序算法</strong>  </p>
<ul>
<li><a href="/blog/2020/02/18/排序算法之快速排序/" target="_blank">快速排序</a>  </li>
<li><a href="/blog/2020/02/21/排序算法之归并排序/" target="_blank">归并排序</a>  </li>
<li><a href="/blog/2020/02/21/排序算法之堆排序/" target="_blank">堆排序</a> </li>
</ul>
<p><strong>3.时间复杂度为线性的排序算法</strong>  </p>
<ul>
<li><a href="/blog/2020/02/22/排序算法之计数排序/" target="_blank">计数排序</a>  </li>
<li><a href="/blog/2020/02/22/排序算法之桶排序/" target="_blank">桶排序</a>  </li>
<li><a href="/blog/2020/02/22/排序算法之基数排序/" target="_blank">基数排序</a> </li>
</ul>
<p>以上列举的只是最主流的排序算法，在算法界还存在着更多的五花八门的排序，它们有些基于传统排序变形而来；有些则是脑洞大开，如鸡尾酒排序、猴子排序、睡眠排序等。<br>此外，排序算法还可以根据其稳定性，划分为<strong>稳定排序</strong>和<strong>不稳定排序</strong>。   </p>
<p><strong>稳定排序：</strong>  即如果值相同的元素在排序后仍让保持着排序前的顺序。<br><strong>不稳定排序：</strong>即值相同的的元素在排序后打乱了排序前的顺序。<br><img src="/blog/img/2020/01/08/稳定排序与不稳定排序.png"><br><br>大多数情况下，值相同的元素谁先谁后是无所谓的。但是在某些场景下，值相同的元素必须保持原有的顺序。  </p>
]]></content>
  </entry>
  <entry>
    <title>优先队列</title>
    <url>/blog/2020/01/06/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>首先我们可以知道一点，队列的特点是<strong>先进先出(FIFO)</strong>。入队时，新元素置于队尾；出队时，队头元素先被移出。<br>但优先队列不再遵循先入先出的原则，而是分为两种情况。<br><strong>最大优先队列，无论入队顺序如何，都是当前最大元素优先出队</strong><br><strong>最小优先队列，无论入队顺序如何，都是当前最小元素优先出队</strong>  </p>
<a id="more"></a>  
<p>例如有一个最大优先队列，其中的最大元素是8，那么虽然8不是队头元素，但出队时仍让元素8首先出队。<br>要实现以上需求，利用线性数据结构也能实现，但是时间复杂度较高。  </p>
<p>我们知道二叉树有以下特点：<br><strong>1.最大堆的堆顶是整个堆中的最大元素。</strong><br><strong>2.最小堆的堆顶是整个堆中的最小元素。</strong><br>那么，我们可以利用最大堆来实现最大优先队列，这样的话，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。<br><strong>入队操作</strong>具体步骤如下。<br>1.插入新节点5。<br><img src="/blog/img/2020/01/06/入队操作1.png"><br><br>2.新节点5“上浮”到合适的位置。<br><img src="/blog/img/2020/01/06/入队操作2.png"><br>  </p>
<p><strong>出队操作</strong>具体步骤如下。<br>1.让堆顶原节点10出队。<br><img src="/blog/img/2020/01/06/出队操作1.png"><br><br>2.把最后一个节点1替换到堆顶位置。<br><img src="/blog/img/2020/01/06/出队操作2.png"><br><br>3.节点1“下沉”，节点9称为新堆顶。<br><img src="/blog/img/2020/01/06/出队操作3.png"><br>  </p>
<p><strong>PS:二叉堆节点“上浮”和“下沉”的时间复杂度都是O(logn)，因此优先队列的入队和出队的时间复杂度也是O(logn)</strong>。  </p>
<p>代码示例  </p>
<pre><code>public class PriorityQueue {

    private int[] arr;
    private int size;
    public PriorityQueue(){
        //初始化队列长度为32
        arr = new int[32];
    }

    /**
     * 入队操作
     * @param element 入队元素
     */
    public void enqueue(int element){
        //超过队列长度
        if(size&gt;=arr.length){
            //扩容
            resize();
        }
        arr[size++]=element;
        //&quot;上浮&quot;操作
        upAdjust();
    }

    /**
     * 出队
     * @return 出队元素
     */
    public int dequeue()throws Exception{
        if(size&lt;=0){
            throw new Exception(&quot;the queue is empty!&quot;);
        }
        //获取堆顶元素
        int head = arr[0];
        //将最后一个元素移动到堆顶
        arr[0] = arr[--size];
        //&quot;下沉&quot;操作
        downAdjust();
        return head;
    }

    /**
     *&quot;上浮&quot;调整
     */
    public void upAdjust() {
        int childIndex = size-1;
        int parentIndex = (childIndex-1)/2;
        //临时保存插入的叶子节点的值，用于最后的赋值
        int temp = arr[childIndex];
        while(childIndex&gt;0 &amp;&amp; temp&gt;arr[parentIndex]){
            //无须真正交换，单向赋值即可
            arr[childIndex] = arr[parentIndex];
            childIndex = parentIndex;
            parentIndex = (childIndex-1)/2;
        }
        arr[childIndex] = temp;
    }

    /**
     * &quot;下沉&quot;操作
     */
    public void downAdjust() {
        int parentIndex = 0;
        //临时保存父节点的值，用于最后的赋值
        int temp = arr[parentIndex];
        int childIndex = parentIndex*2+1;
        while(childIndex&lt;size){
            //如果存在右孩子，并且右孩子的值大于左孩子的值，则定位到右孩子
            if(childIndex+1&lt;size &amp;&amp; arr[childIndex+1]&gt;arr[childIndex]){
                childIndex++;
            }
            //如果父节点的值大于任何一个孩子节点的值，直接跳出循环
            if(temp&gt;=arr[childIndex]){
                break;
            }
            //无须真正交换，单向赋值即可
            arr[parentIndex] = arr[childIndex];
            parentIndex = childIndex;
            childIndex = parentIndex*2+1;
        }
        arr[parentIndex] = temp;
    }

    public void output(){
        for (int i = 0; i &lt; size; i++) {
            System.out.print(arr[i]+&quot; &quot;);
        }
        System.out.println();
    }

    /**
     * 扩容操作
     */
    private void resize() {
        //数组容量翻倍
        int maxSize = arr.length*2;
        arr = Arrays.copyOf(arr, maxSize);
    }

    public static void main(String[] args) throws Exception {
        PriorityQueue queue = new PriorityQueue();
        queue.enqueue(3);
        queue.enqueue(5);
        queue.enqueue(10);
        queue.enqueue(2);
        queue.enqueue(7);
        queue.output();
        System.out.println(&quot;出队元素：&quot;+queue.dequeue());
        queue.output();
        System.out.println(&quot;出队元素：&quot;+queue.dequeue());
        queue.output();
    }
}</code></pre>]]></content>
  </entry>
  <entry>
    <title>二叉堆</title>
    <url>/blog/2020/01/03/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    <content><![CDATA[<h2 id="1-什么是二叉堆？"><a href="#1-什么是二叉堆？" class="headerlink" title="1.什么是二叉堆？"></a>1.什么是二叉堆？</h2><p>二叉堆本质上是一种完全二叉树，它分为两个类型：<br><strong>1.最大堆</strong><br><strong>2.最小堆</strong>  </p>
<a id="more"></a> 
<p>什么是最大堆呢？最大堆的任何一个父节点的值，都<strong>大于或等于</strong>它左、右孩子节点的值。<br><img src="/blog/img/2020/01/03/最大堆.png"><br><br>什么是最小堆呢？最小堆的任何一个父节点的值，都<strong>小于或等于</strong>它左、右孩子节点的值。<br><img src="/blog/img/2020/01/03/最小堆.png"><br><br>二叉堆的根节点叫<strong>堆顶</strong>。  
最大堆和最小堆的特点决定了：最大堆的堆顶是整个堆中的<strong>最大元素</strong>；最小堆的堆顶是整个堆中的<strong>最小元素</strong>。  </p>
<h2 id="2-二叉堆的自我调整"><a href="#2-二叉堆的自我调整" class="headerlink" title="2.二叉堆的自我调整"></a>2.二叉堆的自我调整</h2><p>对于二叉堆，有如下几种操作。<br><strong>1.插入节点</strong><br><strong>2.删除节点</strong><br><strong>3.构建二叉堆</strong><br>这几种操作都基于堆的自我调整。所谓堆的自我调整，就是把一个不符合堆性质的完全二叉树，调整成一个堆。下面以最小堆为例，看一看二叉堆是如何进行自我调整的。  </p>
<h3 id="2-1-插入节点"><a href="#2-1-插入节点" class="headerlink" title="2.1 插入节点"></a>2.1 插入节点</h3><p>当二叉堆插入节点时，插入位置时完全二叉堆树的最后一个位置。例如插入一个新节点，值是0。<br><img src="/blog/img/2020/01/03/最小堆插入步骤1.png"><br><br>这时，新节点的父节点5比0大，显然不符合最小堆的性质，于是让新节点“上浮”和父节点交换位置。<br><img src="/blog/img/2020/01/03/最小堆插入步骤2.png"><br><br>同理，新节点继续上浮。<br><img src="/blog/img/2020/01/03/最小堆插入步骤3.png"><br><br>继续比较，最终新节点0“上浮”到了堆顶的位置。<br><img src="/blog/img/2020/01/03/最小堆插入步骤4.png"><br>   </p>
<h3 id="2-2-删除节点"><a href="#2-2-删除节点" class="headerlink" title="2.2 删除节点"></a>2.2 删除节点</h3><p>二叉堆删除节点过程和插入节点过程正好相反，所删除的是处于堆顶的节点，例如删除最小堆的堆顶节点1。<br><img src="/blog/img/2020/01/03/最小堆删除节点1.png"><br><br>这时为了维持完全二叉树的结构，我们把堆的最后一个元素10临时补偿到原本堆顶的位置。<br><img src="/blog/img/2020/01/03/最小堆删除节点2.png"><br><br>接下来，让暂处堆顶位置的节点10和它的左、右进行比较，如果左、右孩子中最小的一个（显然是节点2）比节点10小，那么让节点10“下沉”。<br><img src="/blog/img/2020/01/03/最小堆删除节点3.png"><br><br>同理，节点10继续“下沉”。<br><img src="/blog/img/2020/01/03/最小堆删除节点4.png"><br><br>这样一来二叉堆就得到了调整。  </p>
<h3 id="2-3-构建二叉堆"><a href="#2-3-构建二叉堆" class="headerlink" title="2.3 构建二叉堆"></a>2.3 构建二叉堆</h3><p>构件二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质就是让<strong>所有非叶子节点依次“下沉”</strong>。  
下面是一个无序完全二叉树的例子，如下图所示。<br><img src="/blog/img/2020/01/03/构建二叉堆1.png"><br><br>首先从最后一个非叶子节点开始，也就是节点10开始。如果节点10大于它左、右孩子节点中最小的一个，则节点10“下沉”。<br><img src="/blog/img/2020/01/03/构建二叉堆2.png"><br><br>接下来轮到节点3，如果节点3大于它左、右孩子节点中最小的一个，则节点3“下沉”。<br><img src="/blog/img/2020/01/03/构建二叉堆3.png"><br><br>然后轮到节点1，如果节点1大于它左、右孩子节点中最小的一个，则节点1“下沉”。事实上节点1小于它的左、右孩子，所以不用改变。<br>同理轮到节点7时，节点7需要“下沉”。<br><img src="/blog/img/2020/01/03/构建二叉堆4.png"><br><br>节点7继续比较，继续“下沉”。<br><img src="/blog/img/2020/01/03/构建二叉堆5.png"><br><br>经过上述几轮比较和“下沉”操作，最终每一节都小于它的左、右孩子节点，一个无序的完全二叉堆就被构建成了一个最小堆。  </p>
<p><strong>PS:堆的插入操作是单一节点的“上浮”，堆的删除操作是单一节点的“下沉”，这两个操作的平均交换次数都是堆高度的一半，所以时间复杂度是O(logn)。但是构建堆的时间复杂度是O(n)。</strong>  </p>
<h2 id="3-二叉堆的代码实现"><a href="#3-二叉堆的代码实现" class="headerlink" title="3.二叉堆的代码实现"></a>3.二叉堆的代码实现</h2><p>在展示代码前，我们需要注意一点：二叉堆虽然是一个完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。也就是二叉堆的所有节点都存储在数组中。<br><img src="/blog/img/2020/01/03/二叉堆在数组中的存储方式.png"><br><br>假设父节点的下标是parent，那么它的左孩子节点下标就是<strong>2xparent+1</strong>；右孩子节点下标就是<strong>2xparent+2</strong>。  
上面的例子中节点6包含节点9和节点10两个孩子节点。其中节点6在数组中的小标为3，那么节点9在数组中的下标是7(7=3x2+1)，节点10在数组中的下标是8(8=3x2+2)。  </p>
<p>代码实例  </p>
<pre><code>/**
 * &quot;上浮&quot;操作
 * @param array 待调整的堆
 */
public static void upAdjust(int[] array){
    int childIndex = array.length-1;
    int parentIndex = (childIndex-1)/2;
    //临时保存插入的叶子节点的值，用于最后的赋值
    int temp = array[childIndex];
    while(childIndex&gt;0 &amp;&amp; temp&lt;array[parentIndex]){
        //无须真正交换，单向赋值即可
        array[childIndex]=array[parentIndex];
        childIndex = parentIndex;
        parentIndex = (childIndex-1)/2;
    }
    array[childIndex] = temp;
    System.out.println(Arrays.toString(array));
}

/**
 * 删除节点
 * @param array 待调整的堆
 * @param parentIndex 要删除的节点位置
 */
public static void deleteElementAdjust(int[] array,int parentIndex)throws Exception{
    if(parentIndex&lt;0 || parentIndex&gt;=array.length){
        throw new Exception(&quot;数组下标越界&quot;);
    }
    //把最后一个元素，临时补充到最后被删除节点位置
    array[parentIndex] = array[array.length-1];
    int[] newArray = new int[array.length-1];
    System.arraycopy(array, 0, newArray, 0, array.length-1);
    downAdjust(newArray,0,newArray.length);
    System.out.println(Arrays.toString(newArray));
}

/**
 * &quot;下沉&quot;操作
 * @param array 待调整的堆
 * @param parentIndex 要&quot;下沉&quot;父节点
 * @param length 堆的有效大小
 */
public static void downAdjust(int[] array,int parentIndex,int length){
    //临时保存父节点的值，用于最后的赋值
    int temp = array[parentIndex];
    int childIndex = parentIndex*2+1;
    while(childIndex&lt;array.length){
        //如果存在右孩子，且右孩子小于左孩子的值，则定位到右孩子
        if(childIndex+1&lt;array.length &amp;&amp; array[childIndex+1]&lt;array[childIndex]){
            childIndex++;
        }
        //如果父节点小于左、右孩子的值，直接跳出循环
        if(temp&lt;array[childIndex]){
            break;
        }
        //无须真正交换，单向赋值
        array[parentIndex]=array[childIndex];
        parentIndex = childIndex;
        childIndex = parentIndex*2+1;
    }
    array[parentIndex] = temp;
}

/**
 * 构建堆
 * @param array 待调整的堆
 */
public static void buildHeap(int[] array){
    for(int i = (array.length-2)/2;i&gt;=0;i--){
        downAdjust(array,i,array.length);
    }
    System.out.println(Arrays.toString(array));
}

public static void main(String[] args) throws Exception {
    //插入节点
    int[] array = new int[]{1,3,2,6,5,7,8,9,10,0};
    upAdjust(array);
    //删除节点
    array = new int[]{1,3,2,6,5,7,8,9,10};
    deleteElementAdjust(array,0);
    //构建二叉堆
    array = new int[]{7,1,3,10,5,2,8,9,6};
    buildHeap(array);
}</code></pre><p>代码中有一个优化的点，就是在父节点和孩子节点做连续交换时，并不一定真的要交换，只需要把交换一方的值存入temp变量，做单向覆盖，循环结束后，再把temp的值存入交换后的最终位置即可。  </p>
<p><strong>PS:二叉堆是实现</strong><a href="/blog/2020/01/06/堆排序/" target="_blank">堆排序</a><strong>及</strong><a href="/blog/2020/01/06/优先队列/" target="_blank">优先队列</a><strong>的基础。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/blog/2019/12/31/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>在计算机中，遍历本身是一个线性操作。所以遍历同样具有线性结构的数组或链表，是一件轻而易举的事情。反观二叉树，是典型的非线性数据结构，遍历时需要把非线性关联的节点转化成一个线性序列，以不同的方式来遍历，遍历出的序列顺序也不同。  </p>
<a id="more"></a>
<p>从节点之间的位置关系的角度来看，二叉树的遍历分为4种。<br><strong>1.前序遍历</strong><br><strong>2.中序遍历</strong><br><strong>3.后序遍历</strong><br><strong>4.层序遍历</strong><br>从更宏观的角度来看，二叉树的遍历归结为两大类。<br><strong>1.深度优先遍历（前序遍历、中序遍历、后序遍历）</strong><br><strong>1.广度优先遍历（层序遍历）</strong>  </p>
<h2 id="1-深度优先遍历"><a href="#1-深度优先遍历" class="headerlink" title="1.深度优先遍历"></a>1.深度优先遍历</h2><p>深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或其他一些复杂数据结构时，这两个概念经常被用到。<br>所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底”的访问方式。可能这些说法有些抽象，下面通过二叉树的<strong>前序遍历、中序遍历、后续遍历</strong>，来看一看深度优先是怎么回事吧。  </p>
<ul>
<li><strong>前序遍历</strong></li>
</ul>
<p>二叉树的前序遍历，输出顺序是根节点、左子树、右子树。<br><img src="/blog/img/2020/01/02/前序遍历.png"><br><br>上图就是一个二叉树的前序遍历，每个节点左侧的序号代表该节点的顺序，详细步骤如下。<br>1.首先输出的是根节点1。<br>2.由于根节点1存在左孩子，输出左孩子节点2。<br>3.由于节点2也存在左孩子，输出左孩子节点4。<br>4.节点4既没有左孩子，也没有右孩子，那么回到节点2，输出节点2的右孩子节点5。<br>5.节点5既没有左孩子也没有右孩子，那么回到节点1，输出节点1的右孩子节点3。<br>6.节点3没有左孩子但是有右孩子，因此输出节点3的右孩子节点6。   </p>
<ul>
<li><strong>中序遍历</strong></li>
</ul>
<p>二叉树的前序遍历，输出顺序是左子树、根节点、右子树。<br><img src="/blog/img/2020/01/02/中序遍历.png"><br><br>上图就是一个二叉树的中序遍历，每个节点左侧的序号代表该节点的顺序，详细步骤如下。<br>1.首先访问根节点的左孩子，如果这个左孩子还拥有左孩子，则继续深入访问下去，一直找到不再有左孩子的节点，并输出该节点。显然，第一个没有左孩子的节点是4。<br>2.依照中序遍历的次序，接下来输出节点4的父节点2。<br>3.在输出节点2的右孩子节点5。<br>4.以节点2为根的右子树已经输出完毕，这时在输出整个二叉树的根节点1。<br>5.由于节点3没有左孩子，所以直接输出根节点1的右孩子节点3。<br>6.最后输出节点3的右孩子节点6。   </p>
<ul>
<li><strong>后序遍历</strong></li>
</ul>
<p>二叉树的前序遍历，输出顺序是左子树、右子树、根节点。<br><img src="/blog/img/2020/01/02/后序遍历.png"><br><br>上图就是一个二叉树的后序遍历，每个节点左侧的序号代表该节点的顺序，详细步骤略。  </p>
<p><strong>前序遍历、中序遍历、后序遍历的代码展示，二叉树的这3种遍历方式，用递归的思路可以非常简单的实现出来。</strong>  </p>
<pre><code>import java.util.Arrays;
import java.util.LinkedList;

public class Traversal {

    /**
     * 构建二叉树
     * @param inputList 输入序列
     */
    public static TreeNode createBinary(LinkedList&lt;Integer&gt; inputList){
        TreeNode node = null;
        if(inputList == null || inputList.isEmpty()){
            return null;
        }
        Integer data = inputList.removeFirst();
        if(data!=null){
            node = new TreeNode(data);
            node.leftChild = createBinary(inputList);
            node.rightChild = createBinary(inputList);
        }
        return node; 
    }

    /**
     * 前序遍历
     * @param node 二叉树节点
     */
    public static void preOrderTraversal(TreeNode node){
        if(node == null){
            return;
        }
        System.out.print(node.data+&quot; &quot;);
        preOrderTraversal(node.leftChild);
        preOrderTraversal(node.rightChild);
    }

    /**
     * 中序遍历
     * @param node
     */
    public static void inOrderTraversal(TreeNode node){
        if(node == null){
            return;
        }
        inOrderTraversal(node.leftChild);
        System.out.print(node.data+&quot; &quot;);
        inOrderTraversal(node.rightChild);
    }

    /**
     * 后序遍历
     * @param node
     */
    public static void postOrderTraversal(TreeNode node){
        if(node == null){
            return;
        }
        postOrderTraversal(node.leftChild);
        postOrderTraversal(node.rightChild);
        System.out.print(node.data+&quot; &quot;);
    }

    /**
     * 二叉树节点
     */
    private static class TreeNode{
        int data;
        TreeNode leftChild;
        TreeNode rightChild;

        TreeNode(int data){
            this.data = data;
        }
    }

    public static void main(String[] args) {
        LinkedList&lt;Integer&gt; inputList = new LinkedList&lt;&gt;(Arrays.
                asList(new Integer[]{3,2,9,null,null,10,null,
                        null,8,null,4}));
        TreeNode treeNode = createBinary(inputList);
        System.out.print(&quot;前序遍历:&quot;);
        preOrderTraversal(treeNode);
        System.out.println();
        System.out.print(&quot;中序遍历:&quot;);
        inOrderTraversal(treeNode);
        System.out.println();
        System.out.print(&quot;后序遍历:&quot;);
        postOrderTraversal(treeNode);
    }
}</code></pre><p>输出结果  </p>
<pre><code>前序遍历:3 2 9 10 8 4 
中序遍历:9 2 10 3 8 4 
后序遍历:9 10 2 4 8 3 </code></pre><p>二叉树构建的方式有很多种，次例在代码的main函数中，通过{3,2,9,null,null,10,null,null,8,null,4}这样一个线性序列，构建的二叉树如下。<br><img src="/blog/img/2020/01/02/代码示例.png"><br>  </p>
<p><strong>非递归实现遍历（用数据结构 栈 实现），以前序遍历为例。</strong><br>1.首先遍历二叉树的节点1，放入栈中。<br><img src="/blog/img/2020/01/02/栈实现1.png"><br><br>2.遍历根节点1的左孩子节点2，放入栈中。<br><img src="/blog/img/2020/01/02/栈实现2.png"><br><br>3.遍历节点2的左孩子节点4，放入栈中。<br><img src="/blog/img/2020/01/02/栈实现3.png"><br><br>4.节点4既没有左孩子，也没有右孩子，我们需要回溯到上一个节点2。让旧的栈顶元素4出栈，就可以重新访问节点2，得到节点2的右孩子节点5。<br>此时节点2已经没有利用价值（已经访问过左孩子和右孩子），节点2出栈，节点5入栈。<br><img src="/blog/img/2020/01/02/栈实现4.png"><br><br>5.节点5既没有左孩子，也没有右孩子，再次回溯，一直回溯到节点1。所以让节点5出栈。<br>根节点1的右孩子是3，节点1出栈，节点3入栈。<br><img src="/blog/img/2020/01/02/栈实现5.png"><br><br>6.节点3的右孩子是节点6，节点3出栈，节点6入栈。<br><img src="/blog/img/2020/01/02/栈实现6.png"><br><br>7.节点6既没有左孩子，也没有右孩子，所以节点6出栈。此时栈为空，遍历结束。<br><img src="/blog/img/2020/01/02/栈实现7.png"><br> </p>
<p>代码实例  </p>
<pre><code>/**
 * 二叉树非递归前序遍历
 * @param root 根节点
 */
public static void preOrderTraversalStack(TreeNode root){
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode treeNode = root;
    while(treeNode != null || !stack.isEmpty()){
        //迭代访问节点的左孩子，并入栈
        while(treeNode != null){
            System.out.print(treeNode.data+&quot; &quot;);
            stack.push(treeNode);
            treeNode = treeNode.leftChild;
        }
        //如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子
        if(!stack.isEmpty()){
            treeNode = stack.pop();
            treeNode = treeNode.rightChild;
        }

    }
}</code></pre><p>中序遍历代码：  </p>
<pre><code>/**
 * 二叉树非递归中序遍历
 * @param root 根节点
 */
public static void inOrderTraversalStack(TreeNode root){
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode treeNode = root;
    while(treeNode != null || !stack.isEmpty()){
        //迭代访问节点的左孩子，并入栈
        while(treeNode != null){
            stack.push(treeNode);
            treeNode = treeNode.leftChild;
        }
        //如果节点没有左孩子，则弹出栈顶节点，输出栈顶，访问节点右孩子
        if(!stack.isEmpty()){
            treeNode = stack.pop();
            System.out.print(treeNode.data+&quot; &quot;);
            treeNode = treeNode.rightChild;
        }

    }
}</code></pre><p>后序遍历代码（略复杂）：<br>我的基本思路是这样的：<br>1.先把左孩子节点全部压入栈内；<br>2.弹出栈顶，判断是否有右孩子；<br>3.不存在的话，直接输出当前节点，有的话，则把当前被弹出节点再次压入栈顶，因为后续遍历是先输出左子树右子树，最后才是根节点，同时还需要保存记录起来，后续再次回到该节点时，直接输出即可，避免重复查找右子树操作。   </p>
<pre><code>/**
 * 二叉树非递归后序遍历
 * @param root 根节点
 */
public static void postOrderTraversalStack(TreeNode root){
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode treeNode = root;
    List&lt;TreeNode&gt; history = new ArrayList&lt;&gt;();//记录访问过并被重新压入进栈的节点
    while(treeNode != null || !stack.isEmpty()){
        //迭代访问节点的左孩子，并入栈
        while(treeNode != null){
            stack.push(treeNode);
            treeNode = treeNode.leftChild;
        }
        //如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子
        if(!stack.isEmpty()){
            TreeNode popTreeNode = stack.pop();
            if(history.size()&gt;0 &amp;&amp; history.contains(popTreeNode)){//判断当前弹出节点是否被第二次弹出，是的话直接输出结果
                System.out.print(popTreeNode.data+&quot; &quot;);
            }else{
                treeNode = popTreeNode.rightChild;
                if(treeNode != null){//判断被弹出节点是否存在右孩子，存在的话，把被弹出节点再次压入栈顶
                    stack.push(popTreeNode);
                    history.add(popTreeNode);
                }else{//被弹出节点不存在右孩子，输出结果
                    System.out.print(popTreeNode.data+&quot; &quot;);
                }
            }
        }

    }
}</code></pre><h2 id="2-广度优先遍历"><a href="#2-广度优先遍历" class="headerlink" title="2.广度优先遍历"></a>2.广度优先遍历</h2><p>如果说深度优先遍历是在一个方向上“一头扎到底”，那么广度优先遍历则恰恰相反；先在各个方向上走出1步，再在各个方向上走出第2步、第3步……一直到各个方向全部走完。听起来有些抽象，下面我们通过二叉树的<strong>层序遍历</strong>，来看一看广度优先是怎么回事。<br>层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。<br><img src="/blog/img/2020/01/03/层序遍历.png"><br><br>上图就是一个二叉树的层序遍历，每个节点左侧的序号代表该节点的输出顺序。<br>可是，二叉树同一层次的节点之间是没有直接关联的，如何实现层序遍历？<br>使用<strong>队列</strong>，详细遍历步骤如下：<br>1.根节点1进入队列。<br><img src="/blog/img/2020/01/03/步骤1.png"><br><br>2.节点1出队，输出节点1，并得到节点1的左孩子节点2、右孩子节点3。让节点2和3进入队列。<br><img src="/blog/img/2020/01/03/步骤2.png"><br><br>3.节点2出队，输出节点2，并得到节点2的左孩子节点4、右孩子节点5。让节点4和节点5入队。<br><img src="/blog/img/2020/01/03/步骤3.png"><br><br>4.同理，节点3出队，输出节点3，并得到节点3的右孩子节点6，让节点6入队。<br><img src="/blog/img/2020/01/03/步骤4.png"><br><br>5.节点4出队，输出节点4，由于节点4没有孩子节点，所以没有新节点入队。<br><img src="/blog/img/2020/01/03/步骤5.png"><br><br>6.结点5的操作同节点4操作。<br><img src="/blog/img/2020/01/03/步骤6.png"><br><br>7.结点6的操作同节点4操作。<br><img src="/blog/img/2020/01/03/步骤7.png"><br><br>到此为止所有的节点都遍历输出完毕。  </p>
<p>示例代码：  </p>
<pre><code>/**
 * 队列实现 层序遍历
 * @param root 根节点
 */
public static void levalOrderTraversal(TreeNode root){
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.offer(root);
    while(!queue.isEmpty()){
        TreeNode treeNode = queue.poll();
        System.out.print(treeNode.data+&quot; &quot;);
        if(treeNode.leftChild!=null){
            queue.offer(treeNode.leftChild);
        }
        if(treeNode.rightChild!=null){
            queue.offer(treeNode.rightChild);
        }
    }

}</code></pre><p>层序遍历也可以通过递归实现，下面是我个人的一段实现，借用了数组（可能有更好的方法，后续补充）。<br>大致思路：<br>1.二叉树有个特点，左孩子的下标=父节点下标x2+1，右孩子下标=父节点下标x2+2。<br>2.这样的话，我们只需要把每个节点存储在数组对应的下标里，就行了，然后输出数组就行了。</p>
<pre><code>/**
 * 递归实现  层序遍历
 * @param root 根节点
 */
static String[] arr = new String[10];//这里没有用int[],考虑到节点如果包含0元素，输出数组时可能会被过滤掉。
public static void levalOrderTraversal2(TreeNode node,int i){
    if(i&gt;=arr.length){//如果数组容量不够，扩容
        String[] newArr = new String[arr.length*2];
        System.arraycopy(arr, 0, newArr, 0, arr.length);//复制数据
    }
    arr[i] = String.valueOf(node.data);
    if(node.leftChild!=null){
        levalOrderTraversal2(node.leftChild,i*2+1);
    }
    if(node.rightChild!=null){
        levalOrderTraversal2(node.rightChild,i*2+2);
    }
}
/**
 * 输出
 */
public static void output(){
    for (int i = 0; i &lt; arr.length; i++) {
        if(arr[i]!=null){//过滤null
            System.out.print(arr[i]+&quot; &quot;);
        }
    }
}</code></pre><p>mian方法代码：</p>
<pre><code>System.out.print(&quot;递归，层序遍历:&quot;);
levalOrderTraversal2(treeNode,0);
Traversal.output();</code></pre>]]></content>
  </entry>
  <entry>
    <title>数据结构基础之树</title>
    <url>/blog/2019/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%91/</url>
    <content><![CDATA[<h2 id="1-什么是树？"><a href="#1-什么是树？" class="headerlink" title="1.什么是树？"></a>1.什么是树？</h2><p><strong>树是n个节点的有限集，有且仅有一个特定的称为根的节点。当n&gt;1时，其余节点可分为m个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。</strong>  </p>
<a id="more"></a>
<p>下面的这张图就是一个标准的树结构。<br><img src="/blog/img/2019/12/30/树图.png"><br><br>上图中，节点1是<strong>根节点(root)</strong>；节点5、6、7、8、9是树的末端，没有”孩子”，被称为<strong>叶子节点(leaf)</strong>。图中虚线部分是根节点1的其中一个<strong>子树</strong>。  
同时，树的结构从根节点到叶子节点，分为不同的层级。从一个节点的角度来看，上图中，节点4的上一级节点，是节点4的<strong>父节点(parent)</strong>；从节点4衍生出来的节点，是节点4的<strong>孩子节点(child)</strong>；和节点4同级，由同一个父节点衍生出来的节点，是节点4的<strong>兄弟节点(sibling)</strong>。  
树的最大层级数，被称为树的高度或深度。显然上图这个数的高度是4。</p>
<h2 id="2-什么是二叉树？"><a href="#2-什么是二叉树？" class="headerlink" title="2.什么是二叉树？"></a>2.什么是二叉树？</h2><p>二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点<strong>最多有2个孩子节点</strong>。注意，这里是最多有两个，也有可能只有1个，或者没有孩子节点。<br>二叉树的结构如图所示。<br><img src="/blog/img/2019/12/31/二叉树.png"><br><br>此外，二叉树还有两种特殊形式，一个叫做<strong>满二叉树</strong>，另一个叫做<strong>完全二叉树</strong>。 </p>
<h3 id="2-1-什么是满二叉树？"><a href="#2-1-什么是满二叉树？" class="headerlink" title="2.1 什么是满二叉树？"></a>2.1 什么是满二叉树？</h3><p><strong>一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级，那么这个树就是满二叉树。</strong><br><img src="/blog/img/2019/12/31/满二叉树.png"><br><br>简单来说，满二叉树的每一个分支都是满的。  </p>
<h3 id="2-2-什么是完全二叉树？"><a href="#2-2-什么是完全二叉树？" class="headerlink" title="2.2 什么是完全二叉树？"></a>2.2 什么是完全二叉树？</h3><p><strong>对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。</strong><br>这个定义还真绕，看看下图就很容易理解了。<br><img src="/blog/img/2019/12/31/完全二叉树.png"><br><br>在上图中，二叉树编号从1到12的12个节点，和前面满二叉树编号从1到12的节点位置完全相对应。因此这个树是完全二叉树。<br>完全二叉树的条件没有满二叉树的条件那么苛刻；满二叉树要求所有分支都是满的；而完全二叉树只需要保证最后一个节点之前的节点都齐全即可。  </p>
<p><strong>PS:如果还不理解完全二叉树，可以看下这个：</strong><br>①完全二叉树的倒数第二行及之前的行，都与满二叉树相同。</p>
<p>②倒数第一行右半部分可以是空的，也可以是满的，但不能有单个的出现！</p>
<p>③倒数第一行左半部分可以是空的，也可以是满的，也可有单个的出现，但有且只能有一个单个，且必须是它父亲的左孩子！<br>附图：<br><img src="/blog/img/2019/12/31/完全二叉树.jpg"><br><br>顺便一提性质：</p>
<p>1.叶子结点只在最大的两层</p>
<p>2.度为1的点只有1个或者0个(何为度为1的节点？就是只有1个孩子节点的节点，如上图的节点5)</p>
<p>3.n0=n/2 =》n为奇，向上取整（n1=0）；n为偶，n1=1；（n为节点总数，n0表示度为0的节点个数，n1表示度为1的节点个数，n2表示度2的节点个数）</p>
<p>二叉树可以用哪些物理存储结构来表达呢？<br><strong>1、链式存储结构</strong><br><img src="/blog/img/2019/12/31/链式存储结构.png"><br><br><strong>2、数组</strong><br><img src="/blog/img/2019/12/31/数组存储结构.png"><br><br>使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。</p>
<p>这样设计的目的是为了可以更方便的在数组中定位二叉树的孩子节点和父节点。  </p>
<p>假设一个父节点的下标时parent，那么它的左孩子节点下标就是<strong>2xparent+1</strong>；右孩子节点下标就是<strong>2xparent+2</strong>。  </p>
<p>反过来，假设一个左孩子的节点的下标是leftChild，那么它的父节点下标就是<strong>（leftChild-1）/2</strong>。  </p>
<p>显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。  </p>
<p>什么样的二叉树最适合用数组表示呢？<br>二叉堆，一种特殊的完全二叉树。</p>
<h2 id="3-二叉树的应用？"><a href="#3-二叉树的应用？" class="headerlink" title="3.二叉树的应用？"></a>3.二叉树的应用？</h2><p>二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主要的应用还是在于进行<strong>查找操作和维持相对顺序</strong>这两个方面。<br><strong>3.1 查找</strong><br>二叉树的树形结构使它很适合扮演索引的角色。<br>这里我们介绍一种特殊的二叉树；<strong>二叉查找树（Binary search tree）</strong>，这二叉树的主要作用就是进行查找操作。<br>二叉查找树在二叉树的基础上增加了以下几个条件。  </p>
<ul>
<li><strong>如果左子树不为空，则左子树上所有节点的值均小于根节点的值</strong>  </li>
<li><strong>如果右子树不为空，则右子树上所有节点的值均大于根节点的值</strong></li>
<li><strong>左、右子树也都是二叉查找树</strong> </li>
</ul>
<p>下图就是一个二叉查找树：<br><img src="/blog/img/2019/12/31/二叉查找树.png"><br><br>二叉查找树的这些条件有什么用呢？当然是为了查找方便。<br>例如查找值为4的节点，步骤如下。<br>1.访问根节点，发现4&lt;6。<br><img src="/blog/img/2019/12/31/步骤1.png"><br><br>2.访问节点6的左孩子节点3，发现4&gt;3。<br><img src="/blog/img/2019/12/31/步骤2.png"><br><br>3.访问节点3的右孩子节点4，发现4=4，这正是要查找的节点。<br><img src="/blog/img/2019/12/31/步骤3.png"><br><br>对于一个<strong>节点分布相对均匀</strong>的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是<strong>O(logn)</strong>，和树的深度是一样的。<br>这种依靠比较大小来逐步查找的方式，和二分法查找算法非常相似。  </p>
<p><strong>3.2 维持相对顺序</strong><br>这一点仍要从二叉查找树说起。二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。<br>因此二叉查找树还有另外一个名字——<strong>二叉排序树（Binary sort tree）</strong>。  
新插入的节点，同样要遵循二叉排序树的原则。<br>例如插入新元素5，由于5&lt;6，5&gt;3，5&gt;4，所以节点5最终会插入到节点4的右孩子位置。<br>插入新元素10，由于10&gt;6，10&gt;8，10&gt;9，所以10最终会插入到节点9的有孩子位置。<br><img src="/blog/img/2019/12/31/插入.png"><br><br>这一切看起来很顺利，然而却隐藏着一个致命的问题。什么问题呢？下面请试着在二叉查找树中一次插入9、8、7、6、5、4，看看会怎么样？<br><img src="/blog/img/2019/12/31/坡脚.png"><br><br>变成“坡脚”了，不仅外观看起来变得怪异了，查询节点的时间复杂度也退化成了O（n）。<br>怎么解决这个问题呢？这就涉及二叉树的<strong>自平衡</strong>了。二叉树自平衡的方式有很多种，如红黑树、AVL树、树堆等。这里暂不做详细介绍，后续了解。<br>除二叉查找树以外，<strong>二叉堆</strong>也维持着相对顺序。不过二叉堆的条件要宽松一些，只要求父节点比它的左右孩子都大，后续了解。  </p>
<h2 id="4-二叉树的遍历？"><a href="#4-二叉树的遍历？" class="headerlink" title="4.二叉树的遍历？"></a>4.二叉树的遍历？</h2><p>很多内容见此文章<a href="/blog/2019/12/31/二叉树的遍历/" target="_blank"> &gt;&gt;二叉树的遍历</a>。  </p>
<h2 id="5-什么是二叉堆？"><a href="#5-什么是二叉堆？" class="headerlink" title="5.什么是二叉堆？"></a>5.什么是二叉堆？</h2><p>很多内容见此文章<a href="/blog/2020/01/03/二叉堆/" target="_blank"> &gt;&gt;二叉堆</a>。  </p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/weixin_38220948/article/details/86629109" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38220948/article/details/86629109</a><br><a href="https://zhidao.baidu.com/question/525358502688180405.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/525358502688180405.html</a><br><a href="https://www.cnblogs.com/xiaogua918/p/4181561.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaogua918/p/4181561.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>数据结构基础之散列表</title>
    <url>/blog/2019/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-什么是散列表？"><a href="#1-什么是散列表？" class="headerlink" title="1.什么是散列表？"></a>1.什么是散列表？</h2><blockquote>
<p>散列表也叫哈希表，是存储Key-Value映射的集合。对于某一个Key，散列表可以在接近O(1)的时间内进行读写操作。散列表通过哈希函数实现Key和数组下标的转换，通过开放寻址法和链表法来解决哈希冲突。  </p>
</blockquote>
<a id="more"></a>
<h2 id="2-哈希函数"><a href="#2-哈希函数" class="headerlink" title="2.哈希函数"></a>2.哈希函数</h2><p><strong>散列表在本质上也是一个数组。</strong><br>散列表不能像数组那样直接通过a[0]、a[1]这样的方式来访问，需要通过一个中转站<strong>哈希函数</strong>来实现Key和数组下标的转标。<br><img src="/blog/img/2019/12/27/哈希函数.png">   </p>
<p>那么这个所谓的哈希函数是怎么实现的呢？<br>在不同的语言中，哈希函数的实现方式是不一样的。这里以java的常用集合HashMap，来看一看哈希函数在Java中的实现。<br>在Java及大多数面向对象的语言中，每一个对象都有属于自己的hashcode，这个hashcode是区分不同对象的重要标识。无论对象自身的类型是什么，他们的hashcode都是一个整型变量。<br>既然都是整型变量，想要转换成数组的下标也就不难实现了。最简单的转化方式是什么呢？就是按照数组长度进行取模运算。<br><strong>index = HashCode(Key)%Array.length</strong><br>实际上，JDK(Java Development Kit，Java语言的软件开发工具包)中的哈希函数并没有直接采用取模运算，而是利用位运算的方式来优化性能。不过在这里可以姑且简单理解成取模操作。<br>通过哈希函数，我们可以把字符串后其它类型的Key，转换成数组的下标index。  </p>
<h2 id="3-散列表的读写操作"><a href="#3-散列表的读写操作" class="headerlink" title="3.散列表的读写操作"></a>3.散列表的读写操作</h2><p><strong>1）.写操作(put)</strong><br>写操作就是在散列表中插入新的键值对(在JDK中叫做Entry)。<br>具体怎么做？<br>第1步，通过哈希函数，把Key转化成数组下标5。<br>第2步，如果数组下标5对应的位置没有元素，就把这个Entry填充到数组下标5的位置。<br><img src="/blog/img/2019/12/27/写操作.png">  </p>
<p>但是，由于数组的长度是有限的，当插入的Entry越来越多时，不同的Key通过哈希函数获得的下标可能是相同的。例如002936这个Key对应的数组下标是2；002947这个Key对应的数组下标也是2。<br><img src="/blog/img/2019/12/27/哈希冲突.png"><br>这种情况叫<strong>哈希冲突</strong>。  
<strong>哈希冲突是无法避免的，既然不能避免，那就要想办法解决。解决哈希冲突主要有两种方法，一种是开放寻址法，一种是链表法。</strong>  </p>
<p><strong>开放寻址法</strong>的原理很简单，当一个Key通过哈希函数获得对应的数组下标已被占用时，我们可以“另谋高就”，寻找下一个空位。<br>以上面的情况为例，Entry6通过哈希函数得到下标2，该下标在数组中已经有了其他元素，那么就向后移动1位，看看数组下标3的位置是否有空。直到找到空位为止。<br><img src="/blog/img/2019/12/27/哈希冲突2.png"><br><br><img src="/blog/img/2019/12/27/哈希冲突3.png"><br><br><img src="/blog/img/2019/12/27/哈希冲突4.png"><br><br>这是开放寻址法的基本思路。当然，当遇到哈希冲突时，寻址方式有很多种，不一定只是简单的寻找当前元素的后一个元素，这里只是举一个简单的示例。<br>在Java中，ThreadLocal所使用的就是开放寻址法。  </p>
<p><strong>链表法</strong>，这种方法被应用在java的集合类HashMap中：<br>HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只要插入到对应的链表中即可。<br><img src="/blog/img/2019/12/27/哈希冲突5.png"><br>  </p>
<p><strong>2）.读操作(get)</strong><br>读操作就是根据给定的Key，在散列表中找到对应的Value。<br>例如调用hashMap.get(“002936”),一丝是查找Key为002936的Entry在散列表中所对应的值。  </p>
<p>具体怎么做？<br>第1步，通过哈希函数将Key转为数组下标5.<br>第2步，找到数组下标2所对应的元素，如果这个元素的Key是002936，那么就找到了；如果这个Key不是002936也没关系，由于数组的每一个元素都与一个链表对应，我们可以顺着链表慢慢往下找，看看能不能找到与Key匹配的节点。<br><img src="/blog/img/2019/12/27/读操作.png"><br>  </p>
<p><strong>3）.扩容(resize)</strong><br>既然散列表是基于数组实现的，那么散列表也要涉及扩容问题。<br>当经过多次元素插入，散列表达到一定饱和度时，Key映射位置发生冲突的概率会逐渐增高。这样一来，大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大的影响。 </p>
<p><img src="/blog/img/2019/12/27/散列表扩容1.png"><br> </p>
<p>这时，散列表就需要扩展它的长度，也就是进行<strong>扩容</strong>。  
对于JDK中的散列表实现类HashMap来说，影响其扩容的因素有两个。  </p>
<ul>
<li>Capacity，即HashMap的当前长度。</li>
<li>LoadFactor，即HashMap的负载因子，默认值为0.75f。<br>衡量HashMap需要进行扩容的条件如下：  </li>
</ul>
<p><strong>HashMap.Size&gt;=Capacity*LoadFactory</strong>  </p>
<p><strong>那么散列表的扩容具体做了什么操作呢？</strong><br>1.<strong>扩容</strong>，创建一个新的Entry空数组，长度是原数组的2倍。<br>2.<strong>重新Hash</strong>，遍历原Entry数组，把所有的Entry重新Hash到新数组找中（长度扩大，Hash的规则也随之改动）。<br><strong>扩容前的HashMap</strong><br><img src="/blog/img/2019/12/27/扩容前.png"><br><br><strong>扩容后的HashMap</strong><br><img src="/blog/img/2019/12/27/扩容后.png"><br>  </p>
<p><strong>需要注意一点，关于HashMap的实现，JDK8和以前的版本有着很大的不同。当多个Entry被Hash到同一个数组下标位置时，为了提升插入和查找的效率，HashMap会把Entry的链表红黑树这种数据结构。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构基础之栈与队列</title>
    <url>/blog/2019/12/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><strong>栈与队列属于逻辑结构（逻辑结构是抽象的概念，它依赖于物理结构而存在），它们的物理实现既可以利用数组,也可以利用链表来完成。</strong>   </p>
<h2 id="1-什么是栈？"><a href="#1-什么是栈？" class="headerlink" title="1.什么是栈？"></a>1.什么是栈？</h2><p>首先举一个我们生活中的例子（羽毛球筒）：    </p>
<blockquote>
<p>假如我们有一个又细又长的圆筒，圆筒一端封闭，另一端开口。往圆筒里面放入羽毛球，先放入的靠近圆筒底部，后放入的靠近圆筒入口。<br>那么，要想取出这些羽毛球，则只能按照和放入顺序相反的顺序来取，先取出后放入的，再取出先放入的，而不可能把最里面最先放入的羽毛球优先取出来。</p>
</blockquote>
<blockquote>
<p>栈是一种线性逻辑结构，可以利用数组实现，也可以利用链表来实现。栈包含入栈和出栈操作，遵循<strong>先入后出</strong>（First In Last Out，简称FILO）的原则。最早放入的元素称为<strong>栈底（bottom）</strong>，最后进入的元素存放的位置叫做<strong>栈顶（top）</strong>。 </p>
</blockquote>
<a id="more"></a>
<p><strong>1）.数组实现</strong>  </p>
<pre><code>public class ArrayStack {
    private int[] stack;
    private int top;//栈顶指针

    public ArrayStack(int capacity){
        stack = new int[capacity];
        top=0;
    }

    /**
     * 入栈
     * @param element 入栈的元素
     */
    public void push(int element) throws Exception{
        if(top == stack.length){
            throw new Exception(&quot;栈已满&quot;);
        }
        stack[top++]=element;
    }

    /**
     * 出栈
     * @return
     */
    public int pop()throws Exception{
        if(top == 0){
            throw new Exception(&quot;栈为空&quot;);
        }
        return stack[--top];
    }

    /**
     * 获取栈顶元素，只查看，不删除
     * @return
     * @throws Exception
     */
    public int getTop()throws Exception{
        if(top == 0){
            throw new Exception(&quot;栈为空&quot;);
        }
        return stack[top-1];
    }

    public static void main(String[] args) throws Exception {
        ArrayStack arrayStack = new ArrayStack(10);
        arrayStack.push(3);
        arrayStack.push(5);
        arrayStack.push(1);
        arrayStack.push(4);
        arrayStack.push(9);
        System.out.println(arrayStack.pop());
        System.out.println(arrayStack.pop());
    }
}</code></pre><p><strong>2）.链表实现</strong>  </p>
<pre><code>public class LinkedStack {

    //栈顶
    private Node top;
    /**
     * 入栈
     * @param element 入栈的元素
     */
    public void push(int element){
        Node currentNode = new Node(element);
        if(top == null){
            top = currentNode;
        }else{
            currentNode.next=top;
            top=currentNode;
        }
    }

    /**
     * 出栈
     * @return 出栈的元素
     */
    public int pop()throws Exception{
        if(top == null){
            throw new Exception(&quot;栈为空&quot;);
        }
        int element = top.data;
        Node next = top.next;
        top = next;
        return element;
    }

    private class Node{
        Node next;
        int data;
        public Node(int data){
            this.data=data;
        }
    }

    public static void main(String[] args) throws Exception {
        LinkedStack linkedStack = new LinkedStack();
        linkedStack.push(1);
        linkedStack.push(2);
        linkedStack.push(3);
        System.out.println(linkedStack.pop());
        System.out.println(linkedStack.pop());
        System.out.println(linkedStack.pop());
    }
}</code></pre><p><strong>PS:入栈和出栈只会影响到最后一个元素，不涉及其他元素的整体移动，所以无论是以数组还是以链表实现，入栈、出栈的时间复杂度都是O(1)。</strong></p>
<h2 id="2-什么是队列？"><a href="#2-什么是队列？" class="headerlink" title="2.什么是队列？"></a>2.什么是队列？</h2><p>首先举一个生活中的例子（单行汽车隧道）：  </p>
<blockquote>
<p>加入公路上有一条单行隧道，所有通过隧道的车辆只允许从隧道入口驶入，从隧道出口驶出，不允许逆行。<br>因此，要想让车辆驶出隧道，只能按照它们驶入隧道的顺序，先驶入的车辆先驶出，后驶入的车辆后驶出，任何车辆都无法跳过它前面的车辆提前驶出。  </p>
</blockquote>
<blockquote>
<p>队列也是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队列包含入队和出队操作，遵循<strong>先入先出</strong>（First In First Out，简称FIFO）原则。队列的出口段叫<strong>队头</strong>(front)，队列的入口段叫<strong>队尾</strong>(rear)。  </p>
</blockquote>
<p><strong>1）.数组实现</strong>  </p>
<pre><code>public class ArrayQueue {

    private int[] array;
    //队尾
    private int rear;

    public ArrayQueue(int capacity){
        array = new int[capacity];
    }

    /**
     * 入队
     * @param element 入队的元素
     */
    public void enqueue(int element) throws Exception{
        if(rear == array.length){
            throw new Exception(&quot;队列已满&quot;);
        }
        array[rear++] = element;
    }

    /**
     * 出队
     * @return 出队元素
     */
    public int dequeue()throws Exception{
        if(rear==0){
            throw new Exception(&quot;队列为空&quot;);
        }
        int topElement = array[0];
        //后续队列元素前挪
        for(int i=0;i&lt;rear-1;i++){
            array[i]=array[i+1];
        }
        //队尾前移
        rear--;
        return topElement;
    }

    public void output(){
        for(int i=0;i&lt;rear;i++){
            System.out.print(array[i]+&quot; &quot;);
        }
        System.out.println();
    }

    public static void main(String[] args) throws Exception {
        ArrayQueue queue = new ArrayQueue(5);
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        queue.enqueue(4);
        queue.enqueue(5);
        queue.output();
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
        queue.output();
        queue.enqueue(6);
        queue.output();
    }
}</code></pre><p><strong>这里有个问题就是每次队头出队，后续元素都要整体移动，有点麻烦。这里可以使用循环队列进行优化一下。</strong><br><img src="/blog/img/2019/12/26/循环队列1.png"><br><img src="/blog/img/2019/12/26/循环队列2.png"><br><strong>2）.循环队列实现</strong> </p>
<pre><code>public class MyQueue {

    private int[] array;
    //队头
    private int front; 
    //队尾
    private int rear;

    public MyQueue(int capacity){
        array = new int[capacity];
    }

    /**
     * 入队
     * @param element 入队元素
     */
    public void enqueue(int element)throws Exception{
        if((rear+1)%array.length == front){
            throw new Exception(&quot;队列已满&quot;);
        }
        array[rear] = element;
        rear = (rear+1)%array.length;
    }

    /**
     * 出队
     * @return 出队元素
     */
    public int dequeue()throws Exception{
        if(rear == front){
            throw new Exception(&quot;队列为空&quot;);
        }
        int element = array[front];
        front = (front+1)%array.length;
        return element;
    }

    public void output(){
        for(int i=front;i != rear;i=i%array.length){
            System.out.print(array[i]+&quot; &quot;);
            i++;
        }
        System.out.println();
    }

    public void output2(){
        for(int i=0;i&lt;array.length;i++){
            System.out.print(array[i]+&quot; &quot;);
        }
        System.out.println();
    }

    public static void main(String[] args) throws Exception {
        MyQueue queue = new MyQueue(5);
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        queue.enqueue(4);
        queue.output();
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
        queue.output();
    }
}</code></pre><p><strong>循环队列不但充分的利用了数组的空间，同时还避免了元素整体移动的麻烦，出队入队时间复杂度都变为了O(1)。</strong><br><strong>PS:为什么队尾指向的位置永远空出一位呢？</strong><br>因为想区别队空和队满的条件.<br>队空条件:Q.front==Q.rear;<br>队满条件:(Q.rear+1)%Maxsize==Q.front</p>
<p><strong>3）.链表实现</strong>  </p>
<pre><code>public class LinkedQueue {

    //队头
    private Node head;
    //队尾
    private Node last;

    /**
     * 入队
     * @param element 入队元素
     */
    public void enqueue(int element){
        Node currentNode = new Node(element);
        if(head == null){
            head = currentNode;
            last = currentNode;
        }else{
            last.next = currentNode;
            last = currentNode;
        }
    }

    /**
     * 出队
     * @return
     */
    public int dequeue()throws Exception{
        if(head == null){
            throw new Exception(&quot;队列为空&quot;);
        }
        int headElement = head.data;
        head = head.next;
        return headElement;
    }

    /**
     * 输出元素
     */
    public void output(){
        Node temp = head;
        while(temp!=null){
            System.out.print(temp.data+&quot; &quot;);
            temp = temp.next;
        }
        System.out.println();
    }

    private class Node{
        int data;
        Node next;
        public Node(int data){
            this.data=data;
        }
    }

    public static void main(String[] args) throws Exception {
        LinkedQueue linkedQueue = new LinkedQueue();
        linkedQueue.enqueue(1);
        linkedQueue.enqueue(2);
        linkedQueue.enqueue(3);
        linkedQueue.enqueue(4);
        linkedQueue.enqueue(5);
        linkedQueue.output();
        System.out.println(linkedQueue.dequeue());
        System.out.println(linkedQueue.dequeue());
        linkedQueue.output();
        linkedQueue.enqueue(6);
        linkedQueue.enqueue(7);
        linkedQueue.output();
    }
}</code></pre><h2 id="3-栈与队列的应用场景？"><a href="#3-栈与队列的应用场景？" class="headerlink" title="3.栈与队列的应用场景？"></a>3.栈与队列的应用场景？</h2><p><strong>1）.栈的应用</strong><br>栈的输出顺序与输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯历史。<br>例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。<br><strong>2）.队列的应用</strong><br>队列的输出顺序与输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。<br>例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。<br>再如网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中，再按照存入队列的顺序来依次抓取和解析的。<br><strong>3）.双端队列</strong><br>双端队列这种数据结构综合了栈和队列的优点，对双端队列来说，从队头一端可以入队或出队，从队尾一端也可以入队或出队。<br>例子暂无，后续补充。<br><strong>4）.优先队列</strong><br>还有一种队列，他遵循的不是先入先出，而是谁的优先级最高，谁先出队。<br>优先队列已经不属于线性数据结构的范畴了，它是基于二叉堆来实现的。关于优先队列的原理和使用情况，后续补充。  </p>
]]></content>
  </entry>
  <entry>
    <title>数据结构基础之链表</title>
    <url>/blog/2019/12/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-什么是链表？"><a href="#1-什么是链表？" class="headerlink" title="1.什么是链表？"></a>1.什么是链表？</h2><blockquote>
<p>链表是一种链式数据结构，由若干个节点组成，每个节点包含指向下一节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问。查找链表节点的时间复杂度是O(n)，中间插入、删除节点的时间复杂度是O(1)。</p>
</blockquote>
<a id="more"></a>
<h2 id="2-什么叫随机存储？"><a href="#2-什么叫随机存储？" class="headerlink" title="2.什么叫随机存储？"></a>2.什么叫随机存储？</h2><blockquote>
<p>链表采用了见缝插针的方式，链表的每一个节点分布在内存的不同位置依靠next指针关联起来。这样可以灵活有效的利用零散的碎片空间。</p>
</blockquote>
<p><img src="/blog/img/2019/12/20/内存单元存储链表数据示意图.png"><br><br>图中的箭头代表链表节点的next指针。</p>
<h2 id="3-链表的基本操作"><a href="#3-链表的基本操作" class="headerlink" title="3.链表的基本操作"></a>3.链表的基本操作</h2><p><strong>1).查找节点</strong><br>在查找元素时，链表不想数组那样可以通过下标快速进行定位，只能从头节点开始向后一个一个节点逐一查找。<br><strong>2).更新节点</strong><br>如果不考虑查找节点的过程，链表的更新过程会像数组那样简单，直接把旧数据换成新数据即可。<br><strong>3).插入节点（同样存在尾部插入、头部插入、中间插入三种情况）</strong>  </p>
<pre><code>public class MyLinkedList {

    //头节点指针
    private Node head;
    //尾节点指针
    private Node last;
    //链表实际长度
    private int size;

    /**
     * 链表插入元素
     * @param data 插入元素
     * @param index 插入位置
     */
    public void insert(int data,int index)throws Exception{
        if(index&lt;0 || index&gt;size){
            throw new IndexOutOfBoundsException(&quot;超出链表节点范围&quot;);
        }

        Node insertedNode = new Node(data);
        if(size == 0){
            //链表长度为0时插入头部
            head = insertedNode;
            last = insertedNode;
        }else if(index == 0){
            //链表长度大于0时插入头部
            insertedNode.next = head;
            head = insertedNode;
        }else if(size == index){
            //插入尾部
            last.next = insertedNode;
            last=insertedNode;
        }else{
            //插入中间
            Node prevNode = get(index-1);
            Node nextNode = prevNode.next;
            prevNode.next = insertedNode;
            insertedNode.next = nextNode;
        }
        size++;
    }

    /**
     * 链表删除元素
     * @param index 删除的位置
     * @return
     */
    public Node delete(int index)throws Exception{
        if(index&lt;0 || index&gt;=size){
            throw new IndexOutOfBoundsException(&quot;超出链表节点范围&quot;);
        }
        Node removeNode;
        if(index == 0){
            //删除头节点
            removeNode = head;
            head = removeNode.next;
        }else if(index == size-1){
            //删除尾部节点
            Node prevNode = get(index-1);
            removeNode = prevNode.next;
            prevNode.next = null;
            last = prevNode;
        }else{
            //删除中间节点
            Node prevNode = get(index-1);
            //Node nextNode = get(index);
            removeNode = prevNode.next;
            Node nextNode = prevNode.next.next;
            prevNode.next = nextNode;
        }
        size--;
        return removeNode;
    }

    /**
     * 链表更新元素
     * @param data 更新元素
     * @param index 更新位置
     * @throws Exception
     */
    public void update(int data,int index)throws Exception{
        if(index&lt;0 || index&gt;=size){
            throw new IndexOutOfBoundsException(&quot;超出链表节点范围&quot;);
        }
        //Node node = get(index);
        //node.data = data;
        if(index == 0){
            //头部更新
            head.data=data;
        }else if(index == size-1){
            //尾部更新
            last.data=data;
        }else{
            //中间更新
            Node node = get(index);
            node.data = data;
        }
    }

    /**
     * 链表查找元素
     * @param index 查找的位置
     * @return
     */
    public Node get(int index) {
        if(index&lt;0 || index&gt;size){
            throw new IndexOutOfBoundsException(&quot;超出链表节点范围&quot;);
        }
        Node temp = head;
        for(int i=0;i&lt;index;i++){
            temp = temp.next;
        }
        return temp;
    }

    /**
     * 输出链表
     */
    public void output(){
        Node temp = head;
        while(temp!=null){
            System.out.print(temp.data+&quot; &quot;);
            temp = temp.next;
        }
        System.out.println();
    }

    /**
     * 链表节点
     */
    private static class Node{
        int data;
        Node next;
        Node(int data){
            this.data=data;
        }
    }


    public static void main(String[] args) throws Exception {
        MyLinkedList myLinkedList = new MyLinkedList();
        myLinkedList.insert(0, 0);
        myLinkedList.insert(1, 1);
        myLinkedList.insert(2, 2);
        myLinkedList.insert(3, 3);
        myLinkedList.output();//0 1 2 3
        myLinkedList.insert(4, 0);
        myLinkedList.output();//4 0 1 2 3
        myLinkedList.insert(5, 1);
        myLinkedList.output();//4 5 0 1 2 3
        myLinkedList.update(100, 2);
        myLinkedList.output();//4 5 100 1 2 3
        System.out.println(myLinkedList.delete(0).data);//4
        myLinkedList.output();//5 100 1 2 3
        System.out.println(myLinkedList.delete(3).data);//2
        myLinkedList.output();// 5 100 1 3
    }
}</code></pre><p><strong>4).删除节点（同样存在尾部删除、头部删除、中间删除三种情况）</strong>  </p>
<pre><code>/**
 * 链表删除元素
 * @param index 删除的位置
 * @return
 */
public Node delete(int index)throws Exception{
    if(index&lt;0 || index&gt;=size){
        throw new IndexOutOfBoundsException(&quot;超出链表节点范围&quot;);
    }
    Node removeNode;
    if(index == 0){
        //删除头节点
        removeNode = head;
        head = removeNode.next;
    }else if(index == size-1){
        //删除尾部节点
        Node prevNode = get(index-1);
        removeNode = prevNode.next;
        prevNode.next = null;
        last = prevNode;
    }else{
        //删除中间节点
        Node prevNode = get(index-1);
        //Node nextNode = get(index);
        removeNode = prevNode.next;
        Node nextNode = prevNode.next.next;
        prevNode.next = nextNode;
    }
    size--;
    return removeNode;
}</code></pre><p><strong>ps:不考虑插入、删除操作之前查找元素的过程，只考虑纯粹的插入和删除操作，时间复杂度都是O(1)。</strong></p>
<h2 id="4-数组-VS-链表"><a href="#4-数组-VS-链表" class="headerlink" title="4.数组 VS 链表"></a>4.数组 VS 链表</h2><p>数组和链表都属于线性的数据结构，但是各有千秋。下面是数组和链表相关操作的性能对比表。  </p>
<p><img src="/blog/img/2019/12/20/数组与链表的操作性能对比表.png"><br><br>从表格可以看出数组的优势在于能够快速定位元素，对于读操作多、写操作少的场景来说，用数组更合适一些。相反的，链表的优势在于能够灵活的进行插入和删除操作，如果需要在尾部频繁插入、删除元素，用链表更合适一些。</p>
]]></content>
  </entry>
  <entry>
    <title>数据结构基础之数组</title>
    <url>/blog/2019/12/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="1-什么是数组？"><a href="#1-什么是数组？" class="headerlink" title="1.什么是数组？"></a>1.什么是数组？</h2><blockquote>
<p>数组对应的英文是array，是由有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。它的物理存储方式是顺序存储。访问方式是随机访问。利用数组下标查找数组元素的时间复杂度是O(1)，中间插入、删除数组元素的时间复杂度是O(n)。</p>
</blockquote>
<a id="more"></a>
<h2 id="2-数组在内存中的顺序存储，具体是什么样子呢？"><a href="#2-数组在内存中的顺序存储，具体是什么样子呢？" class="headerlink" title="2.数组在内存中的顺序存储，具体是什么样子呢？"></a>2.数组在内存中的顺序存储，具体是什么样子呢？</h2><blockquote>
<p>内存是由一个个连续的内存单元组成的，每一个内存单元都有自己的地址。在这些内存单元中，有些被其他数据占用了，有些是空闲的。<br>数组中的每一个元素，都存储在小小的内存单元中，并且元素之间紧密排列既不能打乱元素的存储顺序，也不能跳过某个存储单元进行存储。  </p>
</blockquote>
<p><img src="/blog/img/2019/12/14/内存单元存储数组数据示意图.png"><br><br>在上图中，橙色的格子代表空闲中的存储单元，灰色的格子代表已占用的存储单元，而红色的连续格子代表数组在内存中的位置。<br>不同类型的数组，每个元素所占的字节个数也不同，本图只是一个简单的示意图。  </p>
<h2 id="3-数组的基本操作"><a href="#3-数组的基本操作" class="headerlink" title="3.数组的基本操作"></a>3.数组的基本操作</h2><p><strong>1).读取元素</strong></p>
<pre><code>int[] array = new int[]{3,1,2,5,4,9,7,2};
//输出数组中下标为3的元素
System.out.println(array[3]);     </code></pre><p><strong>2).更新元素</strong>    </p>
<pre><code>int[] array = new int[]{3,1,2,5,4,9,7,2};
//给数组下标为5的元素赋值
array[5] = 10;
//输出数组中下标为5的元素
System.out.println(array[5]);</code></pre><p><strong>3).插入元素（存在尾部插入、中间插入、超范围插入三种情况）</strong></p>
<pre><code>public class Test {

    private int[] array;
    //数组实际元素的数量
    private int size;

    public Test(int capacity){
        this.array = new int[capacity];
        this.size=0;
    }

    /**
     * 数组插入元素
     * @param element 插入元素
     * @param index 插入位置
     */
    public void insert(int element,int index)throws Exception{
        if(index&lt;0 || index&gt;size){
            throw new IndexOutOfBoundsException(&quot;超出数组实际元素范围&quot;);
        }
        //如果实际元素达到数组容量上限，则对数组进行扩容
        if(size&gt;=array.length){
            resize();
        }

        //从右向左，将元素逐个向右挪1位
        for(int i=size-1;i&gt;=index;i--){        
            array[i+1] = array[i];
        }
        //腾出的位置放入新元素
        array[index]=element;
        size++;
    }

    /**
     * 输出数组
     */
    public void output(){
        for (int i = 0; i &lt; array.length; i++) {
            System.out.print(array[i]+&quot; &quot;);
        }
        System.out.println();
    }

    /**
     * 数组扩容
     */
    public void resize(){
        int[] arrayNew = new int[this.array.length*2];
        //从旧数组复制到新数组
        System.arraycopy(array, 0, arrayNew, 0, array.length);
        array = arrayNew;
    }

    public static void main(String[] args)throws Exception {
        Test t = new Test(4);
        t.insert(3, 0);
        t.insert(7, 1);
        t.insert(9, 2);
        t.insert(5, 3);
        t.output();
        t.insert(6, 1);
        t.output();
    }
}</code></pre><p><strong>4).删除元素</strong></p>
<pre><code>/**
 * 数组删除元素
 * @param index 删除的位置
 * @return
 * @throws Exception
 */
public int delete(int index)throws Exception{
    //访问数组下标是否有超出范围
    if(index &lt;0 || index &gt;= size){
        throw new IndexOutOfBoundsException(&quot;超出数组实际元素范围&quot;);
    }
    int deleteElement = array[index];
    //从左向右循环，将元素逐个向左挪1位
    for(int i=index;i&lt;size-1;i++){
        array[i]=array[i+1];
    }
    array[size-1]=0;
    size--;
    return deleteElement;
}</code></pre><h2 id="4-数组的优势劣势"><a href="#4-数组的优势劣势" class="headerlink" title="4.数组的优势劣势"></a>4.数组的优势劣势</h2><blockquote>
<p>数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素。有一种高效查找元素的算法叫做二分法查找，就是利用了数组的这个优势。<br>至于数组的劣势，体现在插入和删除元素方面。由于数组元素连续紧密的存储在内存中，插入、删除都会导致大量元素被迫移动，影响效率。<br>总的来说，数组所适合的是<strong>读操作多、写操作少</strong>的场景，而链表恰恰与此相反。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>数据结构基础</title>
    <url>/blog/2019/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>传送门</strong></p>
<ul>
<li>1.<a href="/blog/2019/12/26/数据结构基础之数组/" target="_blank">数组</a></li>
<li>2.<a href="/blog/2019/12/26/数据结构基础之链表/" target="_blank">链表</a></li>
<li>3.<a href="/blog/2019/12/26/数据结构基础之栈与队列/" target="_blank">栈与队列</a></li>
<li>4.<a href="/blog/2019/12/27/数据结构基础之散列表/" target="_blank">散列表</a></li>
<li>5.<a href="/blog/2019/12/30/数据结构基础之树/" target="_blank">树</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>算法相关专业术语含义</title>
    <url>/blog/2019/12/14/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<h2 id="1-什么是算法？"><a href="#1-什么是算法？" class="headerlink" title="1.什么是算法？"></a>1.什么是算法？</h2><blockquote>
<p>在计算机领域里，算法是一系列程序指令，用于处理特定的运算和逻辑问题。衡量算法好坏的主要标准是时间复杂度和空间复杂度。</p>
</blockquote>
<a id="more"></a>
<h2 id="2-什么是数据结构？"><a href="#2-什么是数据结构？" class="headerlink" title="2.什么是数据结构？"></a>2.什么是数据结构？</h2><blockquote>
<p>数据结构是数据的组织、管理和存储格式，其使用目的是为了高效的访问和修改数据。<br>数据结构包含数组、链表这样的线性数据结构，也包含树、图这样的复杂数据结构。</p>
</blockquote>
<h2 id="3-什么是时间复杂度？"><a href="#3-什么是时间复杂度？" class="headerlink" title="3.什么是时间复杂度？"></a>3.什么是时间复杂度？</h2><blockquote>
<p>时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作T(n)=O(f(n))。<br>常见的时间复杂度按照从低到高的顺序，包括O(1)、O(logn)、O(n)、O(n<sup>2</sup>)等。</p>
</blockquote>
<h2 id="4-什么是空间复杂度？"><a href="#4-什么是空间复杂度？" class="headerlink" title="4.什么是空间复杂度？"></a>4.什么是空间复杂度？</h2><blockquote>
<p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，用大O表示，记作S(n)=O(f(n))。<br>常见的空间复杂度按照从低到高的顺序，包括O(1)、O(n)、O(n<sup>2</sup>)等。其中递归算法的空间复杂度和递归深度成正比(纯粹的递归操作的空间复杂度也是线性的，如果递归的深度是n，那么空间复杂度就是O(n)。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/blog/2019/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>原型模式(Prototype Pattern)用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，他提供了一种创建对象的最佳方式。  </p>
<a id="more"></a>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><strong>主要解决：</strong>在运行期间建立和删除原型。<br><strong>何时使用：</strong>1、当一个系统应该独立于它的产品创建，构成和表示时。2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。3、为了避免创建一个与产品类层次平行的工厂类层次时。4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。<br><strong>如何解决：</strong>利用已有的一个原型对象，快速地生成和原型对象一样的实例。<br><strong>关键代码：</strong>1、实现克隆操作，在JAVA继承Cloneable，重写clone(),在.NET中可以使用Object类的MemberwiseClone()方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。2、原型模式同样用于隔离类对象的使用者和具体类型(易变类)之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。<br><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA中的Object Clone()方法。<br><strong>优点：</strong> 1、当创建的对象实例较为复杂的时候，使用原型模式可以简化对象的创建过程。2、扩展性好，由于写原型模式的时候使用了抽象原型类，在客户端进行编程的时候可以将具体的原型类通过配置进行读取。3、可以使用深度克隆来保存对象的状态，使用原型模式进行复制。当你需要恢复到某一时刻就直接跳到。比如我们的idea种就有历史版本，或则SVN中也有这样的操作。非常好用。<br><strong>缺点：</strong>1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。2、需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的里面，当对已有的类经行改造时需要修改源代码，违背了开闭原则。3、在实现深克隆的时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用的时候，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现相对麻烦。<br><strong>使用场景：</strong> 1、资源优化场景。2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。3、性能和安全要求的场景。4、通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。5、一个对象多个修改者的场景。6、一个对象需要提供给其他对象的访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。<br><strong>注意事项：</strong>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象。浅拷贝实现Cloneable，重写。深拷贝是通过实现Serializable读取二进制流。  </p>
<p>举一个通俗的例子，来帮我们更好的理解原型模式，看过火影忍者都知道<strong>多重影分身</strong>这个东西吧。<br><img src="/blog/img/2020/01/07/多重影分身.gif"><br><br>多重影分身能够很好的体现原型模式的概念，在这里其中鸣人本体是<strong>原型对象</strong>，通过”多重影分身术”也就是原型模式（自己本身使用忍术创建），进行分身，创建<strong>新的对象</strong>！</p>
<p>需要注意的是，创建新”分身”的人就是鸣人！这个意思就是说<strong>原型对象自己不仅是个对象还是个工厂</strong>！并且通过克隆方式<strong>创建的对象是全新的对象</strong>，他们都是有自己的新的地址，通常对克隆模式所产生的新对象（影分身）进行修改（攻击）是不会对原型对象（鸣人）造成任何影响的！，每一个克隆对象都是相对独立的，通过不同的方式克隆对象进行修改后，可以得到一系列相似但不完全相同的对象（参考多重影分身之色诱术）。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><h3 id="2-1-UML类图"><a href="#2-1-UML类图" class="headerlink" title="2.1 UML类图"></a>2.1 UML类图</h3><p><img src="/blog/img/2020/01/07/原型模式UML图.png"><br>  </p>
<h3 id="2-2-模式组成"><a href="#2-2-模式组成" class="headerlink" title="2.2 模式组成"></a>2.2 模式组成</h3><p><strong>原型模式分三个角色，抽象类型角色，具体原型类，客户类</strong><br><strong>抽象原型类(prototype):</strong>它是声明克隆方法的接口，是所有具体原型类的<strong>公共父类</strong>，它可以是接口，抽象类甚至是一个具体的实现类。<br><strong>具体原型类(concretePrototype):</strong>它实现了抽象原型类中声明的<strong>克隆方法</strong>，在克隆方法中返回一个自己的克隆对象。<br><strong>客户类(Client):</strong>在客户类中，使用原型对象只需要<strong>通过工厂方式创建或直接NEW</strong>（实例化一个）原型对象，然后通过原型对象的克隆方法就能够获得多个相同的对象。由于客户端是针对抽象原型对象编程的所以还可以很方便的换成不同类型的原型对象。  </p>
<h2 id="3-基本代码实现"><a href="#3-基本代码实现" class="headerlink" title="3.基本代码实现"></a>3.基本代码实现</h2><p>首先我们需要知道在原型模式中克隆分两种：<strong>浅克隆与深克隆</strong>。  </p>
<blockquote>
<p><strong>浅克隆：被克隆的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。（或者你也可以这么理解，浅克隆只是复制了基础属性，例如八大基本类型，然而引用类型实际上并没有复制，只是将对应的引用给复制了，也复制了地址）</strong><br><strong>深克隆：深克隆把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。（你可能会觉得抽象，难以理解，没事后面通过代码演示，你就能更好的理解了）</strong>  </p>
</blockquote>
<h3 id="3-1-浅克隆"><a href="#3-1-浅克隆" class="headerlink" title="3.1 浅克隆"></a>3.1 浅克隆</h3><p>简历类  </p>
<pre><code>package 设计模式.原型模式.prototype;

/**
 * 简历类
 */
public class Resume implements Cloneable{
    private String name;
    private String sex;
    private int age;
    private String timeArea;
    private String company;

    public Resume(String name){
        this.name=name;
    }
    //设置个人信息
    public void setPesonalInfo(String sex,int age){
        this.sex=sex;
        this.age=age;
    }
    //设置工作经历
    public void setWorkExperience(String timeArea,String company){
        this.timeArea=timeArea;
        this.company=company;
    }
    //显示
    public void disPlay(){
        System.out.printf(&quot;%s   %s   %d&quot;,name,sex,age);
        System.out.println();
        System.out.printf(&quot;工作经历：  %s   %s&quot;,timeArea,company);
        System.out.println();
    }

    //实现clone()方法实现浅克隆
    public Object clone(){
        //需要实现cloneable的接口，直接继承object就好，它里面自带一个clone方法！
        Object obj = null;
        try {
            obj = super.clone();
        } catch (Exception e) {
            System.out.println(&quot;不支持克隆方法！&quot;);
        }
        return obj;
    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Client {
    public static void main(String[] args) {
        Resume a = new Resume(&quot;张三&quot;);
        a.setPesonalInfo(&quot;男&quot;, 29);
        a.setWorkExperience(&quot;1998-2000&quot;, &quot;XX公司&quot;);

        Resume b = (Resume)a.clone();
        b.setWorkExperience(&quot;1998-2006&quot;, &quot;YY企业&quot;);

        Resume c = (Resume)a.clone();
        c.setPesonalInfo(&quot;男&quot;, 24);

        a.disPlay();
        b.disPlay();
        c.disPlay();
    }
}</code></pre><p>输出结果  </p>
<pre><code>张三   男   29
工作经历：  1998-2000   XX公司
张三   男   29
工作经历：  1998-2006   YY企业
张三   男   24
工作经历：  1998-2000   XX公司</code></pre><p>我们之前说到了浅克隆与深克隆的区别，<strong>浅克隆只是复制了被克隆对象中引用类型的引用</strong>，我们现在来修改一下简历类，并新增一个工作经历类，然后简历类中引用这个工作经历对象。  </p>
<p>简历类  </p>
<pre><code>/**
 * 简历类
 */
public class Resume implements Cloneable{
    private String name;
    private String sex;
    private int age;
    //引用工作经历对象
    private WorkExperience work;

    public Resume(String name){
        this.name=name;
        //在简历类实例化时，同时实例化工作经历类
        work = new WorkExperience();
    }
    //设置个人信息
    public void setPesonalInfo(String sex,int age){
        this.sex=sex;
        this.age=age;
    }
    //设置工作经历
    public void setWorkExperience(String workDate,String company){
        work.setWorkDate(workDate);
        work.setCompany(company);
    }
    //显示
    public void disPlay(){
        System.out.printf(&quot;%s   %s   %d&quot;,name,sex,age);
        System.out.println();
        System.out.printf(&quot;工作经历：  %s   %s&quot;,work.getWorkDate(),work.getCompany());
        System.out.println();
    }

    //实现clone()方法实现浅克隆
    public Object clone(){
        //需要实现cloneable的接口，直接继承object就好，它里面自带一个clone方法！
        Object obj = null;
        try {
            obj = super.clone();
        } catch (Exception e) {
            System.out.println(&quot;不支持克隆方法！&quot;);
        }
        return obj;
    }
}</code></pre><p>工作经历类  </p>
<pre><code>//工作经历类
public class WorkExperience {

    private String workDate;
    private String company;

    public String getWorkDate() {
        return workDate;
    }
    public void setWorkDate(String workDate) {
        this.workDate = workDate;
    }
    public String getCompany() {
        return company;
    }
    public void setCompany(String company) {
        this.company = company;
    }

}</code></pre><p>客户端  </p>
<pre><code>public class Client {
    public static void main(String[] args) {
        Resume a = new Resume(&quot;张三&quot;);
        a.setPesonalInfo(&quot;男&quot;, 29);
        a.setWorkExperience(&quot;1998-2000&quot;, &quot;XX公司&quot;);

        Resume b = (Resume)a.clone();
        b.setWorkExperience(&quot;1998-2006&quot;, &quot;YY企业&quot;);

        Resume c = (Resume)a.clone();
        c.setWorkExperience(&quot;1998-2003&quot;, &quot;ZZ企业&quot;);

        a.disPlay();
        b.disPlay();
        c.disPlay();
    }
}</code></pre><p>输出结果  </p>
<pre><code>张三   男   29
工作经历：  1998-2003   ZZ企业
张三   男   29
工作经历：  1998-2003   ZZ企业
张三   男   29
工作经历：  1998-2003   ZZ企业</code></pre><p>发现问题了吗？三个结果一样的，显然输出结果没有达到我们的要求。那么怎么才能达到我们想要的结果呢？请继续往下看！ </p>
<h3 id="3-2-深克隆"><a href="#3-2-深克隆" class="headerlink" title="3.2 深克隆"></a>3.2 深克隆</h3><p>在前文介绍中的注意事项中，我提到过<strong>深拷贝是通过实现Serializable读取二进制流来完成的</strong>。简单讲就是通过序列化，将对象写到流的一个过程，写到流里面去（就是字节流）等于复制了对象，但是原来的对象并没有动，只是复制将类型通过流的方式进行读取，然后写到另一个内存中去！    </p>
<p>代码示例  </p>
<p>工作经历类  </p>
<pre><code>//工作经历类
public class WorkExperience implements Serializable{

    private static final long serialVersionUID = 1L;

    private String workDate;
    private String company;

    public String getWorkDate() {
        return workDate;
    }
    public void setWorkDate(String workDate) {
        this.workDate = workDate;
    }
    public String getCompany() {
        return company;
    }
    public void setCompany(String company) {
        this.company = company;
    }

}</code></pre><p>简历类  </p>
<pre><code>package 设计模式.原型模式.prototype;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * 简历类
 */
public class Resume implements Serializable{
    private static final long serialVersionUID = 1L;
    private String name;
    private String sex;
    private int age;
    //引用工作经历对象
    private WorkExperience work;

    public Resume(String name){
        this.name=name;
        //在简历类实例化时，同时实例化工作经历类
        work = new WorkExperience();
    }
    //设置个人信息
    public void setPesonalInfo(String sex,int age){
        this.sex=sex;
        this.age=age;
    }
    //设置工作经历
    public void setWorkExperience(String workDate,String company){
        work.setWorkDate(workDate);
        work.setCompany(company);
    }
    //显示
    public void disPlay(){
        System.out.printf(&quot;%s   %s   %d&quot;,name,sex,age);
        System.out.println();
        System.out.printf(&quot;工作经历：  %s   %s&quot;,work.getWorkDate(),work.getCompany());
        System.out.println();
    }

    //通过序列化进行深克隆
    public Object deepclone(){
        Object obj = null;
        try {
            //将对象写入流中
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(this);
            //将对象取出来
            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bis);
            obj = ois.readObject();
        } catch (Exception e) {
            System.out.println(&quot;不支持克隆方法！&quot;);
        }
        return obj;
    }
}</code></pre><p>客户端  </p>
<pre><code>public class Client {
    public static void main(String[] args) {
        Resume a = new Resume(&quot;张三&quot;);
        a.setPesonalInfo(&quot;男&quot;, 29);
        a.setWorkExperience(&quot;1998-2000&quot;, &quot;XX公司&quot;);

        Resume b = (Resume)a.deepclone();
        b.setWorkExperience(&quot;1998-2006&quot;, &quot;YY企业&quot;);

        Resume c = (Resume)a.deepclone();
        c.setWorkExperience(&quot;1998-2003&quot;, &quot;ZZ企业&quot;);

        a.disPlay();
        b.disPlay();
        c.disPlay();
    }
}</code></pre><p>输出结果  </p>
<pre><code>张三   男   29
工作经历：  1998-2000   XX公司
张三   男   29
工作经历：  1998-2006   YY企业
张三   男   29
工作经历：  1998-2003   ZZ企业</code></pre><p>好了，此时输出结果已经达到了我们的要求！</p>
<h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/prototype-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/prototype-pattern.html</a><br><a href="https://blog.csdn.net/qq_40709468/article/details/82316418" target="_blank" rel="noopener">https://blog.csdn.net/qq_40709468/article/details/82316418</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/blog/2019/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern），观察者模式又叫做发布-订阅模式（Publish/Subscribe）模式。比如，当一个对象修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。  </p>
<a id="more"></a>

<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。<br><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。<br><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。<br><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。<br><strong>关键代码：</strong>在抽象类里面有一个ArrayList存放观察者。<br><strong>应用实例：</strong>1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。2、天气发生变化，将变化通知给所有关注它的人，通知他们天气发生了变化。<br><strong>优点：</strong>1、观察者和被观察者是抽象耦合的。2、建立一套触发机制。<br><strong>缺点：</strong>1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。2、如果在观察者和观察目标之间有循环依赖的话，观察者目标会触发它们之间循环调用，可能导致系统崩溃。3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察者目标发生了变化。<br><strong>使用场景：</strong>1、一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。2、一个对象的改变将导致其他一个或多个对象也发生变化，而不知道具体有多少对象将发生变化，可以降低对象间的耦合度。3、一个对象必须通知其他对象，而不知道这些对象是谁。4、需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。<br><strong>注意事项：</strong>1、JAVA中已经有了对观察者模式的支持类。2、避免循环使用。3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><h3 id="2-1-UML类图"><a href="#2-1-UML类图" class="headerlink" title="2.1 UML类图"></a>2.1 UML类图</h3><img src="/blog/img/2019/12/30/观察者模式UML类图.png"> 

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>Subject类，可翻译为主题或抽象通知者，一般用一个抽象类或者一个接口实现。它把所有对观察者对象的引用保存在一个集合里，每个主题都可以拥有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。   </p>
<pre><code>public abstract class Subject {

    //观察者列表
    List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();


    //增加观察者
    public void Attach(Observer observer){
        observers.add(observer);
    }

    //移除观察者
    public void Detach(Observer observer){
        observers.remove(observer);
    }

    //通知观察者
    public void Notify(){
        for (Observer observer : observers) {
            observer.Update();
        }
    }

}</code></pre><p>Observer类，抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。抽象观察者一般使用一个抽象类或者一个接口实现。更新接口通常包含一个Update()方法，这个方法叫做更新方法。  </p>
<pre><code>public abstract class Observer {
    //更新
    public abstract void Update();
}</code></pre><p>ConcreteSubject类，叫做具体主题或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。  </p>
<pre><code>public class ConcreteSubject extends Subject {

    //具体被观察者状态
    private String subjectState;

    public String getSubjectState(){
        return subjectState;
    }

    public void setSubjectState(String subjectState){
        this.subjectState=subjectState;
    }
}</code></pre><p>ConcreteObserver类，具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色可以保存一个指向具体主题对象的引用。具体观察者角色通常用一个具体子类实现。  </p>
<pre><code>public class ConcreteObserver extends Observer{

    private ConcreteSubject subject;
    private String subjectState;
    //观察者名字
    private String name;


    public ConcreteObserver(ConcreteSubject subject,String name){
        this.subject=subject;
        this.name = name;
    }

    @Override
    public void Update() {
        subjectState = subject.getSubjectState();
        System.out.println(String.format(&quot;观察者%s的新状态是%s&quot;,name,subjectState));
    }

    public ConcreteSubject getSubject() {
        return subject;
    }

    public void setSubject(ConcreteSubject subject) {
        this.subject = subject;
    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Test {

    public static void main(String[] args) {

        ConcreteSubject concreteSubject = new ConcreteSubject();
        concreteSubject.Attach(new ConcreteObserver(concreteSubject, &quot;X&quot;));
        concreteSubject.Attach(new ConcreteObserver(concreteSubject, &quot;Y&quot;));
        concreteSubject.Attach(new ConcreteObserver(concreteSubject, &quot;Z&quot;));
        concreteSubject.setSubjectState(&quot;ABC&quot;);
        concreteSubject.Notify();
        concreteSubject.setSubjectState(&quot;abc&quot;);
        concreteSubject.Notify();
    }
}</code></pre><p>结果显示  </p>
<pre><code>观察者X的新状态是ABC
观察者Y的新状态是ABC
观察者Z的新状态是ABC
观察者X的新状态是abc
观察者Y的新状态是abc
观察者Z的新状态是abc</code></pre><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/observer-pattern.html</a>   </p>
]]></content>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/blog/2019/09/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在代理模式(Proxy Pattern)中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 </p>
<a id="more"></a>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>为其它对象提供一种代理以控制对这个对象的访问。<br><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因(比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问)，直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。<br><strong>何时使用：</strong>想访问一个类时做一些控制。<br><strong>如何解决：</strong>增加中间层。<br><strong>关键代码：</strong>实现与被代理组合。<br><strong>应用实例：</strong>1、windows里面的快捷方式。2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。3、买火车票不一定在火车站买，也可以去代售点。4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。5、spring aop<br><strong>优点：</strong>1、职责清晰。2、高扩展性 。3、智能化。<br><strong>缺点：</strong>1、由于客户端和真实主题之间增加了代理对象，因此某些类型的代理模式可能会造成请求的处理速度变慢。2、实现代理需要额外的工作，有些代理模式的实现非常复杂。<br><strong>使用场景：</strong>按职责来划分，通常有以下使用场景：1、远程代理。2、虚拟代理。3、Copy-on-Writer代理。4、保护(Protect or Access)代理。5、Cache代理。6、防火墙(Firewall)代理。7、同步化(Synchronization)代理。8、智能引用(Smart Reference)代理。<br><strong>注意事项：</strong>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。2、和装饰器模式的区别：装饰器模式是为了增强功能，而代理模式为了加以控制。   </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><h3 id="2-1-UML类图"><a href="#2-1-UML类图" class="headerlink" title="2.1 UML类图"></a>2.1 UML类图</h3><img src="/blog/img/2019/09/17/2.png"> 

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>Subject类，定义了RealSubject和Proxy的公用接口，这样就在任何使用RealSubject的地方都可以使用Proxy  </p>
<pre><code>public abstract class Subject {
    public abstract void request();
}</code></pre><p>RealSubject类，定义Proxy所代表的的真实实体</p>
<pre><code>public class RealSubject extends Subject {
    @Override
    public void request() {
        System.out.println(&quot;真实的请求&quot;);
    }
}</code></pre><p>Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口，这样代理可以用来替代实体。  </p>
<pre><code>public class Proxy extends Subject {
    private RealSubject realSubject;

    @Override
    public void request() {
        if(realSubject == null){
            realSubject = new RealSubject();
        }
        realSubject.request();
    }
}</code></pre><p>客户端代码</p>
<pre><code>public class Client {
    public static void main(String[] args) {
        Proxy proxy = new Proxy();
        proxy.request();
    }
}</code></pre><h2 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h2><p>从上面的例子可以看出静态代理模式的一个优点：扩展原功能，不侵入源代码。<br>再看看这种代理模式的缺点：假如有这样一个需求，有十个不同的RealSubject，同时我们要去代理的方法是不同的，比如要代理方法：request、request1、request2，添加代理前，源代码可能是这样的：</p>
<blockquote>
<p>realSubject.request();<br>realSubject1.request1();<br>realSubject2.request2();</p>
</blockquote>
<p>为了解决这个问题，我们有方案一：<br>为这些方法创建不同的代理类，代理后的代码是这样的：  </p>
<blockquote>
<p>proxy.request();<br>proxy1.request1();<br>proxy2.request2();</p>
</blockquote>
<p>当然，也有方案二：<br>通过创建一个proxy，持有不同的realSubject，实现Subject、Subject1、Subject2接口，让代码变成这样：  </p>
<blockquote>
<p>proxy.request();<br>proxy.request1();<br>proxy.request2();</p>
</blockquote>
<p>于是你的代理模型会变成这样：<br><img src="/blog/img/2019/09/17/3.png">  </p>
<p>毫无疑问，仅仅为了扩展同样的功能，在方案一中，我们会重复创建多个逻辑相同，仅仅RealSubject引用不同的Proxy。  </p>
<p>而在方案二中，会导致proxy的膨胀，而且这种膨胀往往是无意义的。此外，假如方法签名是相同的，更需要在调用的时候引入额外的判断逻辑。</p>
<p><strong>java 动态代理</strong><br>搞清楚静态代理的缺点十分重要，因为动态代理的目的就是为了解决静态代理的缺点。通过使用动态代理，我们可以通过在运行时，动态生成一个持有RealSubject、并实现代理接口的Proxy，同时注入我们相同的扩展逻辑。哪怕你要代理的RealSubject是不同的对象，甚至代理不同的方法，都可以动过动态代理，来扩展功能。<br>简单理解，动态代理就是我们上面提到的方案一，只不过这些proxy的创建都是自动的并且是在运行期生成的。</p>
<h3 id="4-1-JDK-自带的动态代理"><a href="#4-1-JDK-自带的动态代理" class="headerlink" title="4.1 JDK 自带的动态代理"></a>4.1 JDK 自带的动态代理</h3><p>java.lang.reflect.Proxy：生成动态代理类和对象；<br>java.lang.reflect.InvocationHandler(处理器接口)：可以通过invoke方法实现对真实角色的代理访问。<br>每次通过Proxy生成的代理类对象都要指定对应的处理器对象。<br>代码：<br>a)接口：Subject.java</p>
<pre><code>public interface Subject {
    public int sellBooks();
    public String speak();
}</code></pre><p>b)真实对象：RealSubject.java  </p>
<pre><code>public class RealSubject implements Subject{
    @Override
    public int sellBooks() {
        System.out.println(&quot;卖书&quot;);
        return 1;
    }
    @Override
    public String speak() {
        System.out.println(&quot;说话&quot;);
        return &quot;张三&quot;;
    }
}</code></pre><p>c)处理器对象：MyInvocationHandler.java</p>
<pre><code>//定义一个处理器
public class MyInvocationHandler implements InvocationHandler{

    //因为需要处理真实角色，所以要把真实角色传进来
    Object realSubject;

    public MyInvocationHandler(Object realSubject){
        this.realSubject=realSubject;
    }

    /**
    * @param proxy    代理类
    * @param method    正在调用的方法
    * @param args      方法的参数
    * @return
    * @throws Throwable
    */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //代理扩展逻辑            
        System.out.println(&quot;调用代理类&quot;);
        if(method.getName().equals(&quot;sellBooks&quot;)){
            int invoke = (int)method.invoke(realSubject, args);
            return invoke;
        }else{
            String string = (String)method.invoke(realSubject, args);
            System.out.println(&quot;调用的是说话的方法&quot;);
            return string;
        }
    }

}</code></pre><p>d)调用端：Client.java</p>
<pre><code>public class Client {
    public static void main(String[] args) {
        //真实对象
        Subject realSubject = new RealSubject();

        MyInvocationHandler myInvocationHandler = new MyInvocationHandler(realSubject);

        //代理对象
        Subject proxyClass = (Subject)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), 
                new Class[]{Subject.class}, myInvocationHandler);
        proxyClass.sellBooks();
        proxyClass.speak();
    }
}</code></pre><p>Proxy.newProxyInstance传入的是一个ClassLoader，一个代理接口，和我们定义的handler，返回的是一个Proxy实例。  </p>
<pre><code>public static void main(String[] args) {
    //Proxy proxy = new Proxy();
    //proxy.request();
    Proxy proxy = new Proxy();
    Subject proxyClass = proxy;
    proxyClass.request();
}</code></pre><p>仔细体会这个过程，其实有点类似我们在静态代理中提到的方案一，生成了一个包含我们扩展功能，持有RealSubject引用，实现Subject接口的代理实例Proxy。只不过这个Proxy不是我们自己写的，而是java帮我们生成，有没有一点动态的味道。  </p>
<p>让我们回顾一下代理三要素：真实对象：RealSubject，代理接口：Subject，代理实例：Proxy  </p>
<p>上面的代码含义也就是，输入RealSubject、Subject，返回一个Proxy。妥妥的代理模式。  </p>
<p>综上，动态生成+代理模式，也就是动态代理。  </p>
<p><strong>看一下源码</strong><br>道理讲清楚了，但是我们还不清楚这个Proxy是如何自动被生成的。入口就在newProxyInstance方法，核心代码如下：  </p>
<pre><code>private static final Class&lt;?&gt;[] constructorParams = { InvocationHandler.class };

public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)throws IllegalArgumentException
{
    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);
    ...
    final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);

    if (!Modifier.isPublic(cl.getModifiers())) {
        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
             public Void run() {
                cons.setAccessible(true);
                return null;
            }
        });
    }
    return cons.newInstance(new Object[]{h});
}</code></pre><p>整体流程就是：<br>&nbsp;&nbsp;1、生成代理类Proxy的Class对象。<br>&nbsp;&nbsp;2、如果Class作用域为私有，通过setAccessible支持访问。<br>&nbsp;&nbsp;3、获取Proxy Class构造函数，创建Proxy代理实例。  </p>
<p>生成Proxy的Class文件<br>&nbsp;&nbsp;生成Class对象的方法中，先是通过传进来的ClassLoader参数和Class[]数组对象作为组成键，维护了一个对于Proxy的Class对象的缓存。这样需要相同Proxy的Class对象时，只需要创建一次。<br>&nbsp;&nbsp;第一次创建该Class文件时，为了线程安全，方法进行了大量的处理，最后会来到ProxyClassFactory的apply方法中，经过以下流程：<br>&nbsp;&nbsp;1、检验传入的接口是否由传入的ClassLoader加载的。<br>&nbsp;&nbsp;2、校验传入是否是接口的Class对象。<br>&nbsp;&nbsp;3、检验是否传入重复的接口。<br>&nbsp;&nbsp;4、拼装代理类包名和类名，生成class文件的字节码。<br>&nbsp;&nbsp;5、调用native方法，传入字节码，生成Class对象。  </p>
<pre><code>private static final class ProxyClassFactory
    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;
{
    // prefix for all proxy class names
    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;

    // next number to use for generation of unique proxy class names
    private static final AtomicLong nextUniqueNumber = new AtomicLong();

    @Override
    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {

        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);
        for (Class&lt;?&gt; intf : interfaces) {
            /*
             * Verify that the class loader resolves the name of this
             * interface to the same Class object.
             */
            Class&lt;?&gt; interfaceClass = null;
            try {
                interfaceClass = Class.forName(intf.getName(), false, loader);
            } catch (ClassNotFoundException e) {
            }
            //1、检验传入的接口是否由传入的ClassLoader加载的
            if (interfaceClass != intf) {
                throw new IllegalArgumentException(
                    intf + &quot; is not visible from class loader&quot;);
            }
            /*
             * Verify that the Class object actually represents an
             * interface.
             */
            //2、校验传入是否是接口的Class对象。
            if (!interfaceClass.isInterface()) {
                throw new IllegalArgumentException(
                    interfaceClass.getName() + &quot; is not an interface&quot;);
            }
            /*
             * Verify that this interface is not a duplicate.
             */
            //3、检验是否传入重复的接口
            if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
                throw new IllegalArgumentException(
                    &quot;repeated interface: &quot; + interfaceClass.getName());
            }
        }

        String proxyPkg = null;     // package to define proxy class in
        int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

        /*
         * Record the package of a non-public proxy interface so that the
         * proxy class will be defined in the same package.  Verify that
         * all non-public proxy interfaces are in the same package.
         */
        for (Class&lt;?&gt; intf : interfaces) {
            int flags = intf.getModifiers();
            if (!Modifier.isPublic(flags)) {
                accessFlags = Modifier.FINAL;
                String name = intf.getName();
                int n = name.lastIndexOf(&apos;.&apos;);
                String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));
                if (proxyPkg == null) {
                    proxyPkg = pkg;
                } else if (!pkg.equals(proxyPkg)) {
                    throw new IllegalArgumentException(
                        &quot;non-public interfaces from different packages&quot;);
                }
            }
        }

        if (proxyPkg == null) {
            // if no non-public proxy interfaces, use com.sun.proxy package
            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;
        }

        /*
         * Choose a name for the proxy class to generate.
         */
        //4、拼装代理类包名和类名，生成class文件的字节码
        long num = nextUniqueNumber.getAndIncrement();
        String proxyName = proxyPkg + proxyClassNamePrefix + num;

        /*
         * Generate the specified proxy class.
         */
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces, accessFlags);
        try {
            //5、调用native方法，传入字节码，生成Class对象
            return defineClass0(loader, proxyName,
                                proxyClassFile, 0, proxyClassFile.length);
        } catch (ClassFormatError e) {
            /*
             * A ClassFormatError here means that (barring bugs in the
             * proxy class generation code) there was some other
             * invalid aspect of the arguments supplied to the proxy
             * class creation (such as virtual machine limitations
             * exceeded).
             */
            throw new IllegalArgumentException(e.toString());
        }
    }
}</code></pre><p>&nbsp;&nbsp;看一下第四步生成class文件字节码的过程，主要分为两个阶段：  </p>
<pre><code>addProxyMethod(hashCodeMethod, Object.class);
addProxyMethod(equalsMethod, Object.class);
addProxyMethod(toStringMethod, Object.class);

for (int i = 0; i &lt; interfaces.length; i++) {
    Method[] methods = interfaces[i].getMethods();
    for (int j = 0; j &lt; methods.length; j++) {
         addProxyMethod(methods[j], interfaces[i]);
    }
}
methods.add(this.generateConstructor());

 for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {
    for (ProxyMethod pm : sigmethods) { 
        fields.add(new FieldInfo(pm.methodFieldName,
                                   &quot;Ljava/lang/reflect/Method;&quot;, ACC_PRIVATE | ACC_STATIC));
        methods.add(pm.generateMethod());
    }
 }
methods.add(generateStaticInitializer());</code></pre><p>&nbsp;&nbsp;第一个阶段的代码比较清晰，主要就是添加各种Method，比如toString()、equals，以及传入的代理接口中的方法。再添加一下构造方法以及静态初始化方法。这样构成了一个对象，存储生成Proxy的Class的一些信息。  </p>
<p>&nbsp;&nbsp;到了这里，已经把要构造的Proxy的方法基本定义完成了，接下来就是要生成这个Class文件了。  </p>
<pre><code>ByteArrayOutputStream bout = new ByteArrayOutputStream();
 DataOutputStream dout = new DataOutputStream(bout);
 dout.writeInt(0xCAFEBABE);
 ...
 dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);
 ...
 return bout.toByteArray();</code></pre><p>&nbsp;&nbsp;看到这个CAFEBABE，就清楚第二阶段的内容了。CAFEBABE是Class文件的魔数，关于Class文件这个咖啡宝贝的魔数，相信做java的人都知道。没错，第二阶段就是生成字节码文件。按JVM规范，写入Class文件中包括权限控制、方法表、字段表等内容，生成符合规定的Class文件。最后返回对应的字节码。  </p>
<p>&nbsp;&nbsp;字节码生成以后，通过调用native方法defineClass解析字节码，就生成了Proxy的Class对象。  </p>
<p>Proxy构造方法<br>&nbsp;&nbsp;看一下Proxy的构造方法字节码生成部分：  </p>
<pre><code>MethodInfo minfo = new MethodInfo(&quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;,ACC_PUBLIC);
DataOutputStream out = new DataOutputStream(minfo.code);
code_aload(0, out);
code_aload(1, out);
out.writeByte(opc_invokespecial);
out.writeShort(cp.getMethodRef(superclassName,&quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;));
...</code></pre><p>&nbsp;&nbsp;关键在于，生成了一个参数为InvocationHandler的构造方法，code加载的是jvm方法区中的代码，然后通过invokespecial指令调用了父类构造方法。</p>
<p>查看生成的Class文件<br>&nbsp;&nbsp;上面利用字节码生成技术产生Class文件的过程，看起来可能比较晦涩，其实我们可以查看这个产生的Proxy到底是个什么样子。<br>&nbsp;&nbsp;注意ProxyGenerator中有这样一段代码：  </p>
<pre><code>if(saveGeneratedFiles) {
    ...
    FileOutputStream file = new FileOutputStream(dotToSlash(name) + &quot;.class&quot;);
    file.write(classFile);
    ...
 }</code></pre><p>&nbsp;&nbsp;再看一下saveGenerateFiles这个变量：  </p>
<pre><code>private final static boolean saveGeneratedFiles =
    java.security.AccessController.doPrivileged( 
    new GetBooleanAction(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;))
    .booleanValue();</code></pre><p>&nbsp;&nbsp;这是一个final类型的变量，通过GetBooleanAction方法读取系统变量，获取系统设置。默认这个值是false，稍微看一下System这个类的源码，发现有可以设置系统变量的API，然后在程序中的main函数设置一下这个变量：  </p>
<pre><code>System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code></pre><p>这个时候在跑一遍程序，就可以看到生成的Proxy的Class文件了，直接双击利用idea反编译。  </p>
<pre><code>package com.sun.proxy;

import JAVA基础.设计模式.代理模式.动态代理.Subject;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy0 extends Proxy implements Subject {
    private static Method m1;
    private static Method m2;
    private static Method m4;
    private static Method m3;
    private static Method m0;

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    ...

    public final String speak() throws  {
        try {
            return (String)super.h.invoke(this, m4, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int sellBooks() throws  {
        try {
            return (Integer)super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    ...

    static {
        try {
            ...
            m4 = Class.forName(&quot;JAVA基础.设计模式.代理模式.动态代理.Subject&quot;).getMethod(&quot;speak&quot;);
            m3 = Class.forName(&quot;JAVA基础.设计模式.代理模式.动态代理.Subject&quot;).getMethod(&quot;sellBooks&quot;);
            ...
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}</code></pre><p>&nbsp;&nbsp;省略几个无关重要的方法，可以看到三个重要的方法。<br>&nbsp;&nbsp;其中两个是我们的代理方法speak和sellBooks，另外一个就是构造方法。<br>&nbsp;&nbsp;这个$Proxy继承Proxy并调用了父类的构造方法，回忆一下上文提到的invokeSpecial，怎么样，对上了吧。  </p>
<p>&nbsp;&nbsp;看一下Proxy中这个构造方法：  </p>
<pre><code>protected Proxy(InvocationHandler h) {
    Objects.requireNonNull(h);
    this.h = h;
}</code></pre><p>&nbsp;&nbsp;再看一下$Proxy的代理方法：  </p>
<pre><code>super.h.invoke(this, m3, (Object[])null);</code></pre><p>&nbsp;&nbsp;再来回顾一下生成Proxy实例的过程：  </p>
<pre><code>private static final Class&lt;?&gt;[] constructorParams =
        { InvocationHandler.class };
...
final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
...
return cons.newInstance(new Object[]{h}); </code></pre><p>其实newInstance生成Proxy实例时，通过$Proxy0的Class对象，选择了这个InvocationHandler为参数的构造方法，传入我们定义的InvocationHnadler并生成了一个Proxy0的实例！InvocationHandler里有realSubject的逻辑以及我们的扩展逻辑，当我们调用Proxy0的speak和sellBooks方法时，就会调用我们InvocationHandler里实现的invoke方法。  </p>
<p>对上面这个过程，做一张图总结一下：<br><img src="/blog/img/2019/09/18/1.png">  </p>
<h3 id="4-2-Cglib动态代理"><a href="#4-2-Cglib动态代理" class="headerlink" title="4.2 Cglib动态代理"></a>4.2 Cglib动态代理</h3><p>Cglib动态代理是针对代理的类，动态生成一个子类，然后子类覆盖代理类中的方法，如果是private或是final类修饰的方法，则不会被重写。<br>CGLIB是一个功能强大，高性能的代码生成包。它没为有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。<br>CGLIB作为一个开源项目，其代码托管在github，地址为：<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">https://github.com/cglib/cglib</a>  </p>
<p>需要代理的类：  </p>
<pre><code>package cn.cpf.pattern.structure.proxy.cglib;
public class Engineer {
    // 可以被代理
    public void eat() {
        System.out.println(&quot;工程师正在吃饭&quot;);
    }

    // final 方法不会被生成的子类覆盖
    public final void work() {
        System.out.println(&quot;工程师正在工作&quot;);
    }

    // private 方法不会被生成的字类覆盖
    private void play() {
        System.out.println(&quot;this engineer is playing game&quot;);
    }
}</code></pre><p>CGLIB 代理类:  </p>
<pre><code>package cn.cpf.pattern.structure.proxy.cglib;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;

public class CglibProxy implements MethodInterceptor {
    private Object target;

    public CglibProxy(Object target) {
        this.target = target;
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println(&quot;###   before invocation&quot;);
        Object result = method.invoke(target, objects);
        System.out.println(&quot;###   end invocation&quot;);
        return result;
    }

    public static Object getProxy(Object target) {
        Enhancer enhancer = new Enhancer();
        // 设置需要代理的对象
        enhancer.setSuperclass(target.getClass());
        // 设置代理人
        enhancer.setCallback(new CglibProxy(target));
        return enhancer.create();
    }
}</code></pre><p>测试方法:  </p>
<pre><code>import java.lang.reflect.Method;
import java.util.Arrays;

public class CglibMainTest {
    public static void main(String[] args) {
        // 生成 Cglib 代理类
        Engineer engineerProxy = (Engineer) CglibProxy.getProxy(new Engineer());
        // 调用相关方法
        engineerProxy.eat();
    }
}</code></pre><p>运行结果:  </p>
<pre><code>###   before invocation
工程师正在吃饭
###   end invocation</code></pre><p>相关jar包下载：<br><a href="/blog/attachs/cglib-3.2.6.jar" target="blank">cglib-3.2.6.jar</a><br><a href="/blog/attachs/asm-all-6.0_BETA.jar" target="blank">asm-all-6.0_BETA.jar</a> </p>
<p><strong>jdk动态代理和cglib动态代理的区别：</strong><br>1）jdk动态代理只能对实现了接口的类生成代理，而不能针对类<br>2）CGLIB动态代理是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法</p>
<h2 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5.参考文章"></a>5.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/proxy-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/proxy-pattern.html</a><br><a href="https://blog.csdn.net/WangQYoho/article/details/77584832" target="_blank" rel="noopener">https://blog.csdn.net/WangQYoho/article/details/77584832</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/blog/2019/09/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>装饰模式又叫装饰器模式(Decorator Pattern)允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。<br>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。  </p>
<a id="more"></a>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>动态的给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。<br><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承的方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会膨胀。<br><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。<br><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。<br><strong>关键代码：</strong>1、Component类充当抽象角色，不应该具体实现。2、修饰类引用和继承Component类，具体扩展类重写父类方法。<br><strong>应用实例：</strong> 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。<br><strong>优点：</strong> 装饰类和被装饰类可以独立发展，不会互相耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。<br><strong>缺点：</strong>多层装饰比较复杂。<br><strong>使用场景：</strong> 1、扩展一个类的功能。2、动态增加功能，动态撤销。<br><strong>注意事项：</strong>可替代继承。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><h3 id="2-1-UML类图"><a href="#2-1-UML类图" class="headerlink" title="2.1 UML类图"></a>2.1 UML类图</h3><img src="/blog/img/2019/09/17/1.png">   

<h2 id="3-基本代码实现"><a href="#3-基本代码实现" class="headerlink" title="3.基本代码实现"></a>3.基本代码实现</h2><p>Component类  </p>
<pre><code>public abstract class Component{
    public abstract void operation();
}  </code></pre><p>ConcreteComponent类  </p>
<pre><code>public class ConcreteComponent extends Component{
    @Override
    public void operation() {
        System.out.println(&quot;具体的操作对象&quot;);
    }
}</code></pre><p>Decorator类  </p>
<pre><code>public class Decorator extends Component{

    Component component;

    public void setComponent(Component component){
        this.component=component;
    }

    @Override
    public void operation() {
        if(component!=null){
            component.operation();
        }
    }
}</code></pre><p>ConcreteDecoratorA类</p>
<pre><code>public class ConcreteDecoratorA extends Decorator{
    private String addedState;
    @Override
    public void operation() {
        super.operation();
        addedState = &quot;New State&quot;;
        System.out.println(&quot;具体装饰对象A的操作&quot;);
    }
}</code></pre><p>ConcreteDecoratorB类</p>
<pre><code>public class ConcreteDecoratorB extends Decorator{
    @Override
    public void operation() {
        super.operation();
        addedBehavior();
        System.out.println(&quot;具体装饰对象B的操作&quot;);
    }

    private void addedBehavior() {

    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Client {
    public static void main(String[] args) {
        ConcreteComponent c = new ConcreteComponent();
        ConcreteDecoratorA d1 = new ConcreteDecoratorA();
        ConcreteDecoratorB d2 = new ConcreteDecoratorB();

        //装饰过程
        d1.setComponent(c);
        d2.setComponent(d1);
        d2.operation();
    }
}</code></pre><p>运行结果  </p>
<pre><code>具体的操作对象
具体装饰对象A的操作
具体装饰对象B的操作</code></pre><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/decorator-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/blog/2019/09/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。  </p>
<a id="more"></a>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>定义一系列的算法把他们一个个的封装起来，并且使他们之间可以互相替换(<strong>策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能</strong>)。<br><strong>主要解决：</strong>在多种算法相似的情况下，使用if…else所带来的复杂和难以维护。<br><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是它们的直接行为。<br><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意的替换。<br><strong>关键代码：</strong>实现同一个接口。<br><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。3、JAVA AWT中的LayoutManager。<br><strong>优点：</strong> 1、算法可以自由切换。2、避免使用多重条件判断。3、扩展性好。<br><strong>缺点：</strong>1、策略类会增多。2、所有策略类都需要对外暴露。<br><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。2、一个系统需要动态地在几种算法中选择一种。3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。<br><strong>注意事项：</strong>如果一个系统的策略模式多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><h3 id="2-1-UML类图"><a href="#2-1-UML类图" class="headerlink" title="2.1 UML类图"></a>2.1 UML类图</h3><img src="/blog/img/2019/09/16/1.png">   

<h3 id="2-2-角色组成"><a href="#2-2-角色组成" class="headerlink" title="2.2 角色组成"></a>2.2 角色组成</h3><p>抽象策略角色：策略类，通常由一个接口或抽象类实现。<br>具体策略角色：包装了相关的算法和行为。<br>环境角色：持有一个策略类的引用，最终给客户端调用。</p>
<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>我们将创建一个定义活动的Strategy接口和实现Strategy接口的实体策略类。Context是一个使用了某种策略的类。<br>StrategyPatternDemo，我们的演示类使用Context在它所配置或使用的策略改变时的行为变化。<br><img src="/blog/img/2019/09/16/strategy_pattern_uml_diagram.jpg">   </p>
<p>1、创建一个接口  </p>
<pre><code>public interface Strategy {
    public int doOperation(int num1,int num2);
}</code></pre><p>2、创建实现接口的实体类  </p>
<pre><code>class OperationAdd implements Strategy {
    @Override
    public int doOperation(int num1,int num2) {
        return num1+num2;
    }
}
class OperationSubstract implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1-num2;
    }
}
class OperationMultiply implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1*num2;
    }
}</code></pre><p>3、创建context类  </p>
<pre><code>public class Context {
    private Strategy strategy;
    public Context(Strategy strategy){
        this.strategy=strategy;
    }

    public int executeStrategy(int num1, int num2){
        return strategy.doOperation(num1, num2);
    }
}</code></pre><p>4、使用Context来查看当它改变策略Strategy时的行为变化  </p>
<pre><code>public class StrategyPatternDemo {
    public static void main(String[] args) {
        Context context = new Context(new OperationAdd());
        System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));

        context = new Context(new OperationSubstract());      
        System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));

        context = new Context(new OperationMultiply());    
        System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));
    }
}</code></pre><p>5、运行结果  </p>
<pre><code>10 + 5 = 15
10 - 5 = 5
10 * 5 = 50</code></pre><h2 id="4-策略与简单工厂结合"><a href="#4-策略与简单工厂结合" class="headerlink" title="4.策略与简单工厂结合"></a>4.策略与简单工厂结合</h2><p>修改Context类  </p>
<pre><code>public class Context {
    private Strategy strategy;
    public Context(String type){
        switch (type) {
        case &quot;+&quot;:
            this.strategy=new OperationAdd();
            break;
        case &quot;-&quot;:
            this.strategy=new OperationSubstract();
            break;
        case &quot;*&quot;:
            this.strategy=new OperationMultiply();
            break;
        }

    }

    public int executeStrategy(int num1, int num2){
        return strategy.doOperation(num1, num2);
    }
}  </code></pre><p>修改测试类  </p>
<pre><code>public class StrategyPatternDemo {
    public static void main(String[] args) {
        Context context = new Context(&quot;+&quot;);
        System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));

        context = new Context(&quot;-&quot;);      
        System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));

        context = new Context(&quot;*&quot;);    
        System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));
    }
}</code></pre><h2 id="5-策略模式与简单工厂的区别"><a href="#5-策略模式与简单工厂的区别" class="headerlink" title="5.策略模式与简单工厂的区别"></a>5.策略模式与简单工厂的区别</h2><p><strong>相似点</strong>：在模式结构上，两者很相似。<br><strong>差异</strong>：  </p>
<ul>
<li>用途不一样<br>工厂是创建型模式，它的作用就是创建对象。<br>策略模式是行为型模式，它的作用是让一个对象在许多行为中选择一种行为。  </li>
<li>关注点不一样<br>一个关注对象创建。<br>一个关注行为的封装。  </li>
<li>解决不同的问题<br>工厂模式是创建型的设计模式，它接受指令，创建出符合要求的实例；它主要解决的是资源的统一分发，将对象的创建完全独立出来，让对象的创建和具体的使用客户无关。主要应用在多数据库选择，类库文件加载等。<br>策略模式是为了解决策略的切换与扩展，更简洁的说是定义策略族，分别封装起来，让他们之间可以相互替换，策略模式让策略的变化独立于使用策略的客户。  </li>
<li>工厂相当于黑盒子，策略相当于白盒子。 </li>
</ul>
<h2 id="6-举例说明"><a href="#6-举例说明" class="headerlink" title="6.举例说明"></a>6.举例说明</h2><ul>
<li>工厂模式<br>有一天你决定去吃培根披萨，首先得选择店铺，A店和B店都有培根披萨；<br>你点了A店的培根披萨，过了二十分钟，你的披萨就来了就可以吃到了。但这个披萨是怎么做的，到底面粉放了多少，培根放了多少，佐料放了多少，有多少道工序，你是不需要管的，你需要的是一个美味培根披萨。</li>
<li>策略模式<br>在披萨店，你要一个培根披萨，老板说有标准的pizza，也可以自己去做。原料有培根、面粉、佐料。工序有1、2、3工序，你自己去做吧。然后你就需要自己去做，到底放多少培根，放多少面粉，放多少佐料，这都你自己来决定，工序1、2、3，你是怎么实现的，都你自己决定。最后你得到了披萨。</li>
</ul>
<h2 id="7-参考文章"><a href="#7-参考文章" class="headerlink" title="7.参考文章"></a>7.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/strategy-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/strategy-pattern.html</a><br><a href="https://www.cnblogs.com/chenwolong/archive/2018/01/09/clms.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenwolong/archive/2018/01/09/clms.html</a><br><a href="https://baike.baidu.com/item/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/646307?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/646307?fr=aladdin</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/blog/2019/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br><strong>注意：</strong>  </p>
<ul>
<li>1、单例类只能有一个实例</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。<a id="more"></a>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2></li>
</ul>
<p><strong>意图：</strong>保证一个类仅有一个实例，并且提供一个访问它的全局局点。<br><strong>主要解决：</strong>一个全局使用的类频繁的创建与销毁。<br><strong>何时使用：</strong>当你想控制实例数目，节省系统资源的时候。<br><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br><strong>关键代码：</strong>构造函数是私有的。<br><strong>应用实例：</strong>  </p>
<ul>
<li>1、一个班级只有一个班主任</li>
<li>2、Windows是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li>
<li>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
</ul>
<p><strong>优点：</strong>  </p>
<ul>
<li>1、在内存里只有一个实例，减少了内存开销，尤其是频繁的创建和销毁实例(比如管理学院首页页面缓存)。</li>
<li>2、避免对资源的多重占用(比如写文件操作)。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么实例化。<br><strong>使用场景：</strong>  </p>
<ul>
<li>1、要求产生唯一序列号</li>
<li>2、WEB中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建一个对象需要消耗的资源过多，比如I/O与数据库的连接等。</li>
</ul>
<p><strong>注意事项：</strong>getInstance()方法中需要使用同步锁synchronized(Singleton.class)防止多线程同时进入造成instance被多次实例化。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><h3 id="2-1-UML类图"><a href="#2-1-UML类图" class="headerlink" title="2.1 UML类图"></a>2.1 UML类图</h3><img src="/blog/img/2019/09/09/1.png">   

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>1、创建一个Singleton类  </p>
<pre><code>public class SingleObject {

    //创建一个SingleObject的一个对象
    private static SingleObject instance = new SingleObject();

    //设置构造函数的访问权限修饰符为private，这样该类就不会被实例化
    private SingleObject(){}

    //获取唯一可用对象
    public static SingleObject getInstance(){
        return instance;
    }

    public void showMessage(){
        System.out.println(&quot;hello world!&quot;);
    }
}</code></pre><p>2、编写测试类  </p>
<pre><code>public class Test {

    public static void main(String[] args) {
        //不合法的构造函数
        //编译时错误：构造函数 SingleObject() 是不可见的
        //SingleObject object = new SingleObject();

        //获取唯一可用的对象
        SingleObject object = SingleObject.getInstance();
        //显示消息
        object.showMessage();
    }
}</code></pre><p>3、运行结果  </p>
<pre><code>hello world!</code></pre><h2 id="4-单例模式的几种实现方式"><a href="#4-单例模式的几种实现方式" class="headerlink" title="4.单例模式的几种实现方式"></a>4.单例模式的几种实现方式</h2><h3 id="4-1-懒汉式，线程不安全"><a href="#4-1-懒汉式，线程不安全" class="headerlink" title="4.1 懒汉式，线程不安全"></a>4.1 懒汉式，线程不安全</h3><p><strong>是否Lazy初始化：</strong>是<br><br><strong>是否多线程安全：</strong>否<br><br><strong>实现难易：</strong>易<br><br><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没加锁synchrionized，所以严格意义上他并不算单例模式。<br>这种方式lazy loading很明显，不要求线程安全，在多线程不能正常工作。  </p>
<pre><code>public class Singleton {

    private static Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){
        if(instance==null){
            instance = new Singleton();
        }
        return instance;
    }
}  </code></pre><h3 id="4-2-懒汉式，线程安全"><a href="#4-2-懒汉式，线程安全" class="headerlink" title="4.2 懒汉式，线程安全"></a>4.2 懒汉式，线程安全</h3><p><strong>是否Lazy初始化：</strong>是<br><br><strong>是否多线程安全：</strong>是<br><br><strong>实现难易：</strong>易<br><br><strong>描述：</strong>这种方式具备很好的lazy loading，能够在多线程中很好的工作，但是，效率很低，99%情况下不需要同步。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁synchronized才能保证单例，但加锁会影响效率。<br>getInstance()的性能对应用程序不是很关键(该方法使用不太频繁)。</p>
<pre><code>public class Singleton {

    private static Singleton instance;

    private Singleton(){}

    public static synchronized Singleton getInstance(){
        if(instance==null){
            instance = new Singleton();
        }
        return instance;
    }
}</code></pre><h3 id="4-3-饿汉式"><a href="#4-3-饿汉式" class="headerlink" title="4.3 饿汉式"></a>4.3 饿汉式</h3><p><strong>是否Lazy初始化：</strong>否<br><br><strong>是否多线程安全：</strong>是<br><br><strong>实现难易：</strong>易<br><br><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br><br>优点：没有加锁，执行效率很高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于classloader机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法，但是也不能确定有其他的方式(或者其它的静态方法)导致类装载，这时候初始化instance显然没有达到lazy loading的效果。  </p>
<pre><code>public class Singleton {

    private static Singleton instance = new Singleton();

    private Singleton(){}

    public static Singleton getInstance(){
        return instance;
    }
}</code></pre><h3 id="4-4-双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4-4-双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4.4 双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4.4 双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p><strong>JDK 版本：</strong>JDK1.5 起<br><br><strong>是否Lazy初始化：</strong>是<br><br><strong>是否多线程安全：</strong>是<br><br><strong>实现难易：</strong>较复杂<br><br><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br><br>getInstance()的性能对应用程序很关键。  </p>
<pre><code>public class Singleton {

    private volatile static Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(instance==null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}</code></pre><h3 id="4-5-登记式-静态内部类"><a href="#4-5-登记式-静态内部类" class="headerlink" title="4.5 登记式/静态内部类"></a>4.5 登记式/静态内部类</h3><p><strong>是否Lazy初始化：</strong>是<br><br><strong>是否多线程安全：</strong>是<br><br><strong>实现难易：</strong>一般<br><br><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br><br>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。  </p>
<pre><code>public class Singleton {

    private static class SingleHolder{
        private static final Singleton INSTANCE = new Singleton();
    }

    private Singleton(){}

    public static final Singleton getInstance(){
        return SingleHolder.INSTANCE;
    }
}</code></pre><h3 id="4-6-枚举"><a href="#4-6-枚举" class="headerlink" title="4.6 枚举"></a>4.6 枚举</h3><p><strong>JDK 版本：</strong>JDK1.5 起<br><br><strong>是否Lazy初始化：</strong>否<br><br><strong>是否多线程安全：</strong>是<br><br><strong>实现难易：</strong>易<br><br><strong>描述：</strong>这种方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br><br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。</p>
<pre><code>public enum Singleton {
    INSTANCE;
    public void whateverMethod(){}
}</code></pre><h2 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5.参考文章"></a>5.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/singleton-pattern.html</a>    </p>
<br>
<br>

<p><strong>PS:</strong>一般情况下，不建议使用第1种和第2种懒汉方式，建议使用第3种饿汉模式。只有在要明确实现lazy loading效果的情况时，才会使用第5种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第6种枚举方式。如果有其他特殊需求，可以考虑使用第4种双检锁方式。</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式分类</title>
    <url>/blog/2019/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th><strong>范围\目的</strong></th>
<th align="left"><strong>创建型模式</strong></th>
<th align="left"><strong>结构型模式</strong></th>
<th align="left"><strong>行为型模式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类模式</strong></td>
<td align="left">工厂方法模式</td>
<td align="left">（类）适配器模式</td>
<td align="left">解释器模式<br>模板方法模式</td>
</tr>
<tr>
<td><strong>对象模式</strong></td>
<td align="left">抽象工厂模式<br>建造者模式<br>原型模式<br>单例模式</td>
<td align="left">（对象）适配器模式<br>桥接模式<br>组合模式<br>装饰模式<br>外观模式<br>享元模式<br>代理模式</td>
<td align="left">职责链模式<br>命令模式<br>迭代器模式<br>中介者模式<br>备忘录模式<br>观察者模式<br>状态模式<br>策略模式<br>访问者模式</td>
</tr>
</tbody></table>
<a id="more"></a>
<p>根据目的、用途的不同，分为<strong>创建型模式、结构型模式、行为型模式。</strong>创建型模式主要用于创建对象，结构型模式主要用于处理类和对象间的组合，行为型模式主要用于描述类或对象的交互以及职责分配。  </p>
<p>根据处理范围不同，设计模式又可分为<strong>类模式和对象模式，</strong>类模式处理类与子类的关系，通过处理这些关系来建立继承，属于静态关系，在编译时确定下来；对象模式处理对象与对象之间的关系，运行时发生变化，属于动态关系。  </p>
<p>参考文章：<a href="https://www.cnblogs.com/bayu/p/8933631.html" target="_blank" rel="noopener">https://www.cnblogs.com/bayu/p/8933631.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/blog/2019/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在模板方法模式（Template Method pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。  </p>
<a id="more"></a>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法结构即可重新定义该算法的某些特定步骤。<br><strong>主要解决：</strong>一些方法通用，却在每一个子类都重写了这一方法。<br><strong>何时使用：</strong>有一些通用方法。<br><strong>关键代码：</strong>将这些通用算法抽象出来。<br><strong>应用实例：</strong>1、在建造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。2、西游记里面菩萨定好的81难，这就是一个顶层的逻辑骨架。3、spring中对Hibernate的支持，将一些已经定好的方法封装起来，比如开启事物、获取Session、关闭Session等，程序员不重复写那些已经规范好的代码，直接丢一个实现就可以保存。<br><strong>优点：</strong>1、封装不变部分，扩展可变部分。2、提取公共代码，便于维护。3、行为由父类控制，子类实现。<br><strong>缺点：</strong>每一个不同的实现都需要子类来实现，导致类的个数增加，使得系统庞大。<br><strong>使用场景：</strong>1、有多个子类共有的方法，且逻辑相同。2、重要的、复杂的方法，可以考虑作为模板方法。<br><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上final关键词。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><img src="/blog/img/2019/09/01/1.png">     

<p><strong>AbstractClass</strong>是抽象类，其实也就是一抽象模板，定义并实现了一个模板方法。这个模板方法一般是一个具体方法，他给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体的方法。  </p>
<pre><code>public abstract class AbstractClass{
    //一些抽象行为，放到子类去实现
    public abstract void primitiveOperation1();
    public abstract void primitiveOperation2();

    //模板方法，给出了逻辑的骨架，而逻辑的组成是一些相应的抽象操作，他们都推迟到子类实现
    public final void templateMethod(){
        primitiveOperation1();
        primitiveOperation2();
        System.out.println(&quot;&quot;);
    }
}</code></pre><p><strong>ConcreteClass</strong>，实现父类所定义的一个或多个抽象方法。每一个<strong>AbstractClass</strong>都可以有任意多个<strong>ConcreteClass</strong>与之对应，而每一个<strong>ConcreteClass</strong>都可以给出这些抽象方法(也就是顶级逻辑的组成步骤)的不同实现，从而使得顶级逻辑的实现各不相同。  </p>
<pre><code>class ConcreteClassA extends AbstractClass{
    @Override
    public void primitiveOperation1(){
        System.out.println(&quot;具体类A方法1实现&quot;);//与ConcreteClassB不同的方法实现
    }
    @Override
    public void primitiveOperation2(){
        System.out.println(&quot;具体类A方法2实现&quot;);//与ConcreteClassB不同的方法实现
    }
}

class ConcreteClassB extends AbstractClass{
    @Override
    public void primitiveOperation1(){
        System.out.println(&quot;具体类B方法1实现&quot;);//与ConcreteClassA不同的方法实现
    }
    @Override
    public void primitiveOperation2(){
        System.out.println(&quot;具体类B方法2实现&quot;);//与ConcreteClassA不同的方法实现
    }
}</code></pre><p>客户端调用  </p>
<pre><code>public static void main(String[] args){
    AbstractClass c;
    c = new ConcreteClassA();
    c.templateMethod();

    c = new ConcreteClassB();
    c.templateMethod();
}</code></pre><h2 id="3-例子"><a href="#3-例子" class="headerlink" title="3.例子"></a>3.例子</h2><p>场景：小时候，数学老师的随堂测验，都是在黑板上抄题目，要我们先抄题目，然后再做答案，我那时候眼镜已经开始不好了，所以有时候没看清楚就会把题目抄错，比如数字3看成数字8,7看成1，那就意味着我做的再好，也不会正确了。惨啊，没考好，回家父母还说我考试成绩差是不认真学习，还专门找借口。  </p>
<p>原因在哪里？<br>题目抄错了，那就不是考试题目了，而考试试卷最大的好处就是，大家都是一样的题目，特别是标准化的考试，比如全是选择或判断的题目，那就是最大化地限制了答题者的发挥，大家都是ABCD或打勾打叉，非对即错的结果。  </p>
<p><strong>设计一个抄题目的程序。</strong>  </p>
<h3 id="3-1-重复-易错-难改"><a href="#3-1-重复-易错-难改" class="headerlink" title="3.1 重复=易错+难改"></a>3.1 重复=易错+难改</h3><p>代码结构图<br><img src="/blog/img/2019/09/01/2.png">   </p>
<p>学生甲抄的试卷类  </p>
<pre><code>//学生甲抄的试题
public class TestPaperA {
    //试题1
    public void question1(){
        System.out.println(&quot;1+1=?答案是[] a.1 b.2 c.3 d.4&quot;);
        System.out.println(&quot;答案：b&quot;);
    }
    //试题2
    public void question2(){
        System.out.println(&quot;1+2=?答案是[] a.1 b.2 c.3 d.4&quot;);
        System.out.println(&quot;答案：c&quot;);
    }
    //试题3
    public void question3(){
        System.out.println(&quot;2+2=?答案是[] a.1 b.2 c.3 d.4&quot;);
        System.out.println(&quot;答案：d&quot;);
    }
}</code></pre><p>学生乙抄的试卷类  </p>
<pre><code>//学生乙抄的试题
public class TestPaperB {
    //试题1
    public void question1(){
        System.out.println(&quot;1+1=?答案是[] a.1 b.2 c.3 d.4&quot;);
        System.out.println(&quot;答案：a&quot;);
    }
    //试题2
    public void question2(){
        System.out.println(&quot;1+2=?答案是[] a.1 b.2 c.3 d.4&quot;);
        System.out.println(&quot;答案：b&quot;);
    }
    //试题3
    public void question3(){
        System.out.println(&quot;2+2=?答案是[] a.1 b.2 c.3 d.4&quot;);
        System.out.println(&quot;答案：d&quot;);
    }
}</code></pre><p>客户端测试类  </p>
<pre><code>public class Test {
    public static void main(String[] args) {
        System.out.println(&quot;学生甲抄的试卷：&quot;);
        TestPaperA a = new TestPaperA();
        a.question1();
        a.question2();
        a.question3();
        System.out.println();
        System.out.println(&quot;学生乙抄的试卷：&quot;);
        TestPaperB b = new TestPaperB();
        b.question1();
        b.question2();
        b.question3();
    }
}</code></pre><p>在这个程序中你会发现，学生甲和学生乙两个抄的试卷非常类似，除了答案不同，没什么不一样，这样写又容易错，又难以维护。<br>如果老师突然改题目，那么两个人都要改代码，如果某个人抄错了，那就糟糕了。怎么办？<br>老师出一份试卷，打印多份，让学生填答案就可以了。</p>
<h3 id="3-2-代码提炼"><a href="#3-2-代码提炼" class="headerlink" title="3.2 代码提炼"></a>3.2 代码提炼</h3><p>试卷父类代码  </p>
<pre><code>//考题试卷
public class Paper {
    //试题1
    public void question1(){
        System.out.println(&quot;1+1=?答案是[] a.1 b.2 c.3 d.4&quot;);
    }
    //试题2
    public void question2(){
        System.out.println(&quot;1+2=?答案是[] a.1 b.2 c.3 d.4&quot;);
    }
    //试题3
    public void question3(){
        System.out.println(&quot;2+2=?答案是[] a.1 b.2 c.3 d.4&quot;);
    }    
}</code></pre><p>学生子类代码  </p>
<pre><code>//学生甲抄的试题
public class TestPaperA extends Paper{
    public void question1(){
        super.question1();
        System.out.println(&quot;答案：b&quot;);
    }
    public void question2(){
        super.question2();
        System.out.println(&quot;答案：c&quot;);
    }
    public void question3(){
        super.question3();
        System.out.println(&quot;答案：d&quot;);
    }
}

//学生乙抄的试题
public class TestPaperB extends Paper{
    public void question1(){
        super.question1();
        System.out.println(&quot;答案：a&quot;);
    }
    public void question2(){
        super.question2();
        System.out.println(&quot;答案：b&quot;);
    }
    public void question3(){
        super.question3();
        System.out.println(&quot;答案：d&quot;);
    }
}</code></pre><p>客户端代码相同，略。  </p>
<p>到了这里有些人可能就会觉得子类已经非常简单了，只要填写答案就可以了。<br>实际上这只是初步泛化，你仔细看一下就会发现，这个类里面还有类似代码<strong>super.question1()</strong>以及<strong>System.out.println(“答案：”)</strong>，除了选项abcd，其他的都是重复的。  </p>
<p>这里我们<strong>既然用了继承，并且肯定这个继承有意义，就应该要成为子类的模板，所有重复的代码都应该上升到父类去，而不是让每个子类都去重复。怎么办？</strong>  </p>
<p>这时模板方法登场了，<strong>当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来考虑。</strong>  </p>
<p>改造试卷父类  </p>
<pre><code>//考题试卷
public class Paper {
    //试题1
    public final void question1(){
        System.out.println(&quot;1+1=?答案是[] a.1 b.2 c.3 d.4&quot;);
        System.out.println(&quot;答案：&quot;+answer1());
    }
    //试题2
    public final void question2(){
        System.out.println(&quot;1+2=?答案是[] a.1 b.2 c.3 d.4&quot;);
        System.out.println(&quot;答案：&quot;+answer2());
    }
    //试题3
    public final void question3(){
        System.out.println(&quot;2+2=?答案是[] a.1 b.2 c.3 d.4&quot;);
        System.out.println(&quot;答案：&quot;+answer3());
    }    

    public String answer1(){
        return &quot;&quot;;
    }
    public String answer2(){
        return &quot;&quot;;
    }
    public String answer3(){
        return &quot;&quot;;
    }
}</code></pre><p>改造子类  </p>
<pre><code>//学生甲抄的试题
public class TestPaperA extends Paper{
    public String answer1(){
        return &quot;b&quot;;
    }
    public String answer2(){
        return &quot;c&quot;;
    }
    public String answer3(){
        return &quot;d&quot;;
    }
}

//学生乙抄的试题
public class TestPaperB extends Paper{
    public String answer1(){
        return &quot;a&quot;;
    }
    public String answer2(){
        return &quot;b&quot;;
    }
    public String answer3(){
        return &quot;d&quot;;
    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Test {
    public static void main(String[] args) {
        System.out.println(&quot;学生甲抄的试卷：&quot;);
        Paper a = new TestPaperA();//将子类对象的声明改成了父类，利用了多态性，实现了代码的复用。
        a.question1();
        a.question2();
        a.question3();
        System.out.println();
        System.out.println(&quot;学生乙抄的试卷：&quot;);
        Paper b = new TestPaperB();
        b.question1();
        b.question2();
        b.question3();
    }
}</code></pre><p>代码结构图<br><img src="/blog/img/2019/09/01/3.png">   </p>
<h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/template-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/template-pattern.html</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/blog/2019/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。  </p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。  </p>
<a id="more"></a> 
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br><strong>主要解决：</strong>主要解决接口选择的问题。<br><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。<br><strong>关键代码：</strong>在一个工厂里聚合多个同类产品。<br><strong>应用实例：</strong>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。<br><strong>优点：</strong>当一个产品中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的Creator里加代码，又要在具体的里面加代码。<br><strong>使用场景：</strong>1、QQ换皮肤，一整套一起换。2、生成不同操作系统的程序。<br><strong>注意事项：</strong>产品族难扩展，产品等级易扩展。  </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><h3 id="2-1-UML类图"><a href="#2-1-UML类图" class="headerlink" title="2.1 UML类图"></a>2.1 UML类图</h3><img src="/blog/img/2019/08/29/1.webp">   

<h3 id="2-2-模式组成"><a href="#2-2-模式组成" class="headerlink" title="2.2 模式组成"></a>2.2 模式组成</h3><table>
<thead>
<tr>
<th>组成（角色）</th>
<th align="center">关系</th>
<th align="right">作用</th>
</tr>
</thead>
<tbody><tr>
<td>抽象产品族（AbstractProduct）</td>
<td align="center">抽象产品的父类</td>
<td align="right">描述抽象产品的公共接口</td>
</tr>
<tr>
<td>抽象产品（Product）</td>
<td align="center">具体产品的父类</td>
<td align="right">描述具体产品的公共接口</td>
</tr>
<tr>
<td>具体产品(Concrete Product)</td>
<td align="center">抽象产品的子类；工厂类创建的目标类</td>
<td align="right">描述生产的具体产品</td>
</tr>
<tr>
<td>抽象工厂（Creator）</td>
<td align="center">具体工厂的父类</td>
<td align="right">描述具体工厂的公共接口</td>
</tr>
<tr>
<td>具体工厂（Concrete Creator）</td>
<td align="center">抽象工厂的子类；被外界调用</td>
<td align="right">描述具体工厂；实现FactoryMethod工厂方法创建产品的实例</td>
</tr>
</tbody></table>
<p>如何理解抽象产品族、抽象产品和具体产品的区别呢？请看下图<br><img src="/blog/img/2019/08/29/2.webp">  </p>
<h3 id="2-3-使用步骤"><a href="#2-3-使用步骤" class="headerlink" title="2.3 使用步骤"></a>2.3 使用步骤</h3><p>步骤1： 创建抽象工厂类，定义具体工厂的公共接口；<br>步骤2： 创建抽象产品族类 ，定义抽象产品的公共接口；<br>步骤3： 创建抽象产品类 （继承抽象产品族类），定义具体产品的公共接口；<br>步骤4： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；<br>步骤5： 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；<br>步骤6： 客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例  </p>
<h2 id="3-实例讲解"><a href="#3-实例讲解" class="headerlink" title="3.实例讲解"></a>3.实例讲解</h2><p>这里我们以数据访问程序作为例子，要求能动态更换数据库，从基础做法一步一步深入抽象工厂模式  </p>
<h3 id="3-1-最基本的数据访问程序例子"><a href="#3-1-最基本的数据访问程序例子" class="headerlink" title="3.1 最基本的数据访问程序例子"></a>3.1 最基本的数据访问程序例子</h3><p>用户类  </p>
<pre><code>public class User {
    private int id;
    private String name;

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}</code></pre><p>SqlserverUser类——用于操作User表，假设只有”新增用户”和”得到用户”方法，其余方法以及具体的SQL语句省略。  </p>
<pre><code>class SqlserverUser{
    public void insert(){
        System.out.println(&quot;在SQL Server中给User表增加一条记录&quot;);
    }
    public User getUser(int id){
        System.out.println(&quot;在SQL Server中根据ID得到User表的一条记录&quot;);
        return null;
    }
}</code></pre><p>客户端代码：  </p>
<pre><code>public static void main(String[] args) {
    User user = new User();
    SqlserverUser su = new SqlserverUser();//与SQL Server耦合
    su.insert(user);//插入用户
    su.getUser(1);//得到ID为1的用户
}</code></pre><p>运行结果：  </p>
<pre><code>在SQL Server中给User表增加一条记录
在SQL Server中根据ID得到User表的一条记录</code></pre><p>在这个例子中因为SqlserverUser su = new SqlserverUser();的原因使得su这个对象被框死在SQL Server上了，所以不能直接更换数据库，因为在不同的数据库之间的语法不同，这里更改了数据库的还需要一一修改业务逻辑里对应的sql语句，这是不明智的。如果这里是灵活的，专业点的说法就是多态，那么在执行”su.insert(user)”和”su.getUser(1)”时就不用考虑是在用SQL Server还是在用Access。也就是说使用<strong>工厂方法模式</strong>来封装new SqlserverUser()所造成的变化。那么我们接着来看下一个例子。  </p>
<h3 id="3-2-用了工厂方法模式的数据访问程序"><a href="#3-2-用了工厂方法模式的数据访问程序" class="headerlink" title="3.2 用了工厂方法模式的数据访问程序"></a>3.2 用了工厂方法模式的数据访问程序</h3><p>代码结构图  </p>
<img src="/blog/img/2019/08/30/1.png">  

<p>IUser接口，用于客户端访问，解除与具体数据库访问的耦合。  </p>
<pre><code>public interface IUser {
    void insert(User user);
    User getUser(int id);
}</code></pre><p>SqlserverUser类，用于访问SQL Server的User。  </p>
<pre><code>class SqlserverUser implements IUser{

    @Override
    public void insert(User user) {
        System.out.println(&quot;在SQL Server中给User表增加一条记录&quot;);
    }

    @Override
    public User getUser(int id) {
        System.out.println(&quot;在SQL Server中根据ID得到User表的一条记录&quot;);
        return null;
    }

}</code></pre><p>AccessUser类，用于访问Access的User。  </p>
<pre><code>class AccessUser implements IUser{

    @Override
    public void insert(User user) {
        System.out.println(&quot;在Access中给User表增加一条记录&quot;);
    }

    @Override
    public User getUser(int id) {
        System.out.println(&quot;在Access中根据ID得到User表的一条记录&quot;);
        return null;
    }

}</code></pre><p>IFactory接口，定义一个创建访问User表对象的抽象的工厂接口。  </p>
<pre><code>public interface IFactory {
    IUser creatorUser();
}</code></pre><p>SqlServerFactory类，实现IFactory接口，实例化SqlserverUser。  </p>
<pre><code>class SqlServerFactory implements IFactory{

    @Override
    public IUser creatorUser() {
        return new SqlserverUser();
    }

}</code></pre><p>AccessFactory类，实现IFactory接口，实例化AccessUser。 </p>
<pre><code>class AccessFactory implements IFactory{

    @Override
    public IUser creatorUser() {
        return new AccessUser();
    }

}</code></pre><p>客户端代码  </p>
<pre><code>public static void main(String[] args) {
    User user = new User();
    IFactory factory = new SqlServerFactory();//若要改成Acces数据库，只需要将本句话改成IFactory factory = new AccessFactory();
    IUser iu = factory.creatorUser();
    iu.insert(user);
    iu.getUser(1);
}</code></pre><p>现在如果要换数据库，只需要new SqlServerFactory()改成new AccessFactory()，此时由于多态的关系，使得声明IUser接口的对象iu事先根本不知道是在访问哪个数据库，却可以在运行时很好的完成工作，这就是所谓的业务逻辑与数据访问的解耦。<br>那么新的问题来了，你的数据库里不可能只有一个User表吧，很可能有其他表，比如增加部门表(Department表)，此时如何办呢?  </p>
<pre><code>public class Department {

    private int id;
    private String deptName;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getDeptName() {
        return deptName;
    }
    public void setDeptName(String deptName) {
        this.deptName = deptName;
    }

}</code></pre><h3 id="3-3-用了抽象工厂模式的数据访问程序"><a href="#3-3-用了抽象工厂模式的数据访问程序" class="headerlink" title="3.3 用了抽象工厂模式的数据访问程序"></a>3.3 用了抽象工厂模式的数据访问程序</h3><p>代码结构图  </p>
<img src="/blog/img/2019/08/30/2.png">  

<p>IDepartment接口，用于客户端访问，解除与具体数据库访问的耦合。  </p>
<pre><code>public interface IDepartment {

    void insert(Department department);

    Department getDepartment(int id);
}</code></pre><p>SqlserverDepartment类，用于访问SQL Server的Department。  </p>
<pre><code>class SqlserverDepartment implements IDepartment{

    @Override
    public void insert(Department department) {
        System.out.println(&quot;在SQL Server中给Department表增加一条记录&quot;);
    }

    @Override
    public Department getDepartment(int id) {
        System.out.println(&quot;在SQL Server中根据ID得到Department表的一条记录&quot;);
        return null;
    }

}</code></pre><p>AccessDepartment类，用于访问Access的Department。 </p>
<pre><code>class AccessDepartment implements IDepartment{

    @Override
    public void insert(Department department) {
        System.out.println(&quot;在Access中给Department表增加一条记录&quot;);
    }

    @Override
    public Department getDepartment(int id) {
        System.out.println(&quot;在Access中根据ID得到Department表的一条记录&quot;);
        return null;
    }

}</code></pre><p>IFactory接口，定义一个创建访问Department表对象的抽象的工厂接口。  </p>
<pre><code>public interface IFactory {
    IUser creatorUser();
    IDepartment creatorDepartment();
}</code></pre><p>SqlServerFactory类，实现IFactory接口，实例化SqlserverUser和SqlserverDepartment。  </p>
<pre><code>public class SqlServerFactory implements IFactory{

    @Override
    public IUser creatorUser() {
        return new SqlserverUser();
    }

    @Override
    public IDepartment creatorDepartment() {
        return new SqlserverDepartment();
    }

}</code></pre><p>AccessFactory类，实现IFactory接口，实例化AccessUser和AccessDepartment。 </p>
<pre><code>public class AccessFactory implements IFactory{

    @Override
    public IUser creatorUser() {
        return new AccessUser();
    }

    @Override
    public IDepartment creatorDepartment() {
        return new AccessDepartment();
    }

} </code></pre><p>客户端代码  </p>
<pre><code>public static void main(String[] args) {
    User user = new User();
    Department department = new Department();
    IFactory factory = new AccessFactory();
    IUser iu = factory.creatorUser();
    iu.insert(user);
    iu.getUser(1);
    IDepartment id = factory.creatorDepartment();
    id.insert(department);
    id.getDepartment(1);
}</code></pre><p>只有一个User类和User操作类的时候，是只需要工厂方法模式的，但现在显然你数据库中有很多的表，而SQL Server与Access又是两大不同的分类，所以解决这种涉及多个产品系列的问题，有一个专门的工厂模式叫抽象工厂模式(Abstract Factory,提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类)。  </p>
<p>看到这里你就会发现抽象工厂的好处是什么了：<br>最大的好处<strong>便是易于交换产品系列，由于具体工厂类，</strong>例如IFactory factory = new AccessFactory(),<strong>在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。</strong>我们的设计不能去防止需求的更改，那么我们的理想便是让改动变得最小，现在如果你要更改数据库的访问，我们只需要更改具体的工厂就可以做到。第二大好处是，<strong>它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分类，不会出现在客户代码中。</strong>事实上刚刚的那个例子，客户端所认识的只有IUser和IDepartment，至于它是用SQL Server来实现还是Access来实现就不知道了。 </p>
<p>任何模式都有缺点，不适用的时候，那么我们来谈谈他的缺点：<br>比如我们现在要增加项目表Project，需要改动的地方有哪些？是不是至少要增加三个类<strong>IProject、SqlserverProject、AccessProject</strong>，还需要更改<strong>IFactory、SqlserverFactory和AccessFactory</strong>才可以完全实现。还有就是我们的客户端程序类显然不会是只有一个，有很多地方都在使用IUser和IDepartment，而这样的设计，其实在每一个类的开始都需要声明IFactory factory = new SqlserverFactory()，如果我有100个调用数据库的访问类，是不是就要更改100次IFactory factory = new AccessFactory()这样的代码才行？这不能解决我要更改数据库访问时，改动一处就完全更改的需求呀！  </p>
<p><strong>编程是门艺术，这样大批量的改动，显然是非常丑陋的做法。</strong>  </p>
<h3 id="3-4-用简单工厂来改进抽象工厂"><a href="#3-4-用简单工厂来改进抽象工厂" class="headerlink" title="3.4 用简单工厂来改进抽象工厂"></a>3.4 用简单工厂来改进抽象工厂</h3><p>去除<strong>IFactory、SqlserverFactory和AccessFactory</strong>三个工厂类，取而代之的是<strong>DataAccess</strong>类，用一个简单的工厂来实现。<br>代码结构图  </p>
<img src="/blog/img/2019/08/30/3.png">  

<pre><code>public class DataAccess {
    private static final String DB=&quot;Sqlserver&quot;;
    //private static final String DB=&quot;Access&quot;;

    public static IUser createUser(){
        IUser result = null;
        switch (DB) {
        case &quot;Sqlserver&quot;:
            result = new SqlserverUser();
            break;
        case &quot;Access&quot;:
            result = new AccessUser();
            break;
        }
        return result;
    }

    public static IDepartment createDepartment(){
        IDepartment result = null;
        switch (DB) {
        case &quot;Sqlserver&quot;:
            result = new SqlserverDepartment();
            break;
        case &quot;Access&quot;:
            result = new AccessDepartment();
            break;
        }
        return result;
    }
}</code></pre><p>客户端代码  </p>
<pre><code>public class Test {
    public static void main(String[] args) {
        User user = new User();
        Department department = new Department();
        IUser iu = DataAccess.createUser();//直接得到实际数据访问实例，而不存在任何依赖
        iu.insert(user);
        iu.getUser(1);
        IDepartment id = DataAccess.createDepartment();//直接得到实际数据访问实例，而不存在任何依赖
        id.insert(department);
        id.getDepartment(1);
    }
}</code></pre><p><strong>客户端没有出现任何一个SQL Server或Access字样了，达到了解耦的目的。</strong>但是还是存在不足之处，如果我现在要增加一个Oracle数据库访问，本来抽象工厂只增加一个OracleFactory工厂类就行了，现在比较麻烦了。需要在DataAccess类中每个方法的switch中加case了。  </p>
<p>那么我们是不是可以考虑不在程序里写明‘如果是Sqlserver就去实例化SQL Server数据库相关类，如果是Access就去实例化Access相关类’这样的语句，而是根据字符串DB的值去某个地方找应该要实例化的类是哪一个。这样，我们的switch就可以对它说再见了。也就是<strong>依赖注入(Dependency Injection)这种编程方式。</strong>本来依赖注入是需要专门的Ioc容器提供，比如Spring.NET，显然当前这个程序不需要那么麻烦，你只需要再了解一个简单的.NET技术‘反射’就可以了。  </p>
<blockquote>
<p><strong>Assembly.Load(“程序集名称”).CreateInstance(“命名空间.类名称”)</strong><br>或者Java中使用反射<br><strong>Class.forName(“命名空间.类名称”).newInstance()</strong> </p>
</blockquote>
<h3 id="3-5-用反射-抽象工厂的数据访问程序"><a href="#3-5-用反射-抽象工厂的数据访问程序" class="headerlink" title="3.5 用反射+抽象工厂的数据访问程序"></a>3.5 用反射+抽象工厂的数据访问程序</h3><p>改造DataAccess类，用反射取代IFactory、SqlserverFactory和AccessFactory。  </p>
<pre><code>public class DataAccess {
    //private static final String DB=&quot;Sqlserver&quot;;
    private static final String DB=&quot;Access&quot;;

    public static IUser createUser() throws Exception{
        //JAVA基础.设计模式.抽象工厂模式.SqlserverUser
        return (IUser) Class.forName(&quot;JAVA基础.设计模式.抽象工厂模式.&quot;+DB+&quot;User&quot;).newInstance();
    }

    public static IDepartment createDepartment() throws Exception{
        return (IDepartment)Class.forName(&quot;JAVA基础.设计模式.抽象工厂模式.&quot;+DB+&quot;Department&quot;).newInstance();
    }
}</code></pre><p>现在如果我们要增加Oracle数据访问，相关的类的增加是不可避免的，这点无论我们用任何代码都解决不了，不过这叫扩展，开放-封闭原则性告诉我们对于扩展，我们开放。对于修改我们应该尽量关闭，就目前而言，我们只需要修改private static final String DB=”Access”;为private static final String DB=”Oracle”;就可以了。  </p>
<p>那么如果我们要增加一个Project产品时，如何做呢?<br>只需要增加三个与Project相关的类，再修改DataAccess，在其增加一个public static IProject createProject()方法就行了。  </p>
<p>你有没有发现代码还是有点缺憾的呢，因为在更换数据库访问时，我们还是要去改程序(改DB这个字符串的值)重编译，如果可以不改程序，那才是真正的符合开放-封闭原则。  </p>
<h3 id="3-6-用反射-配置文件实现数据访问程序"><a href="#3-6-用反射-配置文件实现数据访问程序" class="headerlink" title="3.6 用反射+配置文件实现数据访问程序"></a>3.6 用反射+配置文件实现数据访问程序</h3><p>在资源文件夹下添加一个db.properties文件，内容如下：  </p>
<pre><code>db=Sqlserver</code></pre><p>修改DataAccess类  </p>
<pre><code>private static final String DB=ResourceBundle.getBundle(&quot;db&quot;).getString(&quot;db&quot;);</code></pre><p>这样的话我们就不用去修改代码来控制数据库的切换啦。这个程序写到这基本上就是满分了。</p>
<h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4.参考文章"></a>4.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/abstract-factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/abstract-factory-pattern.html</a><br><a href="https://www.jianshu.com/p/7deb64f902db" target="_blank" rel="noopener">https://www.jianshu.com/p/7deb64f902db</a>    </p>
<p>PS:三大工厂模式的区别<br>1、简单工厂模式：由一个工厂对象来决定创建出哪一个产品类的实例。<br>2、工厂方法模式：通过定义工厂父类负责定义创建对象的公共接口，而子类负责创建具体的产品，也就是将实际创建操作延迟到子类当中。<br>3、抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。  </p>
]]></content>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/blog/2019/08/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>工厂方法模式（FACTORY METHOD），又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类负责生成具体的对象。  </p>
<a id="more"></a>
<h2 id="2-模式简介"><a href="#2-模式简介" class="headerlink" title="2.模式简介"></a>2.模式简介</h2><p>工厂方法（Factory Method）模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作延迟到子类当中。核心工厂类不在负责产品的创建，将核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。  </p>
<p>工厂方法模式是<a href="/blog/2019/08/28/设计模式/简单工厂模式/">简单工厂模式</a>的衍生，解决了许多简单工厂模式的问题。首先完全实现”开放 - 关闭原则”，实现了可扩展。其次更复杂的结构层次，可以应用于产品结果复杂的场合。  </p>
<p>工厂方法模式对简单工厂模式进行了抽象。有一个抽象的Factory类(可以是抽象类和接口)，这个类将不再负责具体的产品生产，而是只制定一些规范，具体的生产工作由其子类去完成。在这个模式中，工厂类和产品类往往可以依次对应。即一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品，这个具体的工厂就负责生产对应的产品。  </p>
<p>工厂方法模式(Factory Method pattern)是最典型的<a href="/blog/2019/08/29/设计模式/模板方法模式/">模板方法模式</a>(Template Method pattern)应用。  </p>
<h2 id="2-角色结构"><a href="#2-角色结构" class="headerlink" title="2.角色结构"></a>2.角色结构</h2><p>工厂方法模式类图<br><img src="/blog/img/2019/08/29/1.png"><br>抽象工厂(Creator)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。  </p>
<p>具体工厂(Concrete Creator)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。在上图中有两个这样的角色：BulbCreator与TubeCreator。  </p>
<p>抽象产品(Product)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。在上图中，这个角色是Light。  </p>
<p>具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，他们之间往往一一对应。  </p>
<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><ul>
<li>更符合开-闭原则<br>新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可  <blockquote>
<p>简单工厂模式需要修改工厂类的判断逻辑</p>
</blockquote>
</li>
<li>符合单一职责原则<br>每个具体的工厂类只负责创建相应的产品  <blockquote>
<p>简单工厂中的工厂类存在复杂的switch逻辑判断  </p>
</blockquote>
</li>
<li>不使用静态工厂方法，可以形成基于继承的等级结构。<blockquote>
<p>简单工厂模式的工厂类使用静态工厂方法  </p>
</blockquote>
</li>
</ul>
<p>总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。  </p>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><ul>
<li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
<li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li>
<li>一个具体工厂只能创建一种具体产品</li>
</ul>
<h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h2><p>第一种情况是对于某个产品，调用者清楚地知道应该使用哪个具体工厂服务，实例化该具体工厂，生产出具体的产品来。Java Collection中的iterator() 方法即属于这种情况。  </p>
<p>第二种情况，只是需要一种产品，而不想知道也不需要知道究竟是哪个工厂为生产的，即最终选用哪个具体工厂的决定权在生产者一方，它们根据当前系统的情况来实例化一个具体的工厂返回给使用者，而这个决策过程对于使用者来说是透明的。  </p>
<h2 id="6-例子"><a href="#6-例子" class="headerlink" title="6.例子"></a>6.例子</h2><p>对<a href="/blog/2019/08/28/设计模式/简单工厂模式/">简单工厂模式</a>的中那个计算器控制台程序例子做一点改造：  </p>
<p>1.创建运算类(抽象产品类):  </p>
<pre><code>public abstract class Operation {

    private double number1 = 0;
    private double number2 = 0;

    public double getNumber1() {
        return number1;
    }
    public void setNumber1(double number1) {
        this.number1 = number1;
    }
    public double getNumber2() {
        return number2;
    }
    public void setNumber2(double number2) {
        this.number2 = number2;
    }

    public double getResult() throws Exception{
        return 0;
    }
}</code></pre><p>2.加减乘除类继承运算类(具体产品类)，重写getResult方法：  </p>
<pre><code>/**
 *加法类 
 */
class OperationAdd extends Operation{
    @Override
    public double getResult() throws Exception{
        return getNumber1()+getNumber2();
    }
}
/**
 *减法类 
 */
class OperationSub extends Operation{
    @Override
    public double getResult() throws Exception{
        return getNumber1()-getNumber2();
    }
}
/**
 *乘法类 
 */
class OperationMul extends Operation{
    @Override
    public double getResult() throws Exception{
        return getNumber1()*getNumber2();
    }
}
/**
 *除法类 
 */
class OperationDiv extends Operation{
    @Override
    public double getResult() throws Exception{
        if(getNumber2()==0){
            throw new Exception(&quot;除数不能为：0&quot;);
        }
        return getNumber1()/getNumber2();
    }
}</code></pre><p>3.创建抽象工厂类，定义具体工厂的公共接口：  </p>
<pre><code>public interface IFactory {
    Operation createOperation();
}</code></pre><p>4.创建具体工厂类，定义创建对应具体产品实例的方法：  </p>
<pre><code>//加法工厂
class AddFactory implements IFactory{
    @Override
    public Operation createOperation() {
        return new OperationAdd();
    }
}
//减法工厂
class SubFactory implements IFactory{
    @Override
    public Operation createOperation() {
        return new OperationSub();
    }
}
//乘法工厂
class MulFactory implements IFactory{
    @Override
    public Operation createOperation() {
        return new OperationMul();
    }
}
//除法工厂
class DivFactory implements IFactory{
    @Override
    public Operation createOperation() {
        return new OperationDiv();
    }
}</code></pre><p>5.客户端测试：  </p>
<pre><code>public class Test {
    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        System.out.println(&quot;请输入第一个数：&quot;);
        double number1 = scanner.nextDouble();
        System.out.println(&quot;请输入第二个数：&quot;);
        double number2 = scanner.nextDouble();
        IFactory factory = new AddFactory();//创建一个加法工厂
        Operation oper = factory.createOperation();
        oper.setNumber1(number1);
        oper.setNumber2(number2);
        double result = oper.getResult();
        System.out.println(&quot;运算结果：&quot;+result);
        scanner.close();
    }
}</code></pre><h2 id="7-参考文章"><a href="#7-参考文章" class="headerlink" title="7.参考文章"></a>7.参考文章</h2><p><a href="https://www.jianshu.com/p/d0c444275827" target="_blank" rel="noopener">https://www.jianshu.com/p/d0c444275827</a><br><a href="https://baike.baidu.com/item/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/2361103?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/2361103?fr=aladdin</a>  </p>
<p><br><br><br>PS:可以这么理解简单工厂模式和工厂方法模式：<br>简单工厂模式：就是所有的产品都在一个工厂里面生产，这个工厂里面有多条生产线，我们只要告诉这个工厂我们需要一个产品时，这个工厂就会去找对应的生产线为我们生产产品，我们不需要关心，也不知道工厂是通过哪条生产线为我们生产产品的。然后当我们需要生产一个新的产品的时候，就新增一条生产线用来生产新的产品，在这过程中就有可能就会影响到其他的生产线的工作。  </p>
<p>工厂方法模式：就是有多个工厂，每个工厂就一条生产线只生产一样产品，当我们需要生产一个产品时，需要我们去找到对应的工厂，告诉他我们需要你的产品。当我们需要生产一个新的产品时，就创建一个新的工厂来生产这个产品，这样也不会影响其他的工厂的工作。缺点就是工厂过多，难以维护。  </p>
]]></content>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/blog/2019/08/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。  </p>
<a id="more"></a>
<h2 id="2-基本简介"><a href="#2-基本简介" class="headerlink" title="2.基本简介"></a>2.基本简介</h2><p><strong>实现方式(附图)</strong><br>简单工厂模式的UML类图<br><img src="/blog/img/2019/08/28/1.jpg"><br>简单工厂模式的实质就是由一个工厂类根据传入的参数，动态决定哪一个产品类（这些产品类继承自一个父类或者接口）的实例。  </p>
<p>该模式中包含的角色及其职责  </p>
<p><strong>工厂(Creator)角色</strong><br>简单工厂模式的核心，他负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。  </p>
<p><strong>抽象产品(Product)角色</strong><br>简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。  </p>
<p><strong>具体产品(Concrete Product)角色</strong><br>是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。  </p>
<h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3.优缺点"></a>3.优缺点</h2><p><strong>优点</strong><br>工厂类是整个模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责”消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的，明确了各自的职责和权力，有利于整个软件体系结构的优化。 </p>
<p><strong>缺点</strong><br>由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部的创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则需要改变工厂类了。  </p>
<p>当系统中的具体产品类不断增多时，可能会出现要求工厂类根据不同条件创建不同实例的需求。这种条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利。  </p>
<p>这些缺点在<a href="/blog/2019/08/28/设计模式/工厂方法模式/">工厂方法模式</a>中得到了一定的克服。  </p>
<p><strong>使用场景</strong><br>工厂类负责创建的对象比较少；  </p>
<p>客户只知道传入工厂类的参数，对于如何创建对象(逻辑)不关心；  </p>
<p>由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。  </p>
<p><strong>c++代码：</strong>  </p>
<pre><code>//算法的父类，抽象出返回结果的接口
class Operation
{
public:
    virtual int GetResult() =0;
public:
    double m_Num1;
    double m_Num2;
};
//工厂类，用于生产相应的算法子类
class OperationFactry
{
public:
    OperationFactry(void);
    ~OperationFactry(void);
public:
    static Operation* CreateOperate(int n )
    {
        switch(n)
        {
        case 1:
            return new OperationAdd;
            break;
        }
    }
};
//算法子类，由工厂类创建，重写父类中的虚函数
class OperationAdd：Public Operation
{
public:
    int GetResult();
};</code></pre><h2 id="4-例子"><a href="#4-例子" class="headerlink" title="4.例子"></a>4.例子</h2><p>请用C++、Java、C#或VB.NET任意一种面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。 </p>
<p>1.创建运算类(抽象产品类)：  </p>
<pre><code>public abstract class Operation {

    private double number1 = 0;
    private double number2 = 0;

    public double getNumber1() {
        return number1;
    }
    public void setNumber1(double number1) {
        this.number1 = number1;
    }
    public double getNumber2() {
        return number2;
    }
    public void setNumber2(double number2) {
        this.number2 = number2;
    }

    public double getResult() throws Exception{
        return 0;
    }
}</code></pre><p>2.加减乘除类继承运算类(具体产品类)，重写getResult方法：  </p>
<pre><code>/**
 *加法类 
 */
class OperationAdd extends Operation{
    @Override
    public double getResult() throws Exception{
        return getNumber1()+getNumber2();
    }
}
/**
 *减法类 
 */
class OperationSub extends Operation{
    @Override
    public double getResult() throws Exception{
        return getNumber1()-getNumber2();
    }
}
/**
 *乘法类 
 */
class OperationMul extends Operation{
    @Override
    public double getResult() throws Exception{
        return getNumber1()*getNumber2();
    }
}
/**
 *除法类 
 */
class OperationDiv extends Operation{
    @Override
    public double getResult() throws Exception{
        if(getNumber2()==0){
            throw new Exception(&quot;除数不能为：0&quot;);
        }
        return getNumber1()/getNumber2();
    }
}</code></pre><p>3.创建简单工厂类：  </p>
<pre><code>public class OperationFactory {

    public static Operation createOperate(String operate){
        Operation oper = null;
        switch (operate) {
            case &quot;+&quot;:
                oper = new OperationAdd();
                break;
            case &quot;-&quot;:
                oper = new OperationSub();
                break;
            case &quot;*&quot;:
                oper = new OperationMul();
                break;
            case &quot;/&quot;:
                oper = new OperationDiv();
                break;
        }
        return oper;
    }
}</code></pre><p>4.客户端测试：  </p>
<pre><code>public class Test {
    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        System.out.println(&quot;请输入第一个数：&quot;);
        double number1 = scanner.nextDouble();
        System.out.println(&quot;请输入第二个数：&quot;);
        double number2 = scanner.nextDouble();
        System.out.println(&quot;请输入运算符：&quot;);
        String operate = scanner.next();
        Operation oper = OperationFactory.createOperate(operate);
        oper.setNumber1(number1);
        oper.setNumber2(number2);
        double result = oper.getResult();
        System.out.println(&quot;运算结果：&quot;+result);
        scanner.close();
    }
}</code></pre><p>运行结果：  </p>
<pre><code>请输入第一个数：
5
请输入第二个数：
2.5
请输入运算符：
/
运算结果：2.0</code></pre>]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/blog/2019/08/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>使用设计模式可以使得程序更加的灵活，容易修改，并且易于复用。  </p>
<a id="more"></a>  
<p><strong>传送门</strong>  </p>
<ul>
<li>1.<a href="/blog/2019/08/28/设计模式/简单工厂模式/" target="_blank">简单工厂模式</a></li>
<li>2.<a href="/blog/2019/08/28/设计模式/工厂方法模式/" target="_blank">工厂方法模式</a></li>
<li>3.<a href="/blog/2019/08/29/设计模式/抽象工厂模式/" target="_blank">抽象工厂模式</a></li>
<li>4.<a href="/blog/2019/08/29/设计模式/模板方法模式/" target="_blank">模板方法模式</a></li>
<li>5.<a href="/blog/2019/09/08/设计模式/单例模式/" target="_blank">单例模式</a></li>
<li>6.<a href="/blog/2019/09/09/设计模式/策略模式/" target="_blank">策略模式</a> </li>
<li>7.<a href="/blog/2019/09/17/设计模式/装饰模式/" target="_blank">装饰模式</a></li>
<li>8.<a href="/blog/2019/09/17/设计模式/代理模式/" target="_blank">代理模式</a></li>
<li>9.<a href="/blog/2019/10/21/设计模式/观察者模式/" target="_blank">观察者模式</a></li>
<li>10.<a href="/blog/2019/10/22/设计模式/原型模式/" target="_blank">原型模式</a></li>
<li>11.<a href="/blog/2020/01/09/设计模式/外观模式/" target="_blank">外观模式</a></li>
<li>12.<a href="/blog/2020/01/23/设计模式/建造者模式/" target="_blank">建造者模式</a></li>
<li>13.<a href="/blog/2020/02/10/设计模式/状态模式/" target="_blank">状态模式</a></li>
<li>14.<a href="/blog/2020/02/17/设计模式/适配器模式/" target="_blank">适配器模式</a></li>
<li>15.<a href="/blog/2020/02/17/设计模式/备忘录模式/" target="_blank">备忘录模式</a></li>
<li>16.<a href="/blog/2020/02/17/设计模式/组合模式/" target="_blank">组合模式</a></li>
<li>17.<a href="/blog/2020/02/26/设计模式/迭代器模式/" target="_blank">迭代器模式</a></li>
<li>18.<a href="/blog/2020/02/26/设计模式/桥接模式/" target="_blank">桥接模式</a></li>
<li>19.<a href="/blog/2020/02/27/设计模式/命令模式/" target="_blank">命令模式</a></li>
<li>20.<a href="/blog/2020/02/27/设计模式/职责链模式/" target="_blank">职责链模式</a></li>
<li>21.<a href="/blog/2020/02/27/设计模式/中介者模式/" target="_blank">中介者模式</a></li>
<li>22.<a href="/blog/2020/02/28/设计模式/享元模式/" target="_blank">享元模式</a></li>
<li>23.<a href="/blog/2020/02/28/设计模式/解释器模式/" target="_blank">解释器模式</a></li>
<li>24.<a href="/blog/2020/02/28/设计模式/访问者模式/" target="_blank">访问者模式</a></li>
</ul>
<p><a href="/blog/2020/04/25/资源整理/" target="blank">大话设计模式</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>给一整型变量a，写两段代码，第一个设置a的bit3，第二个清除a的bit3.“a的bit3”</title>
    <url>/blog/2019/08/28/%E7%BB%99%E4%B8%80%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%EF%BC%8C%E5%86%99%E4%B8%A4%E6%AE%B5%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%AE%BE%E7%BD%AEa%E7%9A%84bit3%E4%B8%BA1%EF%BC%8C%E5%85%B6%E4%BB%96bit%E4%B8%8D%E5%8F%98%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>|操作,当操作数为1时,结果为1,当操作数为0时,结果不变.<br>&amp;操作,当操作数为1时,结果不变,当操作数为0时,结果为0  </p>
<p>这个a是一个整形的,占8位,所以bit3应该是第三位。因为是从第零位开始计算的。  </p>
<p>因此：设置a的bit3为1的方法就是将a和00001000作|操作,这样其他位都不变,只有第3位变成1。<br>清除a的bit3的方法就是将a和11110111作&amp;操作,这样第3位变成0,其他位不变。</p>
<p>所以最终结果应该是：</p>
<pre><code>#define BIT3 (0x1&lt;&lt;3) 
static int a; 
void set_bit3(void) 
{ 
    a |= BIT3; 
} 
void clear_bit3(void) 
{ 
    a &amp;= ~BIT3; 
}   </code></pre><p>bit0 = 0x1&lt;&lt;0 = 0001<br>bit1 = 0x1&lt;&lt;1 = 0010<br>bit2 = 0x1&lt;&lt;2 = 0100<br>bit3 = 0x1&lt;&lt;3 = 1000<br>…</p>
]]></content>
  </entry>
  <entry>
    <title>transient关键字(转载整理)</title>
    <url>/blog/2019/08/28/transient%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p><strong>transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。</strong>   </p>
<p><strong>阅读目录</strong>  </p>
<ul>
<li><a href="#Serializable" title="#Serializable">先解释下java中的对象序列化</a></li>
<li><a href="#transient" title="#transient">关于transient关键字</a></li>
<li><a href="#example" title="#example">举个例子</a></li>
<li><a href="#reference" title="#reference">参考资料</a><a id="more"></a></li>
</ul>
<p><strong><span id="Serializable">先解释下java中的对象序列化</span></strong><br>在讨论transient之前，有必要先搞清楚java中序列化的含义：<br>java中对象的序列化指的是将对象转换成字节序列的形式表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可以用于网络传输，一般我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。<br>当然，序列化后的最终目的是为了反序列化，恢复成原先的java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成java对象的，这个过程就是反序列化。  </p>
<p><strong><span id="transient">关于transient关键字</span></strong><br>Java中transient关键字的作用，简单来说，就是让某些被修饰的成员属性变量不被序列化，这一看好像很好理解，就是不被序列化，那么什么情况下，一个对象的某些字段不需要被序列化呢？如果有如下情况，可以考虑使用关键字transient修饰：  </p>
<ul>
<li>1.类中的字段值可以根据其他字段推导出来，如一个长方形类有三个属性：长度、宽度、面积(示例而已，一般不会这么设计)，那么在序列化的时候，面积这个属性就没必要被序列化了；  </li>
<li>2.其他看具体的业务需求吧，哪些字段不想被序列化；</li>
</ul>
<p>PS,记得之前看HashMap源码的时候，发现有个字段是用transient修饰的，我觉得还是很有道理的，确实没必要对这个modCount字段进行序列化，因为没有意义，modCount主要用于判断HashMap是否被修改(像put、remove操作的时候，modCount都会自增)，对于这种变量，一开始可以为任何值，0当然也是可以的(new出来、反序列化出来、或者克隆出来的时候都是为0的)，没必要持久化其值。  </p>
<pre><code>/**
 * The number of times this HashMap has been structurally modified
 * Structural modifications are those that change the number of mappings in
 * the HashMap or otherwise modify its internal structure (e.g.,
 * rehash).  This field is used to make iterators on Collection-views of
 * the HashMap fail-fast.  (See ConcurrentModificationException).
 */
transient int modCount;</code></pre><p>最后，为什么要不被序列化呢，主要是为了节省存储空间，缺点的话可能是有些字段可能需要重新计算或初始化什么的，总的来说，利大于弊。  </p>
<p><strong><span id="example">举个例子</span></strong><br>仅仅是示例，具体使用请根据实际情况：  </p>
<pre><code>import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class TransientExample {
    public static void main(String[] args) throws Exception{
        Rectangle rectangle = new Rectangle(3, 4);
        System.out.println(&quot;1.原始对象：&quot;+rectangle);
        ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(&quot;rectangle&quot;));
        //往流写入对象
        o.writeObject(rectangle);
        o.close();

        //从流读取对象
        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;rectangle&quot;));
        Rectangle rectangle1 = (Rectangle)in.readObject();
        System.out.println(&quot;2.反序列化后的对象：&quot;+rectangle1);
        rectangle1.setArea();
        System.out.println(&quot;3.恢复成原始对象：&quot;+rectangle1);
        in.close();
    }
}

class Rectangle implements Serializable{

    private static final long serialVersionUID = 1L;

    private Integer width;
    private Integer height;
    private transient Integer area;

    public Rectangle(Integer width, Integer height) {
        this.width = width;
        this.height = height;
        this.area = width*height;
    }

    public void setArea() {
        this.area = this.width*this.height;
    }

    @Override
    public String toString() {
        return &quot;Rectangle [width=&quot; + width + &quot;, height=&quot; + height + &quot;, area=&quot; + area + &quot;]&quot;;
    }

}</code></pre><p>运行结果：  </p>
<pre><code>1.原始对象：Rectangle [width=3, height=4, area=12]
2.反序列化后的对象：Rectangle [width=3, height=4, area=null]
3.恢复成原始对象：Rectangle [width=3, height=4, area=12]</code></pre><p><strong><span id="reference">参考资料</span></strong><br><a href="http://stackoverflow.com/questions/910374/why-does-java-have-transient-fields" target="_blank" rel="noopener">http://stackoverflow.com/questions/910374/why-does-java-have-transient-fields</a></p>
<p>原文链接：<a href="https://www.cnblogs.com/chenpi/p/6185773.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenpi/p/6185773.html</a> </p>
]]></content>
  </entry>
  <entry>
    <title>StringTokenizer</title>
    <url>/blog/2019/08/27/StringTokenizer/</url>
    <content><![CDATA[<p>StringTokenizer是一个用来分割字符串的工具类。<br>原文链接：<a href="https://www.cnblogs.com/gnivor/p/4509268.html" target="_blank" rel="noopener">https://www.cnblogs.com/gnivor/p/4509268.html</a></p>
<a id="more"></a>
<h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><pre><code>1.StringTokenizer(String str):构造一个用来解析str的StringTokenizer对象。java默认的分隔符是“空格”、“制表符（&apos;\t&apos;）”、“换行符(&apos;\n&apos;)”、“回车符(&apos;\r&apos;)”。
2.StringTokenizer(String str, String delim) ：构造一个用来解析str的StringTokenizer对象，并提供一个指定的分隔符。
3.StringTokenizer(String str, String delim, boolean returnDelims) ：构造一个用来解析str的StringTokenizer对象，并提供一个指定的分隔符，同时，指定是否返回分隔符。</code></pre><h3 id="2-方法简介"><a href="#2-方法简介" class="headerlink" title="2.方法简介"></a>2.方法简介</h3><p>int     　　countTokens()：返回nextToken方法被调用的次数。如果采用构造函数1和2，返回的就是分隔符数量<br>boolean   hasMoreElements()：返回是否还有分隔符。<br>boolean   hasMoreTokens()：同上<br>String　　nextToken()：返回从当前位置到下一个分隔符的字符串。<br>Object      nextElement()：结果同上，除非声明返回的是Object而不是String<br>String       nextToken(String delim)：同nextToken()，以指定的分隔符返回结果<br>例1：  </p>
<pre><code>String s = &quot;This is a test string&quot;;
StringTokenizer st = new StringTokenizer(s);
System.out.println(&quot;Token Total: &quot;+st.countTokens());
while(st.hasMoreElements()){
    System.out.println(st.nextToken());
}</code></pre><p>运行结果：  </p>
<pre><code>Token Total: 5
This
is
a
test
string</code></pre><p>例2：  </p>
<pre><code>String str = &quot;100|66,55:200|567,90:102|43,54&quot;;

StringTokenizer strToke = new StringTokenizer(str, &quot;:,|&quot;);// 默认不打印分隔符
// StringTokenizer strToke=new StringTokenizer(str,&quot;:,|&quot;,true);//打印分隔符
// StringTokenizer strToke=new StringTokenizer(str,&quot;:,|&quot;,false);//不打印分隔符
while(strToke.hasMoreTokens()){
    System.out.println(strToke.nextToken());
}</code></pre><p>注意，StringTokenizer的分隔符不需要使用转义字符<br>运行结果：  </p>
<pre><code>100
66
55
200
567
90
102
43
54</code></pre><h3 id="3-与split的区别"><a href="#3-与split的区别" class="headerlink" title="3.与split的区别"></a>3.与split的区别</h3><p>String.split()使用正则表达式，而StringTokenizer的只是使用逐字分裂的字符。<br>如果不使用正则表达式(StringTokenizer也不能使用正则表达式)，StringTokenizer在截取字符串中的效率最高。</p>
]]></content>
  </entry>
  <entry>
    <title>synchronized修饰static方法与非static方法的区别</title>
    <url>/blog/2019/08/27/synchronized%E4%BF%AE%E9%A5%B0static%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9Estatic%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>原文链接：<a href="https://www.cnblogs.com/ktao/p/8593914.html" target="_blank" rel="noopener">https://www.cnblogs.com/ktao/p/8593914.html</a>  </p>
<p>1.当synchronized修饰一个static方法时，多线程下，获取的是类锁（即Class本身，注意：不是实例），作用范围是整个静态方法，作用的对象是这个类的所有对象。<br>2.当synchronized修饰一个非static方法时，多线程下，获取的是对象锁（即类的实例对象），作用范围是整个方法，作用对象是调用该方法的对象。  </p>
<p><strong>结论：类锁和对象锁不同，他们之间不会产生互斥。</strong>  </p>
<a id="more"></a>
<p>代码实例：  </p>
<pre><code>public class Test {
    public static void main(String[] args) {
        final SynchronizedDemo demo = new SynchronizedDemo();
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    SynchronizedDemo.staticFunction();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    demo.function();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        t1.start();
        t2.start();
    }
}

class SynchronizedDemo{

    //synchronized修饰非静态方法
    public synchronized void function()throws InterruptedException{
        for(int i=0;i&lt;3;i++){
            Thread.sleep(1000);
            System.out.println(&quot;function running....&quot;);
        }
    }

    //synchronized修饰非静态方法
    public synchronized static void staticFunction()throws InterruptedException{
        for(int i=0;i&lt;3;i++){
            Thread.sleep(1000);
            System.out.println(&quot;staticFunction running....&quot;);
        }
    }

}</code></pre><p>运行结果：  </p>
<pre><code>function running....
staticFunction running....
function running....
staticFunction running....
staticFunction running....
function running....</code></pre>]]></content>
  </entry>
  <entry>
    <title>原地交换两个变量的值</title>
    <url>/blog/2019/08/27/%E5%8E%9F%E5%9C%B0%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<p>就以int a=5,b=10;为例子：  </p>
<p><strong>第一种方法，也是最常见的一种方法</strong>  </p>
<blockquote>
<p>int a=5,b=10;a=a+b; b=a-b; a=a-b;  </p>
</blockquote>
<p><strong>第二种方法，使用异或操作，第一种方法还可能会引起溢出</strong>  </p>
<blockquote>
<p>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;  </p>
</blockquote>
<p>异或的运算规律：两个操作数的位中，相同则结果为0，不同则结果为1。<br>例子中a=5的二进制码为：0101，b=10的二进制码为：1010，因此<br>a=a^b=0101 ^ 1010 = 1111<br>b=a^b=1111 ^ 1010 = 0101  ===&gt;5<br>a=a^b=1111 ^ 0101 = 1010  ===&gt;10</p>
]]></content>
  </entry>
  <entry>
    <title>怎么理解变量(变量是什么)</title>
    <url>/blog/2019/08/27/%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F-%E5%8F%98%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>变量是一块命名的内存区域，以便程序进行访问。变量用来存储数据，随着程序的运行，存储的数据也可能跟着改变。  </p>
<a id="more"></a>
<p>原文链接：<a href="https://blog.csdn.net/NEXTLJP/article/details/78142303" target="_blank" rel="noopener">https://blog.csdn.net/NEXTLJP/article/details/78142303</a><br><strong>举个例子：</strong><br>想一想我们在进行1230x235这个运算的时候我们人是怎么做的呢？我们是不是先找一张草稿纸，在上面写上1230x235然后在进行运算。计算机是人发明的所以肯定是让它以我们人类的方法来进行运算的。计算机在进行1230x235这个运算的时候做的第一件事情就是：找一张草稿纸。草稿纸代表什么？代表存储。我们在草稿纸上写1230x235的目的是存储1230、235这个两个数。有的人可能就会说我不用草稿纸就可以了啊，我可以心算啊。但是你在进行心算的时候是不是知道自己在算什么呢？你为什么知道自己再算1230x235呢？这是因为你的大脑此时充当了一张草稿纸把你这两个数存在了大脑里面。  </p>
<p>所以：在计算之前我们需要做的事情就是先把需要运算的数字存储起来，那我们存到哪里去呢？我们存到我们的变量里面去。变量你可以理解成一个存储空间的名称。就像stack和heap一样就是一个对某一种存储空间的名称。  </p>
<p>我们在写代码的时候就应该这样写：  </p>
<pre><code>int a = 1230;
int b = 235;
int mult = a * b</code></pre><p>可能有些人会这样写：  </p>
<pre><code>int mult = 1230 * 235;</code></pre><p>这样写的话是不是以为我们没存储到1230和235呢？我们还是存储了这两个数字的，只不过是不存在我们自定义的变量中，而是存到另一个存储区域去了。  </p>
<p>上面的例子所讲的变量都是基本类型的变量。对于引用类型的变量里有一些不同，因为引用类型变量存储的并不是一个用来运算的值，而是一个地址。真正的用来运算的值存储在另一个地方，我们称之为堆(heap)。<br>我们来看一下这个例子：  </p>
<pre><code>String s1 = new String(&quot;a&quot;);
String s2 = new String(&quot;a&quot;);
String s3 = s1;
System.out.println(&quot;s1 == s2:&quot;+(s1 == s2));  //false
System.out.println(&quot;s1 == s3:&quot;+(s1 == s3));  //true  </code></pre><p>因为s1和s2变量存储的是地址，s1存储的第一个a字符串在堆区中的地址，s2存储的是第二个a字符串在堆区的地址。所以s1 == s2是false的。s3 == s1是true的(why?)，那是因为s1把它指向a字符串的地址copy了一份然后赋值给了s3，所以此时s1、s3指向a字符串的地址是相同的。  </p>
<p>我们在看一个例子：  </p>
<pre><code>String s1 = &quot;a&quot;;
String s2 = &quot;a&quot;;
String s3 = s1;
System.out.println(&quot;s1 == s2:&quot;+(s1 == s2));  //true
System.out.println(&quot;s1 == s3:&quot;+(s1 == s3));  //true</code></pre><p>注意这个例子中的a字符串不是通过new出来的，所以此时a字符串是存放在常量池中的，而在常量池中a字符串只会存在一份，而s1、s2变量存放的地址都是指向常量池中a字符串的地址，所以它们存放的都是同一个地址值。  </p>
<p><strong>变量构成</strong><br>我们来回想一下变量的定义。是不是一般都是这种类型：  </p>
<pre><code>int i = 6；</code></pre><p>int-变量的数据类型；i-变量名；6-变量存储的值。这三个可以称为一个变量必不可少的要素。</p>
<p><strong>变量名</strong><br>这个的存在就很显而意见了。变量名相当于一个接口，通过变量名来操纵一个存储空间（变量）。比如前面的int i = 6；这一条语句他就进行了以下操作：<br>1.在栈中申请一个存储空间，这个申请到了的存储空间就是我们说的变量。并且给这个存储空间命名为a<br>2.a=2，即通过a这个变量名来操纵存储空间，给变量名为a的存储空间存储一个数据2。  </p>
<p><strong>值</strong><br>变量是存储空间，变量中存储的东西就是值。</p>
]]></content>
  </entry>
  <entry>
    <title>0xffffffff是多少?</title>
    <url>/blog/2019/08/26/0xffffffff%E6%98%AF%E5%A4%9A%E5%B0%91/</url>
    <content><![CDATA[<p><strong>0x表示16进制，所以0xffffffff表示的是一个十六进制数</strong>  </p>
<p>1.将其转为二进制数时，其中f对应的十进制数为15，则对应的二进制是：1111，所以<br>0xffffffff = 1111 1111 1111 1111 1111 1111 1111 1111  </p>
<p>2.转为十进制  </p>
<ul>
<li><p><strong>只是简单的把它当做一个普通的二进制数的话，对应的结果为4294967295</strong>  </p>
<blockquote>
<p>0xffffffff = 15x16<sup>7</sup>+15x16<sup>6</sup>+…+15x16<sup>0</sup>=4294967295  </p>
</blockquote>
</li>
<li><p><strong>当它作为一个数的机器数的原码时，对应的结果为-2147483647</strong>  </p>
<blockquote>
<p>因为f对应二进制码为：1111，最高位为1，表示他是一个负数，那么他的结果应为0x7fffffff(0111 1111 1111 1111 1111 1111 1111 1111)的十进制数的负数。其中0x7fffffff转为十进制数时的结果为2147483647，所以当把0xffffffff作为机器数的原码时对应的结果为-2147483647  </p>
</blockquote>
</li>
<li><p><strong>当把它作为一个补码时，对应的结果为-1</strong>  </p>
<blockquote>
<p>0xffffffff = [1111 1111 1111 1111 1111 1111 1111 1111]<sub>补</sub>=[1111 1111 1111 1111 1111 1111 1111 1110]<sub>反</sub>=[1000 0000 0000 0000 0000 0000 0000 0001]<sub>原</sub>=-1</p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>原码，反码，补码</title>
    <url>/blog/2019/08/24/%E5%8E%9F%E7%A0%81%EF%BC%8C%E5%8F%8D%E7%A0%81%EF%BC%8C%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<p>在上一篇java整型的溢出问题的文章中涉及到了原码，反码，补码的知识，这篇文章就来讲讲这些东西。<br>原文出处：<a href="http://www.cnblogs.com/zhangziqiu/" target="_blank" rel="noopener">http://www.cnblogs.com/zhangziqiu/</a>   </p>
<h2 id="一-机器数和真值"><a href="#一-机器数和真值" class="headerlink" title="一.机器数和真值"></a>一.机器数和真值</h2><p>在学习原码，反码和补码之前，需要先了解机器数和真值的概念。 </p>
<a id="more"></a> 
<h3 id="1、机器数"><a href="#1、机器数" class="headerlink" title="1、机器数"></a>1、机器数</h3><p>一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机中用一个数的最高位存放符号，整数位0，负数位1.  </p>
<p>比如，十进制中的数 +3，计算机字长为8位，转换成二进制就是00000011。如果是 -3，就是10000011。</p>
<p>那么，这里的00000011和10000011就是机器数。  </p>
<h3 id="2-真值"><a href="#2-真值" class="headerlink" title="2.真值"></a>2.真值</h3><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数10000011，其最高位1代表负，其真正数值是-3而不是形式值131(10000011转换成十进制为<code>2^7+2^1+1 = 131</code>)。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。<br>例：0000 0001的真值 = +000 0001 = +1,1000 0001的真值 = -000 0001= -1。  </p>
<h2 id="二-原码，反码，补码的基础概念和计算方法"><a href="#二-原码，反码，补码的基础概念和计算方法" class="headerlink" title="二.原码，反码，补码的基础概念和计算方法"></a>二.原码，反码，补码的基础概念和计算方法</h2><p>在探求为何机器要使用补码之前，让我们先了解原码，反码和补码的概念。对于一个数，计算机要使用一定的编码方式进行存储。原码，反码，补码是机器存储一个具体数字的编码方式。  </p>
<h3 id="1-原码"><a href="#1-原码" class="headerlink" title="1.原码"></a>1.原码</h3><p>原码就是符号位加上真值的绝对值，即用第一位表示符号位，其余位表示值。比如如果是8位二进制：  </p>
<blockquote>
<p>[+1]<sub>原</sub> = 0000 0001<br>[-1]<sub>原</sub> = 1000 0001  </p>
</blockquote>
<p>又因为第一位是符号位，所以8位二进制数的取值范围就是(<strong>原码取值范围</strong>)：  </p>
<blockquote>
<p>[1111 1111,0111 1111]  </p>
</blockquote>
<p>即</p>
<blockquote>
<p>[-127,127]  </p>
</blockquote>
<p>原码是人脑最容易理解和计算的表示方式。  </p>
<h3 id="2-反码"><a href="#2-反码" class="headerlink" title="2.反码"></a>2.反码</h3><p>反码的表示方法是：  </p>
<ul>
<li>正数的反码是其本身</li>
<li>负数的反码是其原码的基础上，符号位不变，其余各个位取反  </li>
</ul>
<blockquote>
<p>[+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub><br>[-1] = [10000001]<sub>原</sub> = [11111110]<sub>反</sub>  </p>
</blockquote>
<p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码在计算。  </p>
<h3 id="3-补码"><a href="#3-补码" class="headerlink" title="3.补码"></a>3.补码</h3><p>补码的表示方式是：  </p>
<ul>
<li>整数的补码就是其本身</li>
<li>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1(即在反码的基础上+1)  </li>
</ul>
<blockquote>
<p>[+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub> = [00000001]<sub>补</sub><br>[-1] = [10000001]<sub>原</sub> = [11111110]<sub>反</sub> = [11111111]<sub>补</sub>  </p>
</blockquote>
<p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。  </p>
<h2 id="三-为何要使用原码，反码和补码"><a href="#三-为何要使用原码，反码和补码" class="headerlink" title="三.为何要使用原码，反码和补码"></a>三.为何要使用原码，反码和补码</h2><p>在开始深入学习之前，我的学习建议是先”死记硬背”上面的原码，反码和补码的表示方式以及计算方法。<br>现在我们知道了计算机可以有三种编码方式表示一个数。对于正数因为三种编码方式的结果都相同：  </p>
<blockquote>
<p>[+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub> = [00000001]<sub>补</sub>  </p>
</blockquote>
<p>所以不过多解释。但是对于负数：  </p>
<blockquote>
<p>[-1] = [10000001]<sub>原</sub> = [11111110]<sub>反</sub> = [11111111]<sub>补</sub>  </p>
</blockquote>
<p>可见原码，反码和补码是完全不同的。既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？  </p>
<p>首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。(真值概念在本文中最开头)。但是对于计算机，加减乘除已经是最基础的运算，要设计的尽量简单。计算机辨别“符号位”显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即：1-1 = 1+（-1）=0，所以机器可以只有加法而没有减法，这样计算器的设计就更简单了。  </p>
<p>于是人们开始探索将符号位参与运算，并且只保留加法的方法，首先来看原码：<br>计算十进制的表达式：1-1=0  </p>
<blockquote>
<p>1 - 1 = 1 + (-1) = [00000001]<sub>原</sub> + [10000001]<sub>原</sub> = [10000010]<sub>原</sub> = -2  </p>
</blockquote>
<p>如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。<br>为了解决原码做减法的问题，出现了反码：<br>计算十进制的表达式：1-1=0  </p>
<blockquote>
<p>1-1=1+(-1)=[00000001]<sub>原</sub> + [10000001]<sub>原</sub> = [00000001]<sub>反</sub> + [11111110]<sub>反</sub> = [11111111]<sub>反</sub> = [10000000]<sub>原</sub> = -0  </p>
</blockquote>
<p>发现用反码计算减法，结果的真值部分是正确的。而唯一的问题其实就出现在”0”这个特殊的数值上。虽然人们理解上+0和-0是一样的，但是0带符号是没有任何意义的。而且会有[0000 0000]<sub>原</sub>和[1000 0000]<sub>原</sub>两个编码表示0。<br>于是补码的出现，解决了0的符号以及两个编码的问题：  </p>
<blockquote>
<p>1-1=1+(-1)=[0000 0001]<sub>原</sub>+[1000 0001]<sub>原</sub>=[0000 0001]<sub>补</sub>+[1111 1111]<sub>补</sub>=[0000 0000]<sub>补</sub>=[0000 0000]<sub>原</sub>  </p>
</blockquote>
<p>这样0用[0000 0000]表示，而以前出现问题的-0则不存在了。而且可以用[1000 0000]表示-128:  </p>
<blockquote>
<p>(-1) + (-127) = [1000 0001]<sub>原</sub>+[1111 1111]<sub>原</sub>=[1111 1111]<sub>补</sub>+[1000 0001]<sub>补</sub> = [1000 0000]<sub>补</sub>  </p>
</blockquote>
<p>-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]<sub>补</sub>就是-128。<strong>但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示。</strong><br>使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数，这就是为什么8位二进制，使用原码或反码表示的范围为[-127,+127]，而使用补码表示的范围为[-128,127]。<br><strong>因为机器使用补码，所以对于编程中常用到的32位int类型，可以表示范围是:[-2<sup>31</sup>,2<sup>31</sup>-1]因为第一位表示的是符号位。而使用补码表示时又可以多保存一个最小值。</strong>  </p>
<h2 id="四-原码，反码，补码-再深入"><a href="#四-原码，反码，补码-再深入" class="headerlink" title="四.原码，反码，补码 再深入"></a>四.原码，反码，补码 再深入</h2><p>计算机巧妙的把符号位参与运算，并且将减法变成了加法，背后蕴含了怎么样的数学原理呢？<br>将钟表想象成是一个1位的12进制数。如果当前时间是6点，我希望将时间设置成4点，需要怎么做呢？我们可以：  </p>
<ul>
<li>1.往回拨2个小时：6-2 = 4</li>
<li>2.往前拨10个小时：（6+10）mod 12 =4</li>
<li>3.往前拨10+12=22个小时：（6+22）mod 12 = 4</li>
</ul>
<p>2,3方法中mod是指取模操作，16 mod 12 = 4即用16除以12后的余数是4。<br>所以钟表往回拨(减法)的结果可以用往前拨(加法)替代！<br>现在的焦点就落在了如何用一个正数来代替一个负数。上面的例子我们能感觉出来一些端倪，发现一些规律。<br>首先介绍一个数学中相关的概念：同余。  </p>
<h3 id="同余的概念"><a href="#同余的概念" class="headerlink" title="同余的概念"></a>同余的概念</h3><p>两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余<br>记作 a ≡ b (mod m)<br>读作 a 与 b 关于模 m 同余。<br>举例说明：  </p>
<blockquote>
<p>4 mod 12 = 4<br>16 mod 12 = 4<br>28 mod 12 = 4  </p>
</blockquote>
<p>所以4,16,28关于模12同余。</p>
<h3 id="负数取模"><a href="#负数取模" class="headerlink" title="负数取模"></a>负数取模</h3><p>正数进行mod运算是很简单的，但是负数呢?<br>下面是关于mod运算的数学定义：  </p>
<blockquote>
<p><strong>x mod y = x-y⌊x / y⌋, for y≠0</strong>  </p>
</blockquote>
<p>上面的公式的意思是：<br>x mod y等于x减去y乘上x与y的商的下界。<br>以-3mod2举例：  </p>
<blockquote>
<p>-3 mod 2<br>=-3-2x⌊-3/2⌋<br>=-3-2x⌊-1.5⌋<br>=-3-2x(-2)<br>=-3+4 = 1  </p>
</blockquote>
<p>所以：  </p>
<blockquote>
<p>(-2) mod 12 =12-2=10<br>(-4) mod 12 =12-4=8<br>(-5) mod 12 =12-5=7  </p>
</blockquote>
<h3 id="开始证明"><a href="#开始证明" class="headerlink" title="开始证明"></a>开始证明</h3><p>再回到时钟的问题上：  </p>
<blockquote>
<p>回拨2小时 = 前拨10小时<br>回拨4小时 = 前拨8小时<br>回拨5小时= 前拨7小时  </p>
</blockquote>
<p>注意，这里发现的规律!  
结合上面学到的同余的概念。实际上：  </p>
<blockquote>
<p>(-2) mod 12 = 10<br>10 mod 12 = 10  </p>
</blockquote>
<p>-2与10是同余的。  </p>
<blockquote>
<p>(-4) mod 12 =8<br>8 mod 12 =8  </p>
</blockquote>
<p>-4与8是同余的。<br>距离成功越来越近了，要实现用正数替代负数，只需要运用同余数的两个定理：<br>反身性：   </p>
<blockquote>
<p>a ≡ a(mod m)  </p>
</blockquote>
<p>这个定理是很显而易见的。<br>线性运算定理：  </p>
<blockquote>
<p>如果a ≡ b(mod m),c ≡ d(mod m)那么：<br>(1)a ± c = b ± d(mod m)<br>(2)a * c = b * d(mod m)  </p>
</blockquote>
<p>如果想看这个定理的证明，请看：<a href="http://baike.baidu.com/view/79282.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/79282.htm</a><br>所以：  </p>
<blockquote>
<p>7 ≡ 7(mod 12)<br>(-2) ≡ 10(mod 12)<br>7 - 2 ≡ 7 + 10(mod 12)  </p>
</blockquote>
<p>现在我们为一个负数，找到了他的正数同余数。但是并不是7-2=7+10，而是7-2≡7+10（mod 12），即计算结果额余数相等。<br>接下来回到二进制的问题上，看一下：2-1=1的问题。  </p>
<blockquote>
<p>2-1=2+(-1)=[0000 0010]<sub>原</sub>+[1000 0001]<sub>原</sub>=[0000 0010]<sub>反</sub>+[1111 1110]<sub>反</sub>  </p>
</blockquote>
<p>先到这一步，-1的反码表示是1111 1110。如果这里将[1111 1110]认为是原码，则[1111 1110]<sub>原</sub>=-126,这里将符号位移去，即认为是126。<br>发现有如下规律：  </p>
<blockquote>
<p>(-1) mod 127 = 126<br>126  mod 127 = 126  </p>
</blockquote>
<p>即：  </p>
<blockquote>
<p>(-1) ≡ 126(mod 127)<br>2-1 ≡ 2+126(mod 127)  </p>
</blockquote>
<p>2-1与2+126的余数结果是相同的！而这个余数，正是我们的期望的计算结果：2-1=1<br>所以说一个数的反码，实际上是这个数对于一个膜的同余数。而这个膜并不是我们的二进制，而是所能表示的最大值!这就和钟表一样，转了一圈后总能找到在可表示范围内的一个正确的数值!  
而2+126很显然相当于钟表转过了一轮，而因为符号位是参与计算的，正好和溢出事物最高位形成正确的运算结果。<br>既然反码可以将减法变成加法，那么现在计算机使用的补码呢？为什么在反码的基础上加1，还能得到正确的结果？  </p>
<blockquote>
<p>2-1=2+(-1)=[0000 0010]<sub>原</sub>+[1000 0001]<sub>原</sub>=[0000 0010]<sub>补</sub>+[1111 1111]<sub>补</sub>  </p>
</blockquote>
<p>如果把[1111 1111]当成原码，去除符号位，则：  </p>
<blockquote>
<p>[0111 1111]<sub>原</sub> = 127  </p>
</blockquote>
<p>其实，在反码的基础上+1，只是相当于增加了膜的值：  </p>
<blockquote>
<p>(-1) mod 128 = 127<br>127  mod 128 = 127<br>2-1 ≡ 2+127(mod 128)  </p>
</blockquote>
<p>此时相当于每128个刻度转一轮。所以用补码表示的运算结果最小值和最大值应该是[-128,128]<br>但是由于0的特殊情况，没有办法表示128，所以补码的范围是[-128,127]  </p>
]]></content>
  </entry>
  <entry>
    <title>java整型溢出和下溢问题(转载整理)</title>
    <url>/blog/2019/08/23/java%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA%E5%92%8C%E4%B8%8B%E6%BA%A2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>提问：java是如何处理整型溢出和下溢问题的？<br><strong>java根据类型的大小，将计算结果中的对应低阶字节存储到对应的值里面。</strong><br>这里我们以int整型为例子。<br>java中的int是32位有符号整数类型，其最大值是0x7fffffff,最小值则是0x80000000。其取值范围在-2147483648 ～ 2147483647之间。当int类型的运算结果超出了这个范围时则发生了溢出，而且不会有任何异常抛出。  </p>
<a id="more"></a>
<pre><code>public static void main(String[] args) {

    int max = Integer.MAX_VALUE;
    int min = Integer.MIN_VALUE;
    System.out.println(&quot;最大值===&gt;&quot;+max);
    System.out.println(&quot;最小值===&gt;&quot;+min);
    System.out.println(&quot;最大值+1===&gt;&quot;+(max+1));
    System.out.println(&quot;最小值-1===&gt;&quot;+(min-1));

}</code></pre><p>运行结果：  </p>
<pre><code>最大值===&gt;2147483647
最小值===&gt;-2147483648
最大值+1===&gt;-2147483648
最小值-1===&gt;2147483647</code></pre><p>观察上述结果，我们会发现： </p>
<ul>
<li>当结果超出了Integer的最大表示范围时，结果变成了负数</li>
<li>当结果超出了Integer的最小表示范围时，结果变成了整数</li>
</ul>
<p><strong>这里涉及到原码，反码，补码相关知识，不做过多讲述，如需了解，请查看此<a href="/blog/2019/08/24/原码，反码，补码/" target="_blank">文章</a></strong><br>那么上述结论对吗？是不是只要两个正数的操作（加法或乘法）发生溢出时结果就会变成负数呢?  </p>
<p>接下来再看一个例子：  </p>
<pre><code>public static void main(String[] args) {
    int num = 907654321;
    System.out.println(num * 16);
    System.out.println(num * 16L);
}</code></pre><p>运行结果： </p>
<pre><code>1637567248
14522469136</code></pre><p>通过上述例子居然发现int和int类型相乘的结果虽然发生了溢出，但结果并不是负数，还是一个正数。那么java的溢出的逻辑到底是怎样的？又是怎样得到这个结果的呢？<br>我们先看看下面这个例子：  </p>
<pre><code>public static void main(String[] args) {
    int num = 907654321;
    System.out.println(Integer.toHexString(num));
    System.out.println(Long.toHexString(num * 16L));
    System.out.println((int)((num * 16L) &amp; 0xffffffff));
}</code></pre><p>运行结果：  </p>
<pre><code>3619b4b1
3619b4b10
1637567248</code></pre><p>大家有没有可能发现神奇的一点：<code>(int)((num * 16L) &amp; 0xffffffff) == num * 16</code><br>在java Language Specifiction中所述(JSL 15.7.1)  </p>
<blockquote>
<p>If an integer multiplication overflows, then the result is the low-order bits of the mathematical product as represented in some sufficiently large two’s-complement format. As a result, if overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two operand values.  </p>
</blockquote>
<p>也就是说int型正数相乘，结果只会保留低32位，高位会抛弃掉。所以num * 16L的值与0xffffffff做位与操作（即取后32位）就可以得到实际运算的结果了。（不知道0xfffffff是什么的，可以查看此<a href="/blog/2019/08/26/0xffffffff是多少/" target="_blank">文章</a>）  </p>
<blockquote>
<p>System.out.println(Integer.toBinaryString(num * 16));//<code>1100001 10011011 01001011 00010000</code>（总共是32位二进制，前面的0被省略了）<br>System.out.println(Long.toBinaryString(num * 16L));//11<code>01100001 10011011 01001011 00010000</code><br>System.out.println(Long.toBinaryString((int)((num * 16L) &amp; 0xffffffff)));//<code>1100001 10011011 01001011 00010000</code>  </p>
</blockquote>
<p>那么下面下面的这些语句有没有bug呢？  </p>
<pre><code>long MonthNanoSeconds1 = 30 * 24 * 3600 * 1000 * 1000;
long MonthNanoSeconds2 = 30 * 24 * 3600 * 1000 * 1000L;</code></pre><p>将一个大的数赋值给long型变量，好像没什么问题。但是要注意到java是先计算右边的值，再赋值给long变量的。在计算右值的过程中(int型相乘)发生溢出，然后将溢出后截断的值赋值给变量。而在第二行语句中由于java的运算规则从左到右，再与最后一个long型的1000相乘之前就已经溢出，所以结果也不对。正确的写法应该如下：  </p>
<pre><code>long MonthNanoSeconds = 30L * 24 * 3600 * 1000 * 1000;</code></pre><p>这里实际上涉及到了java类型提升的知识点:<br><strong>数值提升</strong><br>int型整数相乘并不会进行类型提升(type promotion)，在widening conversion(JSL 5.1.2)写到：  </p>
<blockquote>
<p>f any of the operands is of a reference type, unboxing conversion(JSL 5.1.8) is performed.<br>Then:<br>If either operand is of type double, the other is converted to double.<br>Otherwise, if either operand is of type float, the other is converted to float.<br>Otherwise, if either operand is of type long, the other is converted to long.<br>Otherwise, both operands are converted to type int.</p>
</blockquote>
<p>大概意思就是说：  </p>
<blockquote>
<p>如果任一操作数的类型为double，则另一个操作数将转换为double。<br>否则，如果其中一个操作数的类型为float，则另一个操作数将转换为float。<br>否则，如果其中一个操作数的类型为long，则另一个操作数将转换为long。<br>否则，两个操作数都将转换为int类型。  </p>
</blockquote>
<p>所以下述语句不会发生溢出:  </p>
<pre><code>byte a = 40;
byte b = 50;
byte c = 100;
int d = a * b / c;</code></pre><p>虽然40*50=2000已经超过了byte的范围，但是java compile在计算a、b之前就都已经将它们转换成int类型了，所以不会有编译问题。  </p>
<p>那我们该如何防止溢出呢？  </p>
<ul>
<li>使用类型提升，int型转换成long型，long型转换成BigDecimal</li>
<li>使用Math.addExact和Math.multiplyExact,溢出时会抛出异常</li>
<li>可以先使用最大最小数判断一下，比如<code>if(b&gt;Integer.MAX_VALUE/a)</code>  </li>
</ul>
<p>更多内容请参考原文：<a href="https://njucz.github.io/2017/08/16/java-int%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">https://njucz.github.io/2017/08/16/java-int%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java中的向上类型转换和向下类型转换</title>
    <url>/blog/2019/08/22/Java%E4%B8%AD%E7%9A%84%E5%90%91%E4%B8%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%90%91%E4%B8%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="一、向上类型转换"><a href="#一、向上类型转换" class="headerlink" title="一、向上类型转换"></a>一、向上类型转换</h3><blockquote>
<p>通俗地讲即是将子类对象转为父类对象。此处父类对象可以是接口。</p>
</blockquote>
<a id="more"></a>
<p>看下面的例子：  </p>
<pre><code>class Animal {
    public void eat(){
        System.out.println(&quot;animal eatting...&quot;);
    }
}

class Bird extends Animal{
    @Override
    public void eat(){
        System.out.println(&quot;bird eatting...&quot;);
    }
    public void fly(){  
        System.out.println(&quot;bird flying...&quot;);  
    }
}

public class Main{
    public static void main(String[] args) {
        Animal a = new Bird();//向上转型
        a.eat();
        //a.fly();//编译时出错,b虽指向子类对象，但此时丢失fly()方法  
    }
}</code></pre><p>运行结果：  </p>
<pre><code>bird eatting...</code></pre><p>此处调用的是子类的eat()方法。原因：b实际指向的是Bird子类，故调用时会调用子类本身的方法。需要注意的是向上转型时b会遗失除与父类共有的其他方法。比如本例中的fly方法不在为B所有。  </p>
<p>向上转型的好处：<br>我们来查看下面一个例子：  </p>
<pre><code>public class Main {
    public static void main(String[] args) {
        Main.dosleep(new Male());
        Main.dosleep(new Female());
    }

    public static void dosleep(Human h){
        h.sleep();
    }
}

class Human{
    public void sleep(){
        System.out.println(&quot;Human sleep..&quot;);
    }
}
class Male extends Human{
    @Override
    public void sleep(){
        System.out.println(&quot;Male sleep..&quot;);
    }
}
class Female extends Human{
    @Override
    public void sleep(){
        System.out.println(&quot;Female  sleep..&quot;);
    }
}</code></pre><p>输出结果： </p>
<pre><code>Male sleep..
Female  sleep..</code></pre><p>这里以父类作为参数，调用时用子类作为参数，就是利用了向上转型。这样使代码变得更简洁。不然的话，如果dosleep以子类对象为参数，则有多少个子类就需要写多少个函数。这也体现了JAVA的抽象编程思想。  </p>
<h3 id="二、向下类型转换"><a href="#二、向下类型转换" class="headerlink" title="二、向下类型转换"></a>二、向下类型转换</h3><blockquote>
<p>与向上类型相反，即是把父类对象转为子类对象。向下转换也可以说是指由一个通用类型转换成一个具体的类型，在继承结构上向下进行。</p>
<p>看下面的例子：  </p>
</blockquote>
<pre><code>public class Main {
    public static void main(String[] args) {
        Girl g1 = new MMGirl();//向上转型
        g1.smile();

        MMGirl mmg = (MMGirl)g1;//向下转型，编译和运行都不会出错
        mmg.smile();
        mmg.c();

        Girl g2 = new Girl();
        try {
            MMGirl mmg1 = (MMGirl)g2;//不安全的向下转型，编译不会出错，但运行时会出错
            mmg1.smile();
            mmg1.c();
        } catch (Exception e) {
            System.out.println(&quot;我出错了哦!&quot;);
            e.printStackTrace();
        }

        if(g2 instanceof MMGirl){
            System.out.println(&quot;我进来了哦!&quot;);
            MMGirl mmg1 = (MMGirl)g2;
            mmg1.smile();
            mmg1.c();
        }
    }
}

class Girl{
    public void smile(){
        System.out.println(&quot;girl smile()...&quot;);
    }
}

class MMGirl extends Girl{
    @Override
    public void smile(){
        System.out.println(&quot;MMGirl smile()...&quot;);
    }

    public void c(){
        System.out.println(&quot;MMGirl c()...&quot;);
    }
}</code></pre><p>输出结果：  </p>
<pre><code>MMGirl smile()...
MMGirl smile()...
MMGirl c()...
我出错了哦!
java.lang.ClassCastException: Girl cannot be cast to MMGirl at Main.main(Main.java:18)</code></pre><p>Girl g1=new MMGirl(); //向上转型<br>    g1.smile();<br>    MMGirl mmg=(MMGirl)g1; //向下转型,编译和运行皆不会出错<br>这里的向下转型是安全的。因为g1指向的是子类对象。<br>而  
Girl g2=new Girl();<br>    MMGirl mmg1=(MMGirl)g2; //不安全的向下转型,编译无错但会运行会出错<br>运行出错：<br>java.lang.ClassCastException: Girl cannot be cast to MMGirl at Main.main(Main.java:18)<br>如代码所示，可以通过instanceof来防止出现异常。  </p>
<p>到了这里你可能会发现，向下转型是不是很傻，我要是用子类实例对象，先是生成子类实例赋值给父类引用，再将父类引用向下强转给子类引用，这不是多此一举吗？我不向上转型也不向下转型，直接用子类实例就行了。<br>然后给人一种错觉，向下转型没啥用处额。这种想法是错误的，下面我们来看个例子就知道了，通过此例子来了解下这种特性的意义和使用场景。<br>新建一个电子产品接口，如下：  </p>
<pre><code>public interface Electronics {

}</code></pre><p>很简单，什么方法都没有。  </p>
<p>新建一个ThinkPad笔记本类，并实现电子产品接口：  </p>
<pre><code>public class ThinkPad implements Electronics {

    //ThinkPad引导方法
    public void boot(){
        System.out.println(&quot;welcome,I am ThinkPad&quot;);
    }

    //使用ThinkPad编程
    public void program(){
        System.out.println(&quot;using ThinkPad program&quot;);
    }
}</code></pre><p>新建一个mouse类，并实现电子产品接口：</p>
<pre><code>public class Mouse implements Electronics {

    //鼠标移动
    public void move(){
        System.out.println(&quot;move the mouse&quot;);
    }

    //鼠标点击
    public void onClick(){
        System.out.println(&quot;a click of the mouse&quot;);
    }
}</code></pre><p>新建一个Keyboard键盘类，并实现电子产品接口：  </p>
<pre><code>public class Keyboard implements Electronics {

    //使用键盘输入
    public void input(){
        System.out.println(&quot;using Keyboard input&quot;);
    }
}</code></pre><p>接下来，我们想象一个场景：我们去商城购买电子产品，电子产品很多，比如笔记本电脑，鼠标，键盘，步步高点读机等等，这些都属于电子产品。电子产品是抽象的。好，那么我们决定买一台ThinkPad,一个鼠标和一个键盘。<br>这时，我们需要一个购物车来装这些电子产品吧。我们可以添加进购物车，然后通过购物车还能知道存放的电子产品数量，能拿到对应的电子产品。<br>那么，一个购物车类就出来了，如下：  </p>
<pre><code>public class ShopCar {

    //list用来存放电子产品
    private List&lt;Electronics&gt; list = new ArrayList&lt;&gt;();

    //添加电子产品
    public void add(Electronics e){
        list.add(e);
    }

    //获取购物车电子产品数量
    public int getSize(){
        return list.size();
    }

    //获取相应的电子产品
    public Electronics getListItem(int position){
        return list.get(position);
    }
}</code></pre><p>可以看到 List<electronics> 用了泛型的知识，然后你们可能会觉得比较疑惑为什么是放 Electronics 的泛型，而不是放Thinkpad，Mouse，Keyboard，Phone等？<br>打个比方，如果我们的集合定义为List<thinkpad>，肯定是无法放入鼠标Mouse的，这里难道要生成3个集合，然后我们的add方法也要写3个？但是如果我有100个呢？难道要定义100个集合？这个就太可怕了。<br>所以之前，我们写了一个Electronics接口，提供了一个Electronics的标准，然后让每一个子类都去实现这个接口。<br>实际上这里又涉及到了向上转型的知识点，我们虽然在add方法将子类实例传了进来存放，但子类实例在传进去的过程中也进行了向上转型。<br>所以，此时购物车里存放的子类实例对象，由于向上转型成Electronics，已经丢失了子类独有的方法，以上述例子来分析，ThinkPad实例就是丢失了boot()和program()这两个方法，而Mouse实例就是丢失了move()和onClick()这两个方法。</thinkpad></electronics></p>
<p>但是实际使用ThinkPad或Mouse或Keyboard时，这种情况肯定不是我们想要的。  </p>
<p>接着我们写一个测试类Test去测试购物车里的电子产品。  </p>
<p>测试类Test如下：  </p>
<pre><code>public class Test {

    public static final int THINKPAD = 0;
    public static final int MOUSE = 1;
    public static final int KEYBOARD = 2;

    public static void main(String[] args) {

        //添加进购物车
        ShopCar car = new ShopCar();
        car.add(new ThinkPad());
        car.add(new Mouse());
        car.add(new Keyboard());

        //获取大小
        System.out.println(&quot;购物车存放的电子产品数量为 ——&gt; &quot;+car.getSize());

        //开始测试thinkpad电脑
        ThinkPad thinkPad = (ThinkPad)car.getListItem(THINKPAD);
        thinkPad.boot();
        thinkPad.program();

        System.out.println(&quot;-------------------&quot;);

        //开始测试mouse鼠标
        Mouse mouse = (Mouse)car.getListItem(MOUSE);
        mouse.move();
        mouse.onClick();

        System.out.println(&quot;-------------------&quot;);

        //开始测试keyboard键盘
        Keyboard keyboard = (Keyboard)car.getListItem(KEYBOARD);
        keyboard.input();
    }
}</code></pre><p>运行结果：  </p>
<pre><code>购物车存放的电子产品数量为 ——&gt; 3
welcome,I am ThinkPad
using ThinkPad program
-------------------
move the mouse
a click of the mouse
-------------------
using Keyboard input</code></pre><p>举个例子分析：  </p>
<blockquote>
<p>//开始测试thinkpad电脑<br>ThinkPad thinkPad = (ThinkPad)car.getListItem(THINKPAD);<br>thinkPad.boot();<br>thinkPad.program();  </p>
</blockquote>
<p><code>car.getListItem(THINKPAD)</code>这句代码是获取到Electronics类型的实例。不是ThinkPad的实例<br>通过向下转型，赋值给子类引用  </p>
<blockquote>
<p>ThinkPad thinkPad = (ThinkPad)car.getListItem(THINKPAD);</p>
</blockquote>
<p>这样子类实例又重新获得了因为向上转型而丢失的方法（boot和program）  </p>
<p>总结一下吧，很多时候，我们需要把很多种类的实例对象，全部扔到一个集合。（这句话很重要）<br>在这个例子里就是把Thinkpad笔记本，Mouse鼠标，KeyBoard键盘等实例对象，全部扔到一个Shopcar购物车集合。<br>但是肯定不可能给他们每个种类都用一个独立的集合去存放吧，这个时候我们应该寻找到一个标准，接口就是一个标准。这些都是各种电子产品，抽象成电子产品。然后一个Electronics接口就出来了。<br>在回到刚才，我们把很多种类的实例对象全部扔到一个集合。或许这样比较好理解：把很多种类的子类实例对象全部扔到存放父类实例的集合。<br>经过了这个过程，子类实例已经赋值给了父类引用（即完成了向上转型），但很遗憾的丢失了子类扩展的方法。<br>很好的是Java语言有个向下转型的特性，让我们可以重新获得丢失的方法，即强转回子类<br>所以我们需要用到子类实例的时候，就从那个父类集合里拿出来向下转型就可以了，一样可以使用子类实例对象<br>原文链接：<a href="https://blog.csdn.net/xyh269/article/details/52231944" target="_blank" rel="noopener">https://blog.csdn.net/xyh269/article/details/52231944</a>  </p>
<p><strong>题外话：父类为什么不能直接转为子类？</strong><br>这里涉及到一个安全问题，我们都知道对子类实现向上转型得到的 父类对象是安全的，因为子类会完全继承父类的方法，我们向上转型为父类，当我们调用父类的方法其实在子类实现中是能完全找到的。反之向下转型是不安全的，我们子类除了完全继承父类的方法外还会扩展自己的方法，所以我们在调用子类方法时可能在父类实现中是找不到的，所以向下转型不安全。  </p>
<p>说到这里让我们来看下面这个例子：  </p>
<pre><code>HTTPServletrequest  req = (HTTPServletrequest)new ServletRequest();

public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse resp = (HttpServletResponse) response;

  }</code></pre><p>你会发现我对ServletRequest进行了强转，然后编译运行都没问题。可是后来一想不对啊，我们不仅实现了向下转型，同时还调用了子类的扩展方法，是父类没有的，可是却实现了。这不是自相矛盾吗？其实看一下API和一些资料你就会发现，这和我们所学的并不冲突！我们先看API：  </p>
<blockquote>
<p>public interface HttpServletRequest extends ServletRequest  </p>
</blockquote>
<p>你会发现原来HttpServletRequest和ServletRequest都是接口，他们都只定义了方法却没有提供相关的实现。所以我们看到的ServletRequest request中的request对象其实并不是我们ServletRequest的一个具体实现。<br>这里我们要看我们提出的问题是否安全，其实主要是看request对象的具体实现类究竟是继承的哪个接口，如果继承自HttpServletRequest接口那么我们向下转型使用HttpServletRequest接口的方法就是安全的。测试如下：  </p>
<pre><code> if(request instanceof HttpServletRequest){
    System.out.println(&quot;我是右边类的实例&quot;);
}</code></pre><p>输出：我是右边类的实例，证明我们的request对象的确是HttpServletRequest的一个实例。</p>
]]></content>
  </entry>
  <entry>
    <title>java中native的用法</title>
    <url>/blog/2019/08/21/java%E4%B8%ADnative%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>在看java源码时，我们有时能看见用native关键字声明的方法：<br>public native String intern();</p>
<p><strong>那么native方法是什么?</strong><br>native方法是非java代码实现的方法。<br>native关键字修饰一个方法，那么说明这个方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（例如C和C++）实现的文件中。java语言本身不能对操作系统底层进行访问和操作，但是可用过JNI接口调用其他语言来实现对底层的访问。<br>JNI是java本地接口(Java Native Interface)，是一个本地编程接口，他是java软件开发工具箱(Java Software Development Kit,SDK)的一部分。JNI允许java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本地应用程序中，从而允许程序员从本地代码内部调用Java代码。</p>
<a id="more"></a>
<p><strong>native的用法：</strong>  </p>
<ul>
<li>1.编写带有native声明的方法的java类 (java文件)</li>
<li>2.使用javac命令编译编写的java类(class文件)</li>
<li>3.使用javah -jin ****来生成后缀名为.h的头文件（.h的文件）</li>
<li>4.使用其他语言(C、C++)实现本地方法</li>
<li>5.将本地方法编写的文件生成动态链接库(dll文件)</li>
</ul>
<p><strong>例子：</strong><br>1.java文件</p>
<pre><code>public class HelloWorld {

    public native void hello(String name);

    static{
        System.loadLibrary(&quot;hello&quot;);
    }

    public static void main(String[] args){
        new HelloWorld().hello(&quot;jni&quot;);
    }
}</code></pre><p>2.javac命令编译  </p>
<pre><code>javac HelloWorld.java</code></pre><p>3.生成.h文件（注意：javah NativeTest后边不跟.class）  </p>
<pre><code>javah -jni HelloWorld</code></pre><p>如果执行出现报错信息：<br>错误: 找不到 ‘NativeTest’ 的类文件。<br>执行以下命令(在想要存储生成的.h文件目录下 javah + -classpath + 项目包目录前 + -jni + 包名类名):  </p>
<pre><code>javah  -classpath E:/workspace_sts/JAVA/src/build/classes -jni test.HelloWorld</code></pre><p>执行成功后会在对应目录下生成一个.h后缀的文件，文件内容如下:  </p>
<pre><code>/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class test_HelloWorld */

#ifndef _Included_test_HelloWorld
#define _Included_test_HelloWorld
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     test_HelloWorld
 * Method:    hello
 * Signature: (Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_test_HelloWorld_hello
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif</code></pre><p>4.实现本地方法(编写C文件：HelloWorldImpl.c)  </p>
<pre><code>#include &lt;jni.h&gt;
#include &quot;test_HelloWorld.h&quot;
#include &lt;stdio.h&gt;
JNIEXPORT void JNICALL Java_test_HelloWorld_hello(JNIEnv *env,jobject obj,jstring name){

    const char *str;
    str = (*env)-&gt;GetStringUTFChars(env,name,NULL);
    if(str == NULL){
        return;
    }

    printf(&quot;Hello World! %s \n&quot;,str);
    return;
}</code></pre><p>5.生成动态链接库，编译c文件产生dll文件，在控制台下使用cl -i调试</p>
<pre><code>cl -I &quot;G:\Program Files\Java\jdk1.8.0_111\include&quot; -I &quot;G:\Program Files\Java\jdk1.8.0_111\include\win32&quot; -LD HelloWorldImpl.c -Fehello.dll</code></pre><p>注意：生成的dll文件名在选项-Fe后面配置，这里是hello，因为在HelloWorld.java文件中我们loadLibary的时候使用的名字是hello。当然这里修改之后那里也需要修改。<br>执行成功后会返回如下结果：  </p>
<pre><code>用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.16.27031.1 版
版权所有(C) Microsoft Corporation。保留所有权利。

HelloWorldImpl.c
Microsoft (R) Incremental Linker Version 14.16.27031.1
Copyright (C) Microsoft Corporation.  All rights reserved.

/dll
/implib:hello.lib
/out:hello.dll
HelloWorldImpl.obj
  正在创建库 hello.lib 和对象 hello.exp</code></pre><p><strong>★关键 hello.dll文件需要存放到 jdk的bin目录或者system32下面</strong></p>
<p>具体内容请参考以下文章：<br><a href="https://www.cnblogs.com/b3051/p/7484501.html" target="_blank" rel="noopener">https://www.cnblogs.com/b3051/p/7484501.html</a><br><a href="http://blog.sina.com.cn/s/blog_4d18e4240100gfgy.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4d18e4240100gfgy.html</a><br><a href="https://blog.csdn.net/origin100/article/details/7305222" target="_blank" rel="noopener">https://blog.csdn.net/origin100/article/details/7305222</a>  </p>
<p>6.运行java程序，输出Hello World! jni<br>如果运行出现Can’t load IA 32-bit .dll on a AMD 64-bit platform错误，请参考以下文章：<a href="https://blog.csdn.net/cbbbc/article/details/45772063" target="_blank" rel="noopener">https://blog.csdn.net/cbbbc/article/details/45772063</a></p>
]]></content>
  </entry>
  <entry>
    <title>面向对象的三大基本特征，七大基本原则</title>
    <url>/blog/2019/08/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%EF%BC%8C%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h3 id="1-三大基本特征"><a href="#1-三大基本特征" class="headerlink" title="1)三大基本特征"></a>1)三大基本特征</h3><ul>
<li>1、<a href="#package" title="#package">封装</a></li>
<li>2、<a href="#extends" title="#extends">继承</a></li>
<li>3、<a href="#polymorphism" title="#polymorphism">多态</a></li>
</ul>
<h3 id="2）六大基本原则-设计模式的七大基本原则"><a href="#2）六大基本原则-设计模式的七大基本原则" class="headerlink" title="2）六大基本原则(设计模式的七大基本原则)"></a>2）六大基本原则(设计模式的七大基本原则)</h3><ul>
<li>1、<a href="#SRP" title="#SRP">单一职责原则（SRP）</a>  </li>
<li>2、<a href="#OCP" title="#OCP">开放封闭原则（OCP）</a>  </li>
<li>3、<a href="#LSP" title="#LSP">里氏替换原则（LSP）</a>  </li>
<li>4、<a href="#DIP" title="#DIP">依赖倒置原则（DIP）</a>  </li>
<li>5、<a href="#ISP" title="#ISP">接口隔离原则（ISP）</a></li>
<li>6、<a href="#LKP" title="#LKP">迪米特|最少知道原则（LKP）</a></li>
<li>7、<a href="#CAPP" title="#CAPP">合成复用原则（CAPP）</a><a id="more"></a>

</li>
</ul>
<h1 id="一、三大基本特征：封装、继承、多态"><a href="#一、三大基本特征：封装、继承、多态" class="headerlink" title="一、三大基本特征：封装、继承、多态"></a>一、三大基本特征：封装、继承、多态</h1><h2 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a><span id="package">1、封装</span></h2><p style="text-indent:2em">封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改数据的访问级别，将抽象得到的数据和行为(或功能)相结合，<b>形成一个有机的整体</b>，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。</p>
<p style="text-indent:2em">封装的目的是为了增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。(打个比方：例如我们使用String类的equals()方法，我们不需要知道equals()方法的具体内部实现，它是如何进行比较内容然后得到结果，我们只需要调用这个方法接口并传入另一个字符串(a.equals(b))，就能得到我们想要的结果)。</p>
<p style="text-indent:2em">面向对象的不就是使用程序处理事情时以对象为中心去分析吗，与面向过程不同，面向过程关心处理的逻辑、流程等问题，而不关心事件的主体。而面向对象即面向主体，所以我们在解决问题时应该先进性对象的封装(对象是封装类的实例，比如张三是人，人是一个封装类，张三只是对象中的一个实例、一个对象)。比如我们日常生活中的小兔子、小绵羊都可以封装成为一个类。</p>
<p style="text-indent:2em">比如兔子的属性有两只耳朵、四条腿、一双眼睛、三瓣嘴等；行为(功能)有跑、跳、吃素等。</p>  

<h2 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a><span id="extends">2、继承</span></h2><p style="text-indent:2em">继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。<b>继承就是子类继承父类的特征和行为</b>，使得子类对象(实例)具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。类似于下面这个图：</p>
<img src="/blog/img/2019/08/20/1.png">
<p style="text-indent:2em">我们在上面已经封装了兔子这个类，其他动物也一样可以进行封装。在封装过程中我们发现兔子、绵羊这两个类具有相似的功能或特性如吃草，所以我们可以<b>抽取共有特征和方法形成高一层的类</b>，如这里的草食动物、食肉动物。继承之间是子父类的关系。继承的机制可以很好的描述一个类的生态，也提高了代码的复用率，在java中的Object类是所有类的超类，常称作上帝类。</p>

<h2 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a><span id="polymorphism">3、多态</span></h2><p style="text-indent:2em">多态是指同一个行为具有多个不同表现形式或形态的能力。是指一个类实例(对象)的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这就意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们(那些操作)可以通过相同的方式给予调用。</p>
<p style="text-indent:2em"><b>多态的优点：</b></p>
<li>1.消除类型之间的耦合关系</li>
<li>2.可替换性</li>
<li>3.可扩充性</li>
<li>4.接口性</li>
<li>5.灵活性</li>
<li>6.简化性</li>
<p style="text-indent:2em"><b>多态存在的三个必要条件：</b></p>
<li>继承(接口)</li>
<li>重写(子类继承父类后对父类方法进行重新定义)</li>
<li>父类引用指向子类对象</li>
<p style="text-indent:2em">简言之，<b>多态其实是在继承的基础上的</b>。比如说今天我们要去动物园参观动物，那么你说我们去参观兔子、参观绵羊、参观狮子、参观豹子都是对的，但你不能说我们去参观汽车。在这个例子中，子类具有多态性：除了使用自己的身份，还能充当父类。</p>

<p>下面来看一个例子（接口也能间接达到继承的效果，这里以继承的方式为例）：</p>
<pre><code>//汽车类
abstract class Car { 
    // 汽车名称 
    abstract String getName(); 

    // 获得汽车售价 
    abstract int getPrice(); 
} 

// 宝马 
class BMW extends Car { 
    public String getName() { 
      return &quot;BMW&quot;; 
    } 

    public int getPrice() { 
      return 300000; 
    } 
} 

// 奇瑞QQ 
class CheryQQ extends Car { 
    public String getName() { 
      return &quot;CheryQQ&quot;; 
    } 

    public int getPrice() { 
      return 20000; 
    } 
} 

// 汽车出售店 
public class CarShop { 
    // 售车收入 
    private int money = 0; 

    // 卖出一部车 
    public void sellCar(Car car) { 
       System.out.println(&quot;车型：&quot; + car.getName() + &quot; 单价：&quot; + car.getPrice()); 
       // 增加卖出车售价的收入 
       money += car.getPrice(); 
    } 

    // 售车总收入 
    public int getMoney() { 
      return money; 
    } 

    public static void main(String[] args) { 
        CarShop aShop = new CarShop(); 
        // 卖出一辆宝马 
        aShop.sellCar(new BMW()); 
        // 卖出一辆奇瑞QQ 
        aShop.sellCar(new CheryQQ()); 
        System.out.println(&quot;总收入：&quot; + aShop.getMoney()); 
    } 
} </code></pre><p>运行结果：</p>
<pre><code>车型：BMW  单价：300000
车型：CheryQQ  单价：20000
总收入：320000</code></pre><p>继承是多态得以实现的基础。从字面上理解，多态就是一种类型（都是Car类型）表现出多种状态（宝马汽车的名称是BMW，售价是300000；奇瑞汽车的名称是CheryQQ，售价是2000）。将一个方法调用同这个方法所属的主体（也就是对象或类）关联起来叫做绑定，分前期绑定和后期绑定两种。下面解释一下它们的定义：</p>
<p>前期绑定：在程序运行之前进行绑定，由编译器和连接程序实现，又叫做静态绑定。比如static方法和final方法，注意，这里也包括private方法，因为它是隐式final的。<br>后期绑定：在运行时根据对象的类型进行绑定，由方法调用机制实现，因此又叫做动态绑定，或者运行时绑定。除了前期绑定外的所有方法都属于后期绑定。</p>
<p>多态就是在后期绑定这种机制上实现的。多态给我们带来的好处是消除了类之间的耦合关系，使程序更容易扩展。比如在上例中，新增加一种类型汽车的销售，只需要让新定义的类继承Car类并实现它的所有方法，而无需对原有代码做任何修改，CarShop类的sellCar(Car car)方法就可以处理新的车型了。新增代码如下：</p>
<pre><code>// 桑塔纳汽车 
class Santana extends Car { 
  public String getName() { 
    return &quot;Santana&quot;; 
  } 

  public int getPrice() { 
    return 80000; 
  } 
}</code></pre><h1 id="二、六大基本原则"><a href="#二、六大基本原则" class="headerlink" title="二、六大基本原则"></a>二、六大基本原则</h1><h2 id="1、单一职责原则（SRP）"><a href="#1、单一职责原则（SRP）" class="headerlink" title="1、单一职责原则（SRP）"></a><span id="SRP">1、单一职责原则（SRP）</span></h2><p style="text-indent:2em"><b>一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作。</b></p>
<p style="text-indent:2em">比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要if else判断是哪种情况，从类结构上来说将会是分臃肿。</p>  

<h2 id="2、开放封闭原则（OCP）"><a href="#2、开放封闭原则（OCP）" class="headerlink" title="2、开放封闭原则（OCP）"></a><span id="OCP">2、开放封闭原则（OCP）</span></h2><p style="text-indent:2em"><b>对象或实体应该对扩展开放，对修改封闭。</b></p>
<p style="text-indent:2em">更改封闭即是在我们对模块进行扩展时勿需对原有代码和DLL进行修改或重新编译文件！这个原则对我们设计类的时候很有帮助，坚持这个原则就必须尽量考虑接口封装，抽象机制和多态技术。</p>  

<h2 id="3、里氏替换原则（LSP）"><a href="#3、里氏替换原则（LSP）" class="headerlink" title="3、里氏替换原则（LSP）"></a><span id="LSP">3、里氏替换原则（LSP）</span></h2><p style="text-indent:2em"><b>在对象x为类型T时q(x)成立，那么当S是T的子类时，对象y为类型S时q(y)也应成立(即对父类的调用同样适用于子类)。</b></p> 
<p style="text-indent:2em"><b>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。 </b></p>  
这里来看个例子（举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。）：  

<pre><code>class A {
    public int func1(int a, int b) {
        return a - b;
    }
}

public class Client {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(&quot;100-50=&quot; + a.func1(100, 50));
        System.out.println(&quot;100-80=&quot; + a.func1(100, 80));
    }
}</code></pre><p>运行结果：  </p>
<pre><code>100-50=50
100-80=20</code></pre><p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：<br>两数相减。<br>两数相加，然后再加100。</p>
<p>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：  </p>
<pre><code>class B extends A {
    public int func1(int a, int b) {
        return a + b;
    }

    public int func2(int a, int b) {
        return func1(a, b) + 100;
    }
}

public class Client {
    public static void main(String[] args) {
        B b = new B();
        System.out.println(&quot;100-50=&quot; + b.func1(100, 50));
        System.out.println(&quot;100-80=&quot; + b.func1(100, 80));
        System.out.println(&quot;100+20+100=&quot; + b.func2(100, 20));
    }
}</code></pre><p>运行结果：  </p>
<pre><code>100-50=150
100-80=180
100+20+100=220</code></pre><p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。<br>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。<br>它包含以下4层含义：  </p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件(即方法的形参)要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件(即方法的返回值)要比父类更严格。</li>
</ul>
<p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？<br>后果就是：你写的代码出问题的几率将会大大增加。</p>
<h2 id="4、依赖倒置原则（DIP）"><a href="#4、依赖倒置原则（DIP）" class="headerlink" title="4、依赖倒置原则（DIP）"></a><span id="DIP">4、依赖倒置原则（DIP）</span></h2><p style="text-indent:2em"><b>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。具体实现应该依赖于抽象，而不是抽象依赖于实现。</b></p>
<p style="text-indent:2em">可以这样理解，上面我举例子的时候先说了兔子和绵羊，然后才推出草食动物。但是我们继续认识了牛、马等草食动物，我们会发现我们需要不断调整草食动物的描述，这样程序会变得僵化，所以我们不应该让子类依赖于实体，不应该让父类模块依赖于子类模块。所以我们需要将草食动物设计为抽象类，即<b>抽象类或接口</b>。这样下层只需要实现相应的细节而不会影响父类。</p>  

<h2 id="5、接口隔离原则（ISP）"><a href="#5、接口隔离原则（ISP）" class="headerlink" title="5、接口隔离原则（ISP）"></a><span id="ISP">5、接口隔离原则（ISP）</span></h2><p style="text-indent:2em"><b>不应强迫客户端实现它一个用不上的接口，或是说客户端不应该被强迫依赖他们不使用的方法，使用多个专门的接口比使用单个接口要好得多！</b></p>
<p style="text-indent:2em">比如，为了减少接口的定义，将许多类似的方法都放在一个接口中，最后会发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，这种承诺当然是越少越好，越精炼越好，过多的承诺带来的就是你的大量精力和时间去维护！</p> 

<h2 id="6、迪米特-最少知道原则（LKP）"><a href="#6、迪米特-最少知道原则（LKP）" class="headerlink" title="6、迪米特|最少知道原则（LKP）"></a><span id="LKP">6、迪米特|最少知道原则（LKP）</span></h2><p style="text-indent:2em"><b>一个类应该对其他对象有最少的了解；一个类应该对自己需要耦合或调用的类知道的最少，类的内部如何实现、如何复杂都与调用者或依赖者没关系，调用者或依赖者只需要知道他需要的方法即可，其他的一概不关心。</b></p>
<p style="text-indent:2em">类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也大。只与直接的朋友通信。每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。</p>  
例子：一般在使用框架的时候，框架的开发者会抽象出一个类供外部调用，而这个主要的类像是一个中介一样去调用框架里面的其他类，恰恰框架里面其他类一般都是不可访问(调用)的，这个框架就遵循了迪米特原则(Law of Demeter)，其他开发人员只关心调用的方法，并不需要关心功能具体如何实现。  
这里我们来看个例子：  
<img src="/blog/img/2019/08/21/1.jpg">  

<p>如果Lily和Jack自己做hamburg那么就会与Vegetable、Meat、Bread产生千丝万缕关系。上图，则由KFC来做，这样Lily和Jack就只与Hamburg有关关联，与材料就没有关联了。  </p>
<h2 id="7、合成复用原则（CAPP）"><a href="#7、合成复用原则（CAPP）" class="headerlink" title="7、合成复用原则（CAPP）"></a><span id="CAPP">7、合成复用原则（CAPP）</span></h2><p style="text-indent:2em"><b>尽量使用聚合、组合的方式，而不是使用继承。</b></p>
<p style="text-indent:2em">其实大部分人刚开始学会用面向对象的继承时，感觉它既新颖又功能强大，所以只要可以用，就都用上继承。这就好比是’有了新锤子，所有的东西看上去都成了钉子’。但事实上，很多情况用继承会带来麻烦。比如，<b>对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须被重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</b></p>
<p style="text-indent:2em">合成/聚合复用原则的好处是，<b>优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</b></p>


<h1 id="三、参考文章"><a href="#三、参考文章" class="headerlink" title="三、参考文章"></a>三、参考文章</h1><p><a href="https://www.cnblogs.com/fzz9/p/8973315.html" target="_blank" rel="noopener">https://www.cnblogs.com/fzz9/p/8973315.html</a><br><a href="https://www.jianshu.com/p/068b2d0ce4e6" target="_blank" rel="noopener">https://www.jianshu.com/p/068b2d0ce4e6</a><br><a href="https://my.oschina.net/u/3198904/blog/1633355?from=timeline" target="_blank" rel="noopener">https://my.oschina.net/u/3198904/blog/1633355?from=timeline</a></p>
]]></content>
  </entry>
  <entry>
    <title>Locale类的使用</title>
    <url>/blog/2019/08/20/Locale%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Locale类用来根据语言环境来动态调整程序的输出<br>Locale类有如下几个构造器：  </p>
<pre><code>创建一个通用英语的locale.
Locale l1 = new Locale(&quot;en&quot;);
创建一个加拿大英语的locale.
Locale l2 = new Locale(&quot;en&quot;,&quot;CA&quot;);
创建一个美式英语的locale，硅谷的英语
Locale l3 = new Locale(&quot;en&quot;, &quot;US&quot;, &quot;SiliconValley&quot;);</code></pre><a id="more"></a>

<p>Locale类有一些预定义的Locale对象实例：</p>
<pre><code>Locale Name　　　　　　　                  Locale
===============================================
Locale.CHINA　　　　　　                   zh_CN
Locale.CHINESE　　　　　                  zh
Locale.SIMPLIFIED_CHINESE　　            zh_CN
Locale.TRADITIONAL_CHINESE　　　         zh_TW
Locale.PRC　　　　　　　                  zh_CN
Locale.TAIWAN　　　　　　                  zh_TW
Locale.ENGLISH　　　　　                  en
Locale.UK　　　　　　                     en_GB
Locale.US　　　　　　                     en_US
Locale.FRANCE　　　　　                　 fr_FR
Locale.FRENCH　　　　　　                 fr</code></pre><p>例子：  </p>
<pre><code>public class LocaleTest {
    public static void main(String[] args) {
        //下面的例子是德国locale实例以英语(默认情况下是作者的主机),德语和法语提供了信息：
        Locale deLocale = new Locale(&quot;de&quot;, &quot;DE&quot;);
        Locale frLocale = new Locale(&quot;fr&quot;, &quot;FR&quot;);
        System.out.println(&quot;Default language name (default):&quot; + deLocale.getDisplayLanguage());
        System.out.println(&quot;German language name (German): &quot; + deLocale.getDisplayLanguage(deLocale));
        System.out.println(&quot;German language name (French): &quot; + deLocale.getDisplayLanguage(frLocale));
    }
}</code></pre><p>输出结果：  </p>
<pre><code>Default language name (default):德文
German language name (German): Deutsch
German language name (French): allemand</code></pre><p>具体信息请参考文章：<a href="https://blog.csdn.net/iteye_13551/article/details/81932722" target="_blank" rel="noopener">https://blog.csdn.net/iteye_13551/article/details/81932722</a></p>
]]></content>
  </entry>
  <entry>
    <title>while与do/while循环的区别</title>
    <url>/blog/2019/08/20/while%E4%B8%8Edo-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>while结构在循环的开始判断下一个迭代是否应该继续。do/while结构在循环的结尾来判断是否将继续下一轮迭代。do结构至少会执行一次循环体。  </p>
<a id="more"></a>
<p>不多说上例子：  </p>
<pre><code>public class WhileAndDoWhileTest {

    public static void main(String[] args) {
        int count = 0;
        while(count&gt;0){
            System.out.println(&quot;执行了while循环&quot;);
        }

        do{
            System.out.println(&quot;执行了do/while循环&quot;);
        }while(count&gt;0);

    }
}</code></pre><p>输出结果：  </p>
<pre><code>执行了do/while循环</code></pre>]]></content>
  </entry>
  <entry>
    <title>SimpleTimeZone</title>
    <url>/blog/2019/08/20/SimpleTimeZone/</url>
    <content><![CDATA[<p>SimpleTimeZone提供公历日期支持。它是时区(TimeZone)的具体子类，它表示与公历使用的时区。  </p>
<ul>
<li>这个类持有GMT的偏移，称为原始偏移。</li>
<li>这个类还拥有开始和结束的夏令时安排的规则。  </li>
</ul>
<p>例子：  </p>
<a id="more"></a>
<pre><code>public class SimpleTimeZoneTest {

    public static void main(String[] args) {
        //此构造一个SimpleTimeZone与给定基准时区GMT和时区的ID与保存白昼没有时间表偏移。
        // create simple time zone object     
        SimpleTimeZone stz = new SimpleTimeZone(820, &quot;GMT&quot;);
        // create date
         Date date = new Date(2012, 04, 23);

         // check day light
         //inDaylightTime 方法用于查询，如果给定的日期是在夏令时。
         //其他类方法请查看API文档
         boolean daylight=stz.inDaylightTime(date); 

         // checking the value of day light      
         System.out.println(&quot;Is in day light : &quot; + daylight);


    }
}</code></pre><p>输出结果：  </p>
<pre><code>Is in day light : false</code></pre>]]></content>
  </entry>
  <entry>
    <title>ResourceBundle类的简单使用</title>
    <url>/blog/2019/08/19/ResourceBundle%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>ResourceBundle用来存储指定语言环境的资源，应用程序可以根据运行时的语言环境来加载这些资源，从而提供不同语言的展示。  </p>
<p>测试及验证：<br>下面我们来模拟一个多语言的环境  </p>
<pre><code>定义四个资源文件：res_en_US.properties、res_zh_CN.properties、res_zh.properties、res.properties
res_en_US.properties：cancelKey=cancel
res_zh_CN.properties：cancelKey=\u53D6\u6D88（取消）
res_zh.properties：cancelKey=\u53D6\u6D88zh（取消zh）
res.properties：cancelKey=\u53D6\u6D88default（取消default）
命名规则按照：资源名+_语言_国别.properties，每个资源文件中定义了本地化的信息，那么系统如何取到对应的资源文件呢？</code></pre><p>代码：  </p>
<a id="more"></a>
<pre><code>public static void main(String[] args) {
        /**
         * 其中new Locale(&quot;zh&quot;, &quot;CN&quot;);这个对象就告诉了程序你的本地化信息，就拿这个来说吧：
         * 程序首先会去classpath下寻找res_zh_CN.properties
         * 若不存在，那么会去找res_zh.properties，若还是不存在，则会去寻找res.properties，
         * 要还是找不到的话，那么就该抛异常了：MissingResourceException
         */
        ResourceBundle bundle = ResourceBundle.getBundle(&quot;res&quot;, new Locale(&quot;zh&quot;, &quot;CN&quot;));
        String cancel = bundle.getString(&quot;cancelKey&quot;);
        System.out.println(cancel);//取消

        bundle = ResourceBundle.getBundle(&quot;res&quot;, new Locale(&quot;zh&quot;));
        cancel = bundle.getString(&quot;cancelKey&quot;);
        System.out.println(cancel);//取消zh

        bundle = ResourceBundle.getBundle(&quot;res&quot;, Locale.US);
        cancel = bundle.getString(&quot;cancelKey&quot;);
        System.out.println(cancel);//cancel

        bundle = ResourceBundle.getBundle(&quot;res&quot;, Locale.getDefault());
        cancel = bundle.getString(&quot;cancelKey&quot;);
        System.out.println(cancel);//取消

        bundle = ResourceBundle.getBundle(&quot;res&quot;, Locale.GERMAN);
        cancel = bundle.getString(&quot;cancelKey&quot;);
        System.out.println(cancel);//取消   why?    
}</code></pre><p>输出结果：  </p>
<pre><code>取消
取消zh
cancel
取消
取消</code></pre><p>这里前四个都在我们的预期范围之内，但是最后一个GERMAN，应该会去使用res.properties这个资源包吧？怎么使用了res_zh_CH.properties？  </p>
<pre><code>原来ResourceBundle为我们提供了一个fallback（也就是一个备用方案），这个备用方案就是根据当前系统的语言环境来得到的本地化信息。
所以若是找不到GERMAN的，之后就会去找CHINA了，所以找到了res_zh_CH.properties这个资源包
这点我也是看了源代码才明白的，下面就贴上一些关键的源代码：
ResourceBundle baseBundle = null;
for (Locale targetLocale = locale;targetLocale != null;
     targetLocale = control.getFallbackLocale(baseName, targetLocale)) {// 这里就是去拿备用方案的
         // do something 我们暂时不关心
}
跟踪control.getFallbackLocale(baseName, targetLocale)看看备用方案到底是什么？
public Locale getFallbackLocale(String baseName, Locale locale) {
    if (baseName == null) {
         throw new NullPointerException();
    }
    Locale defaultLocale = Locale.getDefault();
    return locale.equals(defaultLocale) ? null : defaultLocale;
}</code></pre><p>除此之外我们还可以将类作为ResourceBundle，使用类，还可以使用除字符串值外的其它类型资源。与属性文件类似，可以创建带有 bundle base名称与语言后缀的一组类。</p>
<pre><code>在i18n文件夹下创建两个类，分别为：
import java.util.ListResourceBundle;

public class MyClassBundle extends ListResourceBundle{

    @Override
    protected Object[][] getContents() {
        return contents;
    }

    private Object[][] contents = {  
            { &quot;price&quot;   , new Double(10.00) },  
            { &quot;currency&quot;, &quot;EUR&quot; },  
    };

}

public class MyClassBundle_da extends ListResourceBundle {  

    @Override  
    protected Object[][] getContents() {  
        return contents;  
    }  

    private Object[][] contents = {  
            { &quot;price&quot;   , new Double(75.00) },  
            { &quot;currency&quot;, &quot;DKK&quot; },  
    };  

}</code></pre><p>然后编写一个测试类：</p>
<pre><code>public class ListResourceBundleTest {

    //将类作为ResourceBundle
    /**
     * 也可以使用一组类来获取资源，使用类，还可以使用除字符串值外的其它类型资源。
     * 与属性文件类似，可以创建带有 bundle base名称与语言后缀的一组类。
     */
    public static void main(String[] args) {

        Locale locale = new Locale(&quot;de&quot;, &quot;DE&quot;); //no bundle for German -&gt; default  
        ResourceBundle bundle = ResourceBundle.getBundle(&quot;i18n.MyClassBundle&quot;, locale);  

        System.out.println(&quot;price   : &quot; + bundle.getObject(&quot;price&quot;));  
        System.out.println(&quot;currency: &quot; + bundle.getObject(&quot;currency&quot;));  


        locale = new Locale(&quot;da&quot;, &quot;DK&quot;);  
        bundle = ResourceBundle.getBundle(&quot;i18n.MyClassBundle&quot;, locale);  

        System.out.println(&quot;price   : &quot; + bundle.getObject(&quot;price&quot;));  
        System.out.println(&quot;currency: &quot; + bundle.getObject(&quot;currency&quot;));  

    }
}</code></pre><p>输出结果：  </p>
<pre><code>price   : 10.0
currency: EUR
price   : 75.0
currency: DKK</code></pre>]]></content>
  </entry>
  <entry>
    <title>GregorianCalendar日历类的使用</title>
    <url>/blog/2019/08/19/GregorianCalendar%E6%97%A5%E5%8E%86%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>GregorianCalendar(格林威治时间)是<a href="/blog/2019/08/19/Calendar日历类的简单使用/">Calendar</a>的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。</p>
<p>这里用GregorianCalendar写一个例子，来打印系统当前日历月份信息</p>
<a id="more"></a>

<pre><code>import java.util.Calendar;
import java.util.GregorianCalendar;

public class Test {
    public static void main(String[] args) {
        GregorianCalendar gc = new GregorianCalendar();
        //获取这是这个月的第几天
        int day = gc.get(Calendar.DATE);
        //当前月份
        int month = gc.get(Calendar.MONTH);
        //计算这个月的第一天是星期几
        gc.set(Calendar.DATE, 1);
        int firstweek = gc.get(Calendar.DAY_OF_WEEK);

        //输出第一行星期名
        String[] weeks = {&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;,&quot;Sun&quot;};
        for (int i = 0; i &lt; weeks.length; i++) {
            System.out.printf(&quot;%4s&quot;,weeks[i]);
        }
        System.out.println();
        //打印第二行缩进
        for (int i = 1; i &lt; (firstweek-1); i++) {
            System.out.printf(&quot;%4s&quot;,&quot;&quot;);
        }
        while(gc.get(Calendar.MONTH)==month){

            System.out.printf(&quot;%3d&quot;,gc.get(Calendar.DATE));
            if(gc.get(Calendar.DATE) == day){
                System.out.print(&quot;*&quot;);
            }else{
                System.out.print(&quot; &quot;);
            }
            //打印一周后换行
            if(gc.get(Calendar.DAY_OF_WEEK) == 1){
                System.out.println();
            }
            //加一天
            gc.add(Calendar.DATE, 1);
        }
    }
}</code></pre><p>输出结果：  </p>
<pre><code>Mon Tue Wed Thu Fri Sat Sun
             1   2   3   4 
 5   6   7   8   9  10  11 
12  13  14  15  16  17  18 
19* 20  21  22  23  24  25 
26  27  28  29  30  31 </code></pre>]]></content>
  </entry>
  <entry>
    <title>Calendar日历类的简单使用</title>
    <url>/blog/2019/08/19/Calendar%E6%97%A5%E5%8E%86%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Calendar 类是一个抽象类，为我们提供了关于日期计算的相关功能，比如：年、月、日、时、分、秒的展示和计算。  </p>
<pre><code>YEAR(年份) MONTH(月份从0开始) DATE(一月的某天) HOUR(指示上午或下午的小时)
HOUR_F_DAY(指示一天中的小时) DAY_OF_WEEK(一个星期中的某天) DAY_OF_MONTH(一个月中的某天) DAY_OF_YEAR(一年中的某天)
DAY_OF_WEEK_IN_MONTH(一个月中的第几个星期，从1号开始算起，1-7号才算第一周) 
WEEK_OF_MONTH(指示当前月中的星期数，或者说是本月的第几周，日历上显示的第几周) 
WEEK_OF_YEAR(指示当前年终的星期数，或者说是本年的第几周)</code></pre><p>其中关于DAY_OF_WEEK_IN_MONTH需要注意的地方是：  </p>
<pre><code>1.在网上DAY_OF_WEEK_IN_MONTH有另外一种说法，表示某个月的第几个星期几，与DAY_OF_WEEK一起使用，可以指定唯一日期(这个说法也没错)
2.DAY_OF_WEEK_IN_MONTH是从每个月1号开始算第一周的第一天,与WEEK_OF_MONTH不同(WEEK_OF_MONTH是日历上显示是第几周，就是第几周)
3.所以DAY_OF_MONTH 1 到 7 总是对应于 DAY_OF_WEEK_IN_MONTH 1；8 到 14 总是对应于 DAY_OF_WEEK_IN_MONTH 2，依此类推。
4.又因为1-7号一定把星期一到星期日都占全了，所以不管是哪天，都是本月的第一个星期N。8-14号，一样，不管是哪天，前面1-7号一定有一个星期N了，那么它就是第二个星期N。
具体信息请参考此文章：http://www.mytju.com/classcode/news_readNews.asp?newsID=97</code></pre><a id="more"></a>

<p>使用说明：  </p>
<pre><code>public class CalendarTest {

    private static SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);

    public static void main(String[] args) {
        //通过 Calendar类的静态方法getInstance获得。
        Calendar ca = Calendar.getInstance();
        System.out.println(&quot;初始化日期===&gt;&quot;+dateFormat.format(ca.getTime()));
        ca.clear();

        //void set(int field, int value) 将给定的日历字段设置为给定值。
        ca.set(Calendar.YEAR, 2019);
        ca.set(Calendar.MONTH, 7);//注意,Calendar对象默认一月为0 ,这里指的是8月份
        ca.set(Calendar.DATE, 7);
        ca.set(Calendar.HOUR, 12);
        ca.set(Calendar.MINUTE, 30);
        ca.set(Calendar.SECOND, 00);
        System.out.println(&quot;指定日期1===&gt;&quot;+dateFormat.format(ca.getTime()));
        ca.clear();

        //void set(int year,int month,int date)//设置年月日。
        ca.set(2019, 7, 8);
        System.out.println(&quot;指定日期2===&gt;&quot;+dateFormat.format(ca.getTime()));
        ca.clear();

        //void set(int year, int month, int date, int hourOfDay, int minute)//设置年月日时分
        ca.set(2019, 7, 8,13,50);
        System.out.println(&quot;指定日期3===&gt;&quot;+dateFormat.format(ca.getTime()));
        ca.clear();

        //void set(int year, int month, int date, int hourOfDay, int minute, int second)//设置年月日时分秒
        ca.set(2019, 7, 8,13,50,30);
        System.out.println(&quot;指定日期4===&gt;&quot;+dateFormat.format(ca.getTime()));
        ca.clear();

        //void setTime(Date date);//使用给定的 Date 设置此 Calendar 的时间。
        ca.setTime(new Date());
        System.out.println(&quot;指定日期5===&gt;&quot;+dateFormat.format(ca.getTime()));
        ca.clear();

        ca.set(2019, 7, 7,22,30,30);

        String[] mon = {&quot;一月&quot;,&quot;二月&quot;,&quot;三月&quot;,&quot;四月&quot;,&quot;五月&quot;,&quot;六月&quot;,&quot;七月&quot;,&quot;八月&quot;,&quot;九月&quot;,&quot;十月&quot;,&quot;十一月&quot;,&quot;十二月&quot;};  
        String[] week = {&quot;&quot;,&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;};

        //int  get(int field)//返回给定日历字段的值。如：int month = acobj.get(Calendar.MONTH);
        int month = ca.get(Calendar.MONTH);
        System.out.println(&quot;当前月份====&gt;&quot;+mon[month]);

        //获取当前日期 Date
        Date date = ca.getTime();
        System.out.println(&quot;当前日期====&gt;&quot;+date);

        //返回从1970.1.1   00：00：00到该日历的毫秒数
        long ms = ca.getTimeInMillis();
        System.out.println(&quot;获取毫秒数====&gt;&quot;+ms);

        //当前月份天数
        int day = ca.getActualMaximum(Calendar.DAY_OF_MONTH);
        System.out.println(&quot;本月份的天数====&gt;&quot;+day);

        System.out.println(&quot;指示上午或下午的小时===&gt;&quot;+ca.get(Calendar.HOUR));
        System.out.println(&quot;指示一天中的小时===&gt;&quot;+ca.get(Calendar.HOUR_OF_DAY));
        System.out.println(&quot;一个星期中的某天===&gt;&quot;+week[ca.get(Calendar.DAY_OF_WEEK)]);//星期天算第一天,这里返回的是4，代表星期三
        System.out.println(&quot;一个月中的某天===&gt;&quot;+ca.get(Calendar.DAY_OF_MONTH));
        System.out.println(&quot;一年中的某天===&gt;&quot;+ca.get(Calendar.DAY_OF_YEAR));
        //一个月中的第几个星期
        System.out.println(&quot;DAY_OF_WEEK_IN_MONTH===&gt;&quot;+ca.get(Calendar.DAY_OF_WEEK_IN_MONTH));//返回1
        //本月的第几个星期几
        String s = String.format(&quot;本月的第%s个%s&quot;, ca.get(Calendar.DAY_OF_WEEK_IN_MONTH),week[ca.get(Calendar.DAY_OF_WEEK)]);
        System.out.println(&quot;本月的第几个星期几===&gt;&quot;+s);//本月的第1个星期三
        //本月的第几周
        System.out.println(&quot;WEEK_OF_MONTH===&gt;&quot;+ca.get(Calendar.WEEK_OF_MONTH));//返回2
        //本年的第几周
        System.out.println(&quot;WEEK_OF_MONTH===&gt;&quot;+ca.get(Calendar.WEEK_OF_YEAR));
        //返回一周的第一天
        System.out.println(&quot;返回一周的第一天===&gt;&quot;+ca.getFirstDayOfWeek());

        //日期增减计算 例如：下个月今天减一天
        ca.add(Calendar.MONTH, 1);
        ca.add(Calendar.DATE, -1);
        System.out.println(&quot;日期增减计算,下个月今天减一天====&gt;&quot;+dateFormat.format(ca.getTime()));


    }
}</code></pre><p>输出结果:  </p>
<pre><code>初始化日期===&gt;2019-08-19 15:34:30
指定日期1===&gt;2019-08-07 12:30:00
指定日期2===&gt;2019-08-08 00:00:00
指定日期3===&gt;2019-08-08 13:50:00
指定日期4===&gt;2019-08-08 13:50:30
指定日期5===&gt;2019-08-19 15:34:30
当前月份====&gt;八月
当前日期====&gt;Wed Aug 07 22:30:30 CST 2019
获取毫秒数====&gt;1565188230000
本月份的天数====&gt;31
指示上午或下午的小时===&gt;10
指示一天中的小时===&gt;22
一个星期中的某天===&gt;星期三
一个月中的某天===&gt;7
一年中的某天===&gt;219
DAY_OF_WEEK_IN_MONTH===&gt;1
本月的第几个星期几===&gt;本月的第1个星期三
WEEK_OF_MONTH===&gt;2
WEEK_OF_MONTH===&gt;32
返回一周的第一天===&gt;1
日期增减计算,下个月今天减一天====&gt;2019-09-06 22:30:30</code></pre>]]></content>
  </entry>
  <entry>
    <title>final、finally、finalize的用法</title>
    <url>/blog/2019/08/14/final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1）final关键字"><a href="#1）final关键字" class="headerlink" title="1）final关键字"></a>1）final关键字</h1><blockquote>
<p>final关键字可以用来声明变量、方法和类。接口里声明的变量默认是final的。final类无法继承，也就是没有子类。这么做是出于基础类型的安全考虑，比如String和Integer。这样也使得编译器进行一些优化，更容易保证线程的安全性。final方法无法重写(可以重载)。final变量的值不能改变。</p>
</blockquote>
<ul>
<li><p>1.声明变量</p>
<ul>
<li><p>在定义的时候初始化</p>
</li>
<li><p>final变量可以在初始化块中初始化，不可以在静态初始化块中初始化</p>
</li>
<li><p>静态final变量可以在定义时初始化，也可以在静态初始化块中初始化，不可以在初始化块中初始化</p>
</li>
<li><p>final变量还可以在类的构造器中初始化，但是静态final变量不可以  </p>
<a id="more"></a>    
<pre><code>public class FinalTest {

    public final int A = 10;//在定义时初始化
    public final int B;{B=20;}//在初始化代码块中初始化

    //非静态final变量不能在静态初始化块中初始化
    //public final int C;static{C=30;}

    //静态常量,可以在定义时初始化
    public static final int STATIC_D = 40;

    //静态常量，可以在静态初始化块中初始化
    public static final int STATIC_E;static{STATIC_E=50;};

    //静态变量不能在初始化块中初始化
    //public static final int STATIC_F;{STATIC_F=60;};

    public final int G;

    //静态final变量不可以在构造器中初始化
    //public static final int STATIC_H;

    //在构造器中初始化
    public FinalTest(){
        G = 70;
        //静态final变量不可以在构造器中初始化
        //STATIC_H=80;

        //给final的变量进行二次赋值时，编译会报错。
        //A = 99;
        //STATIC_D = 99;

    }
    //final变量未被初始化时，编译时就会报错
    //public final int I;

    //静态final变量未被初始化时，编译时就会报错
    //public static final STATIC_J;
}</code></pre></li>
</ul>
</li>
<li><p>2.声明方法</p>
<ul>
<li><p>当final定义一个方法时，他表示这个方法不可以被子类重写（可以重载），但不影响他被子类继承  </p>
<pre><code>public class FinalTest2 {

    public final void TestFinal(){
        System.out.println(&quot;父类--这是一个final方法&quot;);
    }

    public static void main(String[] args) {
        SubClass sc = new SubClass();
        sc.TestFinal();
        sc.TestFinal(&quot;&quot;);
    }
}

class SubClass extends FinalTest2{
    //子类无法重写（override父类的final方法，否则编译时会报错
    /*@Override
    public void TestFinal(){
        System.out.println(&quot;子类--重写final方法&quot;);
    }*/
    //但是可以重载
    public void TestFinal(String param){
        System.out.println(&quot;子类--重载父类TestFinal方法&quot;);
    }
}</code></pre></li>
</ul>
</li>
<li><p>3.声明类</p>
<ul>
<li><p>当final定义一个类时，该类不可被继承，因此编译器在处理时会把它所有的方法当做final的，因此final类比普通类拥有更高的效率。而由关键字abstract定义的抽象类含必须由继承自它的子类重写父类中的抽象方法，因此无法同时使用final和abstract来修饰同一个类。  </p>
</li>
<li><p>同样的道理final也不能用来修饰接口，final的类的所有方法都不能被重写，但这并不表示final的类的属性(变量值)也是不可改变的，要想做到final类的属性值不可改变，必须给它增加final修饰  </p>
<pre><code>public final class FinalTest3 {

    int i = 20;
    final int j = 30;

    public static void main(String[] args) {
        FinalTest3 t = new FinalTest3();
        t.i=99;//final类FinalTest3的属性值 i是可以改变的，因为属性值i前面没final修饰
        //t.j=49;//报错....因为j属性是final的不可以改变。
        System.out.println(t.i);
    }

}

/**
 * 接口里声明的变量默认是final的
 */
public interface FinalTest4 {

    int a=10;
    //编译报错
    //int b;
}</code></pre></li>
</ul>
</li>
</ul>
<h1 id="2）finally关键字"><a href="#2）finally关键字" class="headerlink" title="2）finally关键字"></a>2）finally关键字</h1><p>finally只能用在try/catch语句中并且附带着一个语句块，表示这段语句最终总是被执行</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        try {
            throw new NullPointerException();
        }catch (Exception e) {
            System.out.println(&quot;程序出了异常!&quot;);
        } finally {
            //这里总会被执行，不受break,return影响另如数据库连接的close()一般写在这里，可以降低程序的出错几率
            System.out.println(&quot;执行了finally语句块&quot;);
        }
    }
}</code></pre><p>那么有没有一种情况使finally语句块得不到执行呢？  </p>
<pre><code>public class FinallyTest {

    public static void main(String[] args) {
        FinallyTest f = new FinallyTest();
        //测试return语句
        f.testReturn();
        System.out.println();
        // 测试continue语句
        f.testContinue();
        System.out.println();
         // 测试break语句
        f.testBreak();
    }

    //测试return语句
    public ReturnClass testReturn(){
        try {
            return new ReturnClass();
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            System.out.println(&quot;执行了finally语句&quot;);
        }
        System.out.println(&quot;执行了null语句&quot;);
        return null;
    }

    //测试continue语句
    public void testContinue(){
        for (int i = 0; i &lt; 3; i++) {
            try {
                System.out.println(i);
                 if(i == 1){
                     System.out.println(&quot;con&quot;);
                     continue;
                 }
            } catch (Exception e) {
                e.printStackTrace();
            }finally {
                System.out.println(&quot;执行了finally语句&quot;);
            }
        }
    }
    //测试break语句
    public void testBreak(){
        for (int i = 0; i &lt; 3; i++) {
            try {
                System.out.println(i);
                 if(i == 1){
                    break;
                 }
            } catch (Exception e) {
                e.printStackTrace();
            }finally {
                System.out.println(&quot;执行了finally语句&quot;);
            }
        }
    }
}

class ReturnClass{
    public ReturnClass(){
        System.out.println(&quot;执行了return语句&quot;);
    }
}</code></pre><p>输出结果  </p>
<pre><code>执行了return语句
执行了finally语句

0
执行了finally语句
1
con
执行了finally语句
2
执行了finally语句

0
执行了finally语句
1
执行了finally语句</code></pre><p>经过测试：很明显，return、continue和break都没能阻止finally语句块的执行。从输出的结果来看，return语句似乎在finally语句块之前执行了，事实真的如此吗？我们来想想看，return语句的作用是什么呢？是退出当前的方法，并将值或对象返回。如果 finally语句块是在return语句之后执行的，那么return语句被执行后就已经退出当前方法了，finally语句块又如何能被执行呢？因此，正确的执行顺序应该是这样的：编译器在编译return new ReturnClass();时，将它分成了两个步骤，new ReturnClass()和return，前一个创建对象的语句是在finally语句块之前被执行的，而后一个return语句是在finally语句块之后执行的，也就是说finally语句块是在程序退出方法之前被执行的。同样，finally语句块是在循环被跳过（continue）和中断（break）之前被执行的。</p>
<h1 id="3）finalize关键字"><a href="#3）finalize关键字" class="headerlink" title="3）finalize关键字"></a>3）finalize关键字</h1><p>finalize，它是一个方法，属于java.lang.Object类，它的定义如下：protected void finalize()throws Throwable{}<br>众所周知finalize()方法是GC（garbagecollector)运行机制的一部分,在此我们只说说finalize()方法的作用是什么呢？finalize()方法是在GC清理它所从属的对象时被调用的，如果执行它的过程中抛出了无法捕获的异常（uncaughtexception），GC将终止对该对象的清理，并且该异常会被忽略； 直到下一次GC开始清理这个对象时，它的finalize()会被再次调用。请看下面的示例：  </p>
<pre><code>public class Test {
    //重写finalize()方法
    @Override
    protected void finalize() throws Throwable {
        System.out.println(&quot;执行了finallize()方法&quot;);
    }
    public static void main(String[] args) {
        Test t = new Test();
        t = null;
        System.gc();
        //System.runFinalizersOnExit(true);
    }
}</code></pre><p>输出结果：执行了finallize()方法<br>程序调用了java.lang.System类的gc()方法，引起GC的执行，GC在清理t对象时调用了它的finalize()方法，因此才了上面的输出结果。调用System.gc()等同于调用下面这行代码：Runtime.getRuntime().gc();调用它们的作用只是<code>建议</code>垃圾收集器（GC）启动，清理无用的对象释放内存空间，但是GC的启动并不是一定的，这由JAVA虚拟机来决定。直到 JAVA虚拟机停止运行，些对象的finalize()可能都没被运行过，那么怎样保证所对象的这个方法在JAVA虚拟机停止运行之前一定被调用呢？答案是我们可以调用System类的另一个方法：</p>
<pre><code>public static void runFinalizersOnExit(boolean value){
       //othercode
} </code></pre><p>给这个方法传入true就可以保证对象的finalize()方法在JAVA虚拟机停止运行前一定被运行了，不过遗憾的是这个方法是不安全的，它会导致有用的对象finalize()被误调用，因此已不被赞成使用了。由于finalize()属于Object类，因此所类都这个方法，Object的任意子类都可以重写（override）该方法，在其中释放系统资源或者做其它的清理工作，如关闭输入输出流。</p>
]]></content>
  </entry>
  <entry>
    <title>String s =&quot;abc&quot; 与 String s= new String(&quot;abc&quot;)的区别</title>
    <url>/blog/2019/08/14/%E5%85%B3%E4%BA%8EString%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="1、String-str1-“abc”-方式"><a href="#1、String-str1-“abc”-方式" class="headerlink" title="1、String str1 = “abc”;方式"></a>1、String str1 = “abc”;方式</h3><pre><code>/**
 * VM为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间——字符串实例池。
 * String赋值的两种方式。
 * 1、String str1 = &quot;abc&quot;;
 * 在编译期，JVM会去常量池来查找是否存在“abc”，如果不存在，就在常量池中开辟一个空间来存储“abc”；
 * 如果存在，就不用新开辟空间。然后在栈内存中开辟一个名字为str1的空间，来存储“abc”在常量池中的地址值。
 * 
 * 所以通过==比较是，s1，s2指向的是同一地址，所以返回true；
 */
public static void main(String[] args) {
    String s1 = &quot;abc&quot;;
    String s2 = &quot;abc&quot;;
    System.out.println(s1 == s2);//true 
}</code></pre><a id="more"></a>
<h3 id="2、String-s-new-String-“abc”-方式"><a href="#2、String-s-new-String-“abc”-方式" class="headerlink" title="2、String s= new String(“abc”);方式"></a>2、String s= new String(“abc”);方式</h3><pre><code>/**
 * 2、String str2 = new String(&quot;abc&quot;);
 * 在编译阶段JVM先去常量池中查找是否存在“abc”，如果过不存在，则在常量池中开辟一个空间存储“abc”。
 * 在运行时期，通过String类的构造器在堆内存中new了一个空间，然后将常量池中的“abc”复制一份存放到该堆空间中，
 * 在栈中开辟名字为str2的空间，存放堆中new出来的这个String对象的地址值。
 *
 * 这时s1和s2分别指向堆中不同的地址，所以返回false
 */
public static void main(String[] args) {
    String s1 = new String(&quot;test&quot;);
    String s2 = new String(&quot;test&quot;);
    System.out.println(s1 == s2);//false
}</code></pre><p>从上面我们可以里看出：第一种方式在初始化时，可能创建了一个对象，也有可能一个对象都没有创建。而第二种方式在初始化时，因为new关键字的原因至少在内存中创建了一个对象，也有可能是两个对象。</p>
]]></content>
  </entry>
  <entry>
    <title>==与equals的区别</title>
    <url>/blog/2019/08/14/%E7%AD%89%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="1-equals方法是java-lang-Object类的方法"><a href="#1-equals方法是java-lang-Object类的方法" class="headerlink" title="1.equals方法是java.lang.Object类的方法"></a>1.equals方法是java.lang.Object类的方法</h3><p>有两种有用法说明<br>(1)对于字符串变量来说，使用”==”和”equals()”方法比较字符串时，其比较方法不同。<br>“==”比较两个变量本身的值，即两个对象在内存中的首地址<br>“equals”比较字符串中所包含的内容是否相同  </p>
<pre><code>public static void main(String[] args) {
        String s1,s2,s3;
        s1 = new String(&quot;abc&quot;);
        s2 = new String(&quot;abc&quot;);
        s3 = s1;
        System.out.println(s1 == s2); //false
        System.out.println(s1.equals(s2));//true
        System.out.println(s1 == s3); //true
}

 注意(1):
 解释：
     StringBuffer类中没有重新定义equals这个方法，因此这个方法就来自Object类，
     而Object类中的equals方法是用来比较&quot;地址&quot;的，所以等于false
    public static void main(String[] args) {
        StringBuffer s1 = new StringBuffer(&quot;a&quot;);
        StringBuffer s2 = new StringBuffer(&quot;a&quot;);
        System.out.println(s1.equals(s2));//false
    }

 注意(2):
 解释：
      对于s3和s4来说，有一点不一样要引起注意，由于s3和s4是`两个字符串常量`所生成的变量，其中所存放的内存地址是相等的
    所以s3==s4是true（即使没有s3=s4这样一个赋值语句）
    public static void main(String[] args) {
        String s3=&quot;abc&quot;,s4=&quot;abc&quot;;
        System.out.println(s3 == s4); //true
    }</code></pre><a id="more"></a>
<p>(2)对于非字符串变量来说,==与equals方法的作用是相同的，都是用来比较其对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个地址  </p>
<pre><code>public class Test {
    public static void main(String[] args) {
        A obj1 = new  A();
        A obj2 = new  A();
        System.out.println(obj1 == obj2);//false
        System.out.println(obj1.equals(obj2));//false
        //如果
        A obj3 = obj1;
        System.out.println(obj1 == obj3);//true
        System.out.println(obj1.equals(obj3));//true
    }
}
class A{

}</code></pre><h3 id="2-对于基本数据来说，-比较的是值是否相等，不能用equals来比较"><a href="#2-对于基本数据来说，-比较的是值是否相等，不能用equals来比较" class="headerlink" title="2.对于基本数据来说，==比较的是值是否相等，不能用equals来比较"></a>2.对于基本数据来说，==比较的是值是否相等，不能用equals来比较</h3><pre><code>public static void main(String[] args) {
    int a = 3; 
    int b = 4; 
    int c = 3; 
    System.out.println(a == b);//结果是false 
    System.out.println(a == c);//结果是true 
    //System.out.println(a.equals(c));//错误，编译不能通过，equals方法 
}</code></pre><h3 id="3-对于基本数据来的包装类来说，用法与String类基本一直，且都是final修饰的类以Integer为例子，其他的比如Double、Character、Float等也一样"><a href="#3-对于基本数据来的包装类来说，用法与String类基本一直，且都是final修饰的类以Integer为例子，其他的比如Double、Character、Float等也一样" class="headerlink" title="3.对于基本数据来的包装类来说，用法与String类基本一直，且都是final修饰的类以Integer为例子，其他的比如Double、Character、Float等也一样"></a>3.对于基本数据来的包装类来说，用法与String类基本一直，且都是final修饰的类以Integer为例子，其他的比如Double、Character、Float等也一样</h3><pre><code>public static void main(String[] args) {
    Integer n1 = new Integer(30); 
    Integer n2 = new Integer(30); 
    Integer n3 = new Integer(31); 
    Integer n4 = 31;
    Integer n5 = 31;
    System.out.println(n1 == n2);//结果是false 两个不同的Integer对象，故其地址不同， 
    System.out.println(n1 == n3);//false 那么不管是new Integer(30)还是new Integer(31) 结果都显示false 
    System.out.println(n1.equals(n2));//结果是true 根据jdk文档中的说明，n1与n2指向的对象中的内容是相等的，都是30，故equals比较后结果是true 
    System.out.println(n1.equals(n3));//结果是false 因对象内容不一样，一个是30一个是31 
    System.out.println(n4 == n5);//true
    System.out.println(n4.equals(n5));//true
    System.out.println(n3 == n4);//false
    System.out.println(n3.equals(n4));//true
}</code></pre><h3 id="4-关于String的比较的详细说明"><a href="#4-关于String的比较的详细说明" class="headerlink" title="4.关于String的比较的详细说明"></a>4.关于String的比较的详细说明</h3><pre><code>/**
 * 关于String的比较：
 * 解释：
 *     1.s1与s2分别指向由字符串常量”123” 创建的对象，在常量池中，只有一个对象，内容为123，
 * 有两个引用s1和s2指向这个对象，故这两个引用变量所指向的地址是相同的，因而（1）处的运行结果为
 * true，又因为s1.equals(s2)是比较s1和s2所指向的对象的内容是否相等，而我们知道这两个对
 * 象的内容都是字符串常量”123”，故标记（2）处的运行结果是true。
 * 
 * 2.用同样的方法分析，s1和s3所指向的对象不一样，内容也不一样，故标记（3）和（4）处运行结果是false。
 * 
 * 3.再看看s4和s5，这两个引用变量所指向的对象的内容都是一样的（内容都是123），但是这两个对象是用
 * new操作符创建处类的，是在内存中分配两块空间给这两个对象的，因而这两个对象的内存地址不一样，故是两个
 * 不同的对象，标记（5）处的s4 == s5 运行结果为false，但是内容一样，故标记（6）处的s4.equals(s5)
 * 运行结果为true。同理，s4和s6所指向的对象地址不同，内容也不相同。故标记（7）（8）处运行结果为false。
 * 
 * 4.s1和s4分别指向两个不同的对象（之所以这样称呼，是因为这两个对象在内存中的地址不相同，故而对象不相同），
 * 故标记为（9）处的s1 == s4运行结果为false，而标记为（10）处的s1.equals(s4)运行结果为true.
 */
public static void main(String[] args) {
    String s1 = &quot;123&quot;; 
    String s2 = &quot;123&quot;; 
    String s3 = &quot;abc&quot;; 
    String s4 = new String(&quot;123&quot;); 
    String s5 = new String(&quot;123&quot;); 
    String s6 = new String(&quot;abc&quot;); 

    System.out.println(s1 == s2);//（1）true 
    System.out.println(s1.equals(s2));//（2）true 
    System.out.println(s1 == s3);//（3）flase 
    System.out.println(s1.equals(s3));//（4）flase 

    System.out.println(s4 == s5);//（5）flase 
    System.out.println(s4.equals(s5));//（6）true 
    System.out.println(s4 == s6);//（7）flase 
    System.out.println(s4.equals(s6));//（8）flase 

    System.out.println(s1 == s4);//（9）false 
    System.out.println(s1.equals(s4));//（10）true 
}</code></pre>]]></content>
  </entry>
  <entry>
    <title>重写equals,为什么需要重写hashcode</title>
    <url>/blog/2019/08/14/%E9%87%8D%E5%86%99equals-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%87%8D%E5%86%99hashcode/</url>
    <content><![CDATA[<h3 id="1-首先看一个例子-不考虑重写hashcode的情况"><a href="#1-首先看一个例子-不考虑重写hashcode的情况" class="headerlink" title="1.首先看一个例子,不考虑重写hashcode的情况"></a>1.首先看一个例子,不考虑重写hashcode的情况</h3><pre><code>import java.util.HashMap;
import java.util.Objects;

public class Test {
    public static void main(String[] args) {
        Student s1 = new Student(&quot;张三&quot;,18,&quot;123456789&quot;);
        Student s2 = new Student(&quot;张三&quot;,18,&quot;123456789&quot;);
        System.out.println(s1.equals(s2));
        System.out.println(s1.hashCode());
        System.out.println(s2.hashCode());
        HashMap&lt;Student, String&gt; map = new HashMap&lt;&gt;();
        map.put(s1, &quot;123&quot;);
        map.put(s2, &quot;456&quot;);
        System.out.println(map.get(s1));
        System.out.println(map.get(s2));
    }
}
class Student{
    private String name;
    private  int age;
    private  String QQ;

    public Student(String name, int age, String qQ) {
        this.name = name;
        this.age = age;
        QQ = qQ;
    }

    @Override
    public boolean equals(Object obj) {
        if(this == obj) return true;
        if(obj == null || getClass() != obj.getClass()) return false;
        Student student = (Student)obj;
        return Objects.equals(name, student.name) &amp;&amp; age==student.age 
                &amp;&amp; Objects.equals(QQ, student.QQ);
    }
}</code></pre><a id="more"></a>
<p>输出的结果为：</p>
<pre><code>true
366712642  //s1 的hashcode值
1829164700 //s2 的hashcode值
123
456</code></pre><p>是否出现矛盾？？？<br>用equals比较说明对象相同，但是在HashMap中却以不同的对象存储（没有重写hascode值，两个hascode值，在他看来就是两个对象）。<br>到底这两个对象相等不相等？？？？<br>说明必须重写hashCode()的重要性。  </p>
<p>假如只重写equals而不重写hashcode，那么Student类的hashcode方法就是Object默认的hashcode方法，由于默认的hashcode方法是根据对象的内存地址经哈希算法得来的，显然此时s1!=s2,故两者的hashcode不一定相等。</p>
<p>如果不被重写（原生）的hashCode和equals是什么样的？<br>&nbsp;&nbsp;1.不被重写（原生）的hashCode值是根据内存地址换算出来的一个值。<br>&nbsp;&nbsp;2.不被重写（原生）的equals方法是严格判断一个对象是否相等的方法（object1 == object2）  </p>
<h3 id="2-更改上一个例子，重写hashcode，结果会怎样"><a href="#2-更改上一个例子，重写hashcode，结果会怎样" class="headerlink" title="2.更改上一个例子，重写hashcode，结果会怎样"></a>2.更改上一个例子，重写hashcode，结果会怎样</h3><pre><code>class Student{
    private String name;
    private  int age;
    private  String QQ;

    public Student(String name, int age, String qQ) {
        this.name = name;
        this.age = age;
        QQ = qQ;
    }

    @Override
    public boolean equals(Object obj) {
        if(this == obj) return true;
        if(obj == null || getClass() != obj.getClass()) return false;
        Student student = (Student)obj;
        return Objects.equals(name, student.name) &amp;&amp; age==student.age 
                &amp;&amp; Objects.equals(QQ, student.QQ);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name,age,QQ);
    }
}</code></pre><p>输出的结果为：</p>
<pre><code>true
-1122679957 
-1122679957
456
456</code></pre><p>很显然这才是我们想要的结果。  </p>
<h3 id="3-那么我们在什么情况下需要重写equals和hashCode方法呢？"><a href="#3-那么我们在什么情况下需要重写equals和hashCode方法呢？" class="headerlink" title="3.那么我们在什么情况下需要重写equals和hashCode方法呢？"></a>3.那么我们在什么情况下需要重写equals和hashCode方法呢？</h3><p>&nbsp;&nbsp;1.在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的equals方法就不能满足我们的需求了。<br>&nbsp;&nbsp;2.所以这个时候我们需要重写equals方法，来满足我们的业务系统上的需求。那么为什么在重写equals方法的时候需要重写hashCode方法呢？</p>
<p>我们先来看一下Object.hashCode的通用约定（摘自《Effective Java》第45页）</p>
<pre><code>    1.在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么，对该对象调用hashCode方法多次，它必须始终如一地返回 同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。
    2.如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生同样的整数结果。
    3.如果两个对象根据equals(Object)方法是不相等的，那么调用这两个对象中任一个对象的hashCode方法，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能    
    4.如果只重写了equals方法而没有重写hashCode方法的话，则会违反约定的第二条：相等的对象必须具有相等的散列码（hashCode）
    5.同时对于HashSet和HashMap这些基于散列值（hash）实现的类。HashMap的底层处理机制是以数组的方法保存放入的数据(Node&lt;K,V&gt;[] table)，其中的关键是数组下标的处理。数组的下标是根据传入的元素hashCode方法的返回值再和特定的值异或决定的。如果该数组位置上已经有放入的值了，且传入的键值相等则不处理，若不相等则覆盖原来的值，如果数组位置没有条目，则插入，并加入到相应的链表中。检查键是否存在也是根据hashCode值来确定的。所以如果不重写hashCode的话，可能导致HashSet、HashMap不能正常的运作。 如果我们将某个自定义对象存到HashMap或者HashSet及其类似实现类中的时候，如果该对象的属性参与了hashCode的计算，那么就不能修改该对象参数hashCode计算的属性了。有可能会移除不了元素，导致内存泄漏。(这点很重要)

扩展：
    在重写equals方法的时候，需要遵守下面的通用约定：
        1、自反性。
          对于任意的引用值x，x.equals(x)一定为true。
        2、对称性。
          对于任意的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)也一定返回true。
        3、传递性。
          对于任意的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也一定返回true。
        4、一致性。
          对于任意的引用值x和y，如果用于equals比较的对象没有被修改的话，那么，对此调用x.equals(y)要么一致地返回true，要么一致的返回false。
        5、对于任意的非空引用值x，x.equals(null)一定返回false。

重写hashCode方法的大致方式：
   a、把某个非零常数值，比如说17（最好是素数），保存在一个叫result的int类型的变量中。
   b、对于对象中每一个关键域f（值equals方法中考虑的每一个域），完成一些步骤：
      1、为该域计算int类型的散列码c：
         1）、如果该域是boolean类型，则计算（f？0:1）。
         2)、如果该域是byte、char、short或者int类型，则计算（int）f。
         3）、如果该域是float类型，则计算Float.floatToIntBits(f)。
         4）、如果该域是long类型，则计算（int）（f ^ (f&gt;&gt;&gt;32)）。
         5）、如果该域是double类型，则计算Double.doubleToLongBits(f)得到一个long类型的值，然后按照步骤4，对该long型值计算散列值。
         6）、如果该域是一个对象引用，并且该类的equals方法通过递归调用equals的方式来比较这个域，则同样对这个域递归调用hashCode。如果要求一个更为复杂的比较，则为这个域计算一个“规范表示”，然后针对这个范式表示调用hashCode。如果这个域的值为null，则返回0（或者其他某个常数）
         7）、如果该域是一个数组，则把每一个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤下面的做法把这些散列值组合起来。
      2、按照下面的公式，把步骤1中计算得到的散列码C组合到result中：
           result = 31*result+c。
   c、返回result。
   d、写完hashCode方法之后，问自己“是否相等的实例具有相等的散列码”。如果不是的话，找出原因，并修改。可以通过org.apache.commons.lang.builder.HashCodeBuilder这个工具类来方便的重写hashCode方法。</code></pre><p><a href="/blog/2020/04/25/资源整理/" target="blank">《Effective Java》</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>JAVA基础知识</title>
    <url>/blog/2019/08/14/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="1-如果main方法被声明为private会怎样？"><a href="#1-如果main方法被声明为private会怎样？" class="headerlink" title="1.如果main方法被声明为private会怎样？"></a>1.如果main方法被声明为private会怎样？</h3><blockquote>
<p>能正常编译，但运行的时候会提示”main方法不是public的”或者说在类XXX中找不到 main 方法, 请将 main 方法定义为:public static void main(String[] args)。</p>
</blockquote>
<h3 id="2-如果去掉了main方法的static修饰符会怎样？"><a href="#2-如果去掉了main方法的static修饰符会怎样？" class="headerlink" title="2.如果去掉了main方法的static修饰符会怎样？"></a>2.如果去掉了main方法的static修饰符会怎样？</h3><blockquote>
<p>能正常编译，但是会提示方法不是类XXX中的static, 请将 main 方法定义为:public static void main(String[] args)。</p>
</blockquote>
<h3 id="3-Java里的传引用和传值的区别是什么？"><a href="#3-Java里的传引用和传值的区别是什么？" class="headerlink" title="3.Java里的传引用和传值的区别是什么？"></a>3.Java里的传引用和传值的区别是什么？</h3><blockquote>
<p>传引用是指传递的是地址而不是值本身，传值则是传递值的一份拷贝。</p>
</blockquote>
<h3 id="4-如果要重写一个对象的equals方法，还要考虑什么？"><a href="#4-如果要重写一个对象的equals方法，还要考虑什么？" class="headerlink" title="4.如果要重写一个对象的equals方法，还要考虑什么？"></a>4.如果要重写一个对象的equals方法，还要考虑什么？</h3><blockquote>
<p>考虑hashcode。<a href="/blog/2019/08/14/重写equals-为什么需要重写hashcode/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<a id="more"></a>

<h3 id="5-Java的”一次编写，处处运行”是如何实现的？"><a href="#5-Java的”一次编写，处处运行”是如何实现的？" class="headerlink" title="5.Java的”一次编写，处处运行”是如何实现的？"></a>5.Java的”一次编写，处处运行”是如何实现的？</h3><blockquote>
<p>Java程序会被编译成字节码组成的class文件，这些字节码可以运行在任何平台，因此Java是平台独立的。</p>
</blockquote>
<h3 id="6-说明一下public-static-void-main-String-args-这段声明里每个关键字的作用"><a href="#6-说明一下public-static-void-main-String-args-这段声明里每个关键字的作用" class="headerlink" title="6.说明一下public static void main(String args[])这段声明里每个关键字的作用"></a>6.说明一下public static void main(String args[])这段声明里每个关键字的作用</h3><blockquote>
<p>public: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见。所以可见性设置为public。<br>static: Java平台调用这个方法时不会创建这个类的一个实例，因此这个方法必须声明为static。<br>void: main方法没有返回值。<br>String是命令行传进参数的类型，args是指命令行传进的字符串数组。</p>
</blockquote>
<h3 id="7-与equals的区别"><a href="#7-与equals的区别" class="headerlink" title="7.==与equals的区别"></a>7.==与equals的区别</h3><blockquote>
<p>(1)对于基本数据类型来说，”==”比较的是值是否相等,不可以使用” equals”比较基本数据类型(其包装类类似于String类)<br>(2)1.对于字符串(String)变量来说，”==”比较的是两个对象在内存中的首地址。(注意:s1=’abc’,s2=’abc’s1==s2(true),解释：由于s1和s2是<code>两个字符串常量</code>所生成的变量，其中所存放的内存地址是相等的)<br>&nbsp;&nbsp;&nbsp;&nbsp;2.”equals”比较字符串(String)中所包含的内容是否相同<br>(3)对于非字符串变量来说==与equals方法的作用是相同的，都是用来比较其对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个地址<br><a href="/blog/2019/08/14/等于等于与equals的区别/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="8-为什么oracle-type4驱动被称作瘦驱动？"><a href="#8-为什么oracle-type4驱动被称作瘦驱动？" class="headerlink" title="8.为什么oracle type4驱动被称作瘦驱动？"></a>8.为什么oracle type4驱动被称作瘦驱动？</h3><blockquote>
<p>oracle提供了一个type 4 JDBC驱动，被称为瘦驱动。这个驱动包含了一个oracle自己完全用Java实现的一个TCP/IP的Net8的实现，因此它是平台独立的，可以在运行时由浏览器下载，不依赖任何客户端 的oracle实现。客户端连接字符串用的是TCP/IP的地址端口，而不是数据库名的tnsname。</p>
</blockquote>
<pre><code>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class JdbcTest {

    public static void main(String[] args) {
        String driver = &quot;oracle.jdbc.OracleDriver&quot;;//驱动标识
        String url = &quot;jdbc:oracle:thin:@192.168.204.201:1521:xe&quot;;//链接字符串
        String user = &quot;pengwei&quot;;//用户名
        String password = &quot;123456&quot;;//密码
        Connection conn = null;
        PreparedStatement pstm = null;
        ResultSet rs = null;
        boolean flag = false;
        try {
            Class.forName(driver);
            conn = DriverManager.getConnection(url,user,password);
            String sql = &quot;select * from PENGWEI.\&quot;emp\&quot;&quot;;
            pstm = conn.prepareStatement(sql);
            rs = pstm.executeQuery();
            while(rs.next()){
                int id = rs.getInt(&quot;id&quot;);
                String name = rs.getString(&quot;name&quot;);
                int age = rs.getInt(&quot;age&quot;);
                System.out.println(&quot;id:&quot;+id+&quot; name:&quot;+name+&quot; age:&quot;+age);
            }
            flag = true;
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }finally{
            if(rs!=null){
                try {
                    rs.close();
                } catch (Exception e2) {
                    e2.printStackTrace();
                }
            }
            // 关闭执行通道
            if(pstm!=null){
                try {
                    pstm.close();
                } catch (Exception e2) {
                    e2.printStackTrace();
                }
            }
            // 关闭连接通道
            if(conn!=null){
                try {
                    conn.close();
                } catch (Exception e2) {
                    e2.printStackTrace();
                }
            }
        }

        if(flag){
             System.out.println(&quot;执行成功！&quot;);
        }else{
             System.out.println(&quot;执行失败！&quot;);
        }
    }
}</code></pre><h3 id="9-介绍一下final、finally、finalize"><a href="#9-介绍一下final、finally、finalize" class="headerlink" title="9.介绍一下final、finally、finalize"></a>9.介绍一下final、finally、finalize</h3><blockquote>
<p>1.final（常量声明）:用于声明属性，方法和类。<br>接口里声明的变量默认是final的。final类无法继承，也就是没有子类。这么做是出于基础类型的安全考虑，比如String和Integer类。这样也使得编译器进行一些优化，更容易保证线程的安全性。final方法无法重写(可以重载)。final变量的值不能改变。<br>2.finally：处理异常。<br>finally通常用于异常处理，不管有没有异常抛出都一定会执行finally里面的逻辑。比如，关闭连接通常放到finally块中完成。<br>3.finalize：帮助进行垃圾回收<br>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。<br>finalize()方法在一个对象被销毁和回收前会被调用。<br><a href="/blog/2019/08/14/final、finally、finalize的用法/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="10-什么是JAVA-API？"><a href="#10-什么是JAVA-API？" class="headerlink" title="10.什么是JAVA API？"></a>10.什么是JAVA API？</h3><blockquote>
<p>Java API是大量软件组件的集合，它们提供了大量有用的功能，比如GUI组件。</p>
</blockquote>
<h3 id="11-GregorianCalendar类是什么东西？"><a href="#11-GregorianCalendar类是什么东西？" class="headerlink" title="11.GregorianCalendar类是什么东西？"></a>11.GregorianCalendar类是什么东西？</h3><blockquote>
<p>GregorianCalendar 是 Calendar 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。<a href="/blog/2019/08/19/GregorianCalendar日历类的使用/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="12-ResourceBundle类是什么"><a href="#12-ResourceBundle类是什么" class="headerlink" title="12.ResourceBundle类是什么?"></a>12.ResourceBundle类是什么?</h3><blockquote>
<p>ResourceBundle用来存储指定语言环境的资源，应用程序可以根据运行时的语言环境来加载这些资源，从而提供不同语言的展示。<a href="/blog/2019/08/19/ResourceBundle类的简单使用/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="13-为什么Java里没有全局变量"><a href="#13-为什么Java里没有全局变量" class="headerlink" title="13.为什么Java里没有全局变量?"></a>13.为什么Java里没有全局变量?</h3><blockquote>
<p>全局变量是全局可见的，Java不支持全局可见的变量，因为：<code>全局变量破坏了引用透明性原则。全局变量导致了命名空间的冲突</code>。</p>
</blockquote>
<h3 id="14-如何将String类型转化成Number类型？"><a href="#14-如何将String类型转化成Number类型？" class="headerlink" title="14.如何将String类型转化成Number类型？"></a>14.如何将String类型转化成Number类型？</h3><blockquote>
<p>String numString = “1000″;<br>int id=Integer.valueOf(numString).intValue();或者<br>int id=Integer.parseInt(numString);//这里直接返回一个int<br>valueOf()与parseInt()方法的区别：使用valueOf()方法会返回一个包装类对象，我们可以使用里面的一些方法</p>
</blockquote>
<h3 id="15-SimpleTimeZone类是什么"><a href="#15-SimpleTimeZone类是什么" class="headerlink" title="15.SimpleTimeZone类是什么?"></a>15.SimpleTimeZone类是什么?</h3><blockquote>
<p>SimpleTimeZone提供公历日期支持。它是时区(TimeZone)的具体子类，它表示与公历使用的时区。<a href="/blog/2019/08/20/SimpleTimeZone/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="16-while循环和do-while循环有什么不同？"><a href="#16-while循环和do-while循环有什么不同？" class="headerlink" title="16.while循环和do/while循环有什么不同？"></a>16.while循环和do/while循环有什么不同？</h3><blockquote>
<p>while结构在循环的开始判断下一个迭代是否应该继续。do/while结构在循环的结尾来判断是否将继续下一轮迭代。do结构至少会执行一次循环体。<a href="/blog/2019/08/20/while与do-while循环的区别/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="17-Locale类是什么？"><a href="#17-Locale类是什么？" class="headerlink" title="17.Locale类是什么？"></a>17.Locale类是什么？</h3><blockquote>
<p>Locale类用来根据语言环境来动态调整程序的输出。<a href="/blog/2019/08/20/Locale类的使用/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="18-面向对象的三大基本特征，七大基本原则"><a href="#18-面向对象的三大基本特征，七大基本原则" class="headerlink" title="18.面向对象的三大基本特征，七大基本原则"></a>18.面向对象的三大基本特征，七大基本原则</h3><blockquote>
<p>三大特征:多态，继承和封装。<br>七大基本原则(设计模式七大基本原则)：<br>1、单一职责原则（SRP）<br>2、开放封闭原则（OCP）<br>3、里氏替换原则（LSP）<br>4、依赖倒置原则（DIP）<br>5、接口隔离原则（ISP）<br>6、迪米特|最少知道原则（LKP）<br>7、合成复用原则（CAPP）<br><a href="/blog/2019/08/20/面向对象的三大基本特征，七大基本原则/" target="_blank"> &gt;&gt;更多</a>  </p>
</blockquote>
<h3 id="19-介绍下继承的原则"><a href="#19-介绍下继承的原则" class="headerlink" title="19.介绍下继承的原则"></a>19.介绍下继承的原则</h3><blockquote>
<p>继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象(实例)具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。继承机制可以很好的描述一个类的生态，也提高了代码的复用率，在java中的Object类是所有类的超类，长称作上帝类。<br><br><br>继承使得一个对象可以获取另一个对象的属性，使用继承可以让已经测试完备的功能得以复用，并且可以一次修改，所有继承的地方都同时生效。</p>
</blockquote>
<h3 id="20-什么是隐式的类型转化"><a href="#20-什么是隐式的类型转化" class="headerlink" title="20.什么是隐式的类型转化?"></a>20.什么是隐式的类型转化?</h3><blockquote>
<p>隐式的类型转换，就是简单的一个类型赋值给另外一个类型，没有显示的告诉编译器发生了转化，并不是所有的类型都支持隐式的类型转换。<br>代码示例：<br>    int i = 1000;<br>    long j = i; //Implicit casting</p>
</blockquote>
<h3 id="21-sizeof是Java的关键字吗"><a href="#21-sizeof是Java的关键字吗" class="headerlink" title="21.sizeof是Java的关键字吗?"></a>21.sizeof是Java的关键字吗?</h3><blockquote>
<p>不是。（是C语言里的关键字，用来求数据类型字节的函数名）</p>
</blockquote>
<h3 id="22-native方法是什么"><a href="#22-native方法是什么" class="headerlink" title="22.native方法是什么?"></a>22.native方法是什么?</h3><blockquote>
<p>native方法是非Java代码实现的方法。<a href="/blog/2019/08/21/java中native的用法/" target="_blank"> &gt;&gt;更多</a>  </p>
</blockquote>
<h3 id="23-在System-out-println-里面-System-out-println分别是什么"><a href="#23-在System-out-println-里面-System-out-println分别是什么" class="headerlink" title="23.在System.out.println()里面,System, out, println分别是什么?"></a>23.在System.out.println()里面,System, out, println分别是什么?</h3><blockquote>
<p>System是系统提供的预定义的final类，out是一个PrintStream对象，println是out对象里面一个重载方法。</p>
</blockquote>
<h3 id="24-封装，继承和多态是什么"><a href="#24-封装，继承和多态是什么" class="headerlink" title="24.封装，继承和多态是什么?"></a>24.封装，继承和多态是什么?</h3><blockquote>
<p>1.封装：隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改数据的访问级别，将抽象得到的数据和行为(或功能)相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。<br>封装的目的是为了增强安全性和简化编程，使用者不必了解具体的实现细节，而是只要通过外部接口，以特定的访问权限来使用类的成员。<br>2.继承：继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象(实例)具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。继承机制可以很好的描述一个类的生态，也提高了代码的复用率。<br>3.多态：多态是指同一个行为具有多个不同表现形式或形态的能力。是指一个类的实例(对象)的相同方法在不同情形有不同表现形式。<br>简单来说，多态是指一个名字多种实现。多态使得一个实体通过一个通用的方式来实现不同的操作。具体的操作是由实际的实现来决定的。<br>多态在java里有三种表现方式：方法重载、通过继承实现方法重写、通过java接口进行方法重写。<br><a href="/blog/2019/08/20/面向对象的三大基本特征，七大基本原则/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="25-显式的类型转化是什么"><a href="#25-显式的类型转化是什么" class="headerlink" title="25.显式的类型转化是什么?"></a>25.显式的类型转化是什么?</h3><blockquote>
<p>显示类型转化就是明确的告诉了编译器来进行对象的转化。<br>代码示例：<br>long i = 70000<br>int j = (int)i;//Explicit casting</p>
</blockquote>
<h3 id="26-什么是Java虚拟机"><a href="#26-什么是Java虚拟机" class="headerlink" title="26.什么是Java虚拟机?"></a>26.什么是Java虚拟机?</h3><blockquote>
<p>Java虚拟机是能移植到不同硬件平台上的软件系统。</p>
</blockquote>
<h3 id="27-Java中的向上类型转换和向下类型转换"><a href="#27-Java中的向上类型转换和向下类型转换" class="headerlink" title="27.Java中的向上类型转换和向下类型转换"></a>27.Java中的向上类型转换和向下类型转换</h3><blockquote>
<p>1.向上类型转换：通俗的来讲就是将子类对象转为父类对象，此处父类可以是接口。<br>2.向下类型转换：与向上转型相反，即是把父类转为子类对象。向下转换也可以说是指由一个通用类型转换成一个具体的类型，在继承结构上向下进行。<a href="/blog/2019/08/22/Java中的向上类型转换和向下类型转换/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="28-Java的访问修饰符是什么"><a href="#28-Java的访问修饰符是什么" class="headerlink" title="28.Java的访问修饰符是什么?"></a>28.Java的访问修饰符是什么?</h3><blockquote>
<p>访问权限修饰符是表明类成员的访问权限类型的关键字。使用这些关键字来限定程序的方法或者变量的访问权限。他们包含：<br>public：所有类都可以访问<br>protected：归属类、同一个包内以及所有的子类都可以访问(子类没在同一个包中，也可以访问)<br>default(默认)：归属类及同一个包内的其它类可以访问(如果子类没在同一个包中，不能访问)<br>private：只有归属的类才能访问</p>
</blockquote>
<h3 id="29-java中的类加public和不加public的区别"><a href="#29-java中的类加public和不加public的区别" class="headerlink" title="29.java中的类加public和不加public的区别"></a>29.java中的类加public和不加public的区别</h3><blockquote>
<p>加public表示全局类，该类可以import到任何类内。<br>不加public默认为保留类，只能被同一个包内的其他类引用。</p>
</blockquote>
<h3 id="30-所有类的父类是什么？"><a href="#30-所有类的父类是什么？" class="headerlink" title="30.所有类的父类是什么？"></a>30.所有类的父类是什么？</h3><blockquote>
<p>Object</p>
</blockquote>
<h3 id="31-Java的基本类型有哪些"><a href="#31-Java的基本类型有哪些" class="headerlink" title="31.Java的基本类型有哪些?"></a>31.Java的基本类型有哪些?</h3><blockquote>
<p>byte、short、int、long、char、float、double、boolean</p>
</blockquote>
<h3 id="32-静态类型有什么特点"><a href="#32-静态类型有什么特点" class="headerlink" title="32.静态类型有什么特点?"></a>32.静态类型有什么特点?</h3><blockquote>
<p>静态变量是和类绑定在一起的，而不是类的实例对象。每一个实例对象都共享同样一份静态变量。也就是说，一个类的静态变量只有一份，不管他有多少个对象。类变量或者说静态变量是通过static这个关键字来声明的。静态变量通常通过类名字来进行访问。当程序运行的时候这个变量就会创建直到程序结束后才会被销毁。类变量的作用域和实例变量是一样的。他的初始值和成员变量也是一样的，当变量没有被初始化的时候根据它的数据类型，会有一个默认值。类似的，静态方法是属于类的方法，而不是类对象，他的调用并不作用于类对象，也不需要创建任何类的实例。其中父类的静态方法会被子类的静态方法屏蔽，只要原来的方法没有声明为final。非静态方法不能重写静态方法，也就是说，你不能在子类中把一个静态方法改成实例方法。<br>非静态变量在每一个对象实例上都有单独的一份值。  </p>
</blockquote>
<h3 id="33-amp-操作符和-amp-amp-操作符有什么区别"><a href="#33-amp-操作符和-amp-amp-操作符有什么区别" class="headerlink" title="33.&amp;操作符和&amp;&amp;操作符有什么区别?"></a>33.&amp;操作符和&amp;&amp;操作符有什么区别?</h3><blockquote>
<p>&amp;&amp;(只能作为逻辑运算符，通常也被称作短路与)，当&amp;&amp;连接多个表达式求值的时候，先计算第一个表达式，如果它返回true才会计算第二个表达式。如果第一个表达式返回false，第二个表达式就不会被求值，直接返回false，后面的表达式都不会被执行，所以被称作短路与。<br>&amp;：当它作为逻辑运算符时，不管有多少个表达式都会被执行。当他作为位运算符时，可以进行二进制之间的与运算。  </p>
</blockquote>
<blockquote>
<p>|与||的区别，基本同上<br>||：当前面某个表达式计算结果为true时，后面的表达式都不会被执行<br>|：作为逻辑运算符时，所有表达式都会被执行</p>
</blockquote>
<h3 id="34-Java是如何处理整型的溢出和下溢的"><a href="#34-Java是如何处理整型的溢出和下溢的" class="headerlink" title="34.Java是如何处理整型的溢出和下溢的?"></a>34.Java是如何处理整型的溢出和下溢的?</h3><blockquote>
<p>java根据类型的大小，将计算结果中的对应低阶字节存储到对应的值里面。<a href="/blog/2019/08/23/java整形溢出和下溢问题/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="35-public-static-void写成static-public-void会怎样？"><a href="#35-public-static-void写成static-public-void会怎样？" class="headerlink" title="35.public static void写成static public void会怎样？"></a>35.public static void写成static public void会怎样？</h3><blockquote>
<p>程序能够正常编译及运行</p>
</blockquote>
<h3 id="36-声明变量与定义变量有何区别？"><a href="#36-声明变量与定义变量有何区别？" class="headerlink" title="36.声明变量与定义变量有何区别？"></a>36.声明变量与定义变量有何区别？</h3><blockquote>
<p>声明变量我们只提供变量的类型和名字，并没有进行初始化。定义包括声明和初始化两个阶段<br>String  s;只是声明变量，String s = new String(“bob”);或者String s = “bob”；是变量定义。</p>
</blockquote>
<h3 id="37-Java支持哪种参数传递类型"><a href="#37-Java支持哪种参数传递类型" class="headerlink" title="37.Java支持哪种参数传递类型?"></a>37.Java支持哪种参数传递类型?</h3><blockquote>
<p>Java参数都是进行传值。对于对象而言，传递的值是对象的引用，也就是说原始引用和参数引用的那个拷贝，都是指向同一个对象。</p>
</blockquote>
<h3 id="38-对象封装的原则是什么"><a href="#38-对象封装的原则是什么" class="headerlink" title="38.对象封装的原则是什么?"></a>38.对象封装的原则是什么?</h3><blockquote>
<p>内聚(本题的聚合)：内聚是指一个模块内部各个部分之间的关联程度<br>耦合：耦合各个模块之前的关联程度<br><strong>封装原则：隐藏对象的属性和实现细节，仅对外公开接口，并且控制在程序中属性的读和修改数据的访问级别</strong><br>在面向对象方法中，用类来实现上面的要求。用类实现封装，用封装来实现高内聚，低耦合。<br>封装可以增强代码的安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限来使用类的成员，并同时确保使用者无法任意更改接口实现细节内部的重要属性。<br><a href="/blog/2019/08/20/面向对象的三大基本特征，七大基本原则/" target="_blank"> &gt;&gt;更多</a>  </p>
</blockquote>
<h3 id="39-你怎么理解变量？"><a href="#39-你怎么理解变量？" class="headerlink" title="39.你怎么理解变量？"></a>39.你怎么理解变量？</h3><blockquote>
<p>变量是一块命名的内存区域，以便程序进行访问。变量用来存储数据，随着程序的执行，存储的数据也可能跟着改变。<a href="/blog/2019/08/27/怎么理解变量-变量是什么/" target="_blank"> &gt;&gt;更多</a>  </p>
</blockquote>
<h3 id="40-数值提升是什么？"><a href="#40-数值提升是什么？" class="headerlink" title="40.数值提升是什么？"></a>40.数值提升是什么？</h3><blockquote>
<p>数值提升是指数据从一个较小的数据类型转换成为一个更大的数据类型，以便进行整型或浮点型运算。在数值提升的过程中，byte、short、char值会被转化成int类型。需要的时候int类型也可能被提升成long。long和float则有可能会被转换成double类型。<a href="/blog/2019/08/23/java整形溢出和下溢问题/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="41-Java的类型转化是什么？"><a href="#41-Java的类型转化是什么？" class="headerlink" title="41.Java的类型转化是什么？"></a>41.Java的类型转化是什么？</h3><blockquote>
<p>从一个数据类型转换成另一个数据类型叫做类型转换。Java有两种类型转换的方式，一个显示的类型转换，一个是隐式的。  </p>
</blockquote>
<h3 id="42-main方法的参数里面，字符串数组的第一个参数是什么？"><a href="#42-main方法的参数里面，字符串数组的第一个参数是什么？" class="headerlink" title="42.main方法的参数里面，字符串数组的第一个参数是什么？"></a>42.main方法的参数里面，字符串数组的第一个参数是什么？</h3><blockquote>
<p>数组是空的，没有任何元素。不像C或者C++，第一个参数默认是程序名。如果命令行没有提供任何参数的话，main方法中的String数组为空，但不是null。</p>
</blockquote>
<h3 id="43-怎么判断数组是null还是为空？"><a href="#43-怎么判断数组是null还是为空？" class="headerlink" title="43.怎么判断数组是null还是为空？"></a>43.怎么判断数组是null还是为空？</h3><blockquote>
<p>输出array.length的值，如果是0，说明数组为空。如果是null，会抛出空指针异常。  </p>
</blockquote>
<h3 id="44-程序中可以允许多个类同时拥有都有main方法吗？"><a href="#44-程序中可以允许多个类同时拥有都有main方法吗？" class="headerlink" title="44.程序中可以允许多个类同时拥有都有main方法吗？"></a>44.程序中可以允许多个类同时拥有都有main方法吗？</h3><blockquote>
<p>可以。当程序运行的时候，我们会指定运行的类型。JVM只会在你指定的类中查找main方法。因此多个类同时拥有main方法不存在命名冲突的问题。</p>
</blockquote>
<h3 id="45-静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？"><a href="#45-静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？" class="headerlink" title="45.静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？"></a>45.静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？</h3><blockquote>
<p>当类加载器将类加载到JVM中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，他并不是类的成员，也没有返回值，并不能直接调用。静态代码块不能包含this或者super，它们通常被用来初始化静态变量。  </p>
</blockquote>
<h3 id="46-一个类能拥有多个main方法吗？"><a href="#46-一个类能拥有多个main方法吗？" class="headerlink" title="46.一个类能拥有多个main方法吗？"></a>46.一个类能拥有多个main方法吗？</h3><blockquote>
<p>可以。但是只能有一个方法拥有以下签名：<br>public static void main(String[] args){}<br>否则程序将无法通过编译。编译器会警告你main方法已经存在。</p>
</blockquote>
<h3 id="47-简单介绍下JVM是如何工作的？"><a href="#47-简单介绍下JVM是如何工作的？" class="headerlink" title="47.简单介绍下JVM是如何工作的？"></a>47.简单介绍下JVM是如何工作的？</h3><blockquote>
<p>JVM是一台抽象的计算机，就像真实的计算机那样，它们会将.java文件编译成.class文件(.class文件就是字节码文件)，然后用它的解释器来加载字节码。  </p>
</blockquote>
<h3 id="48-如何原地交换两个变量的值？"><a href="#48-如何原地交换两个变量的值？" class="headerlink" title="48.如何原地交换两个变量的值？"></a>48.如何原地交换两个变量的值？</h3><blockquote>
<p>先把两个值相加赋值给第一个变量，然后用得到的结果减去第二个变量，赋值给第二个变量。再用第一个变量减去第二个变量，同时赋值给第一个变量。代码如下：<br>int a=5,b=10;a=a+b;b=a-b;a=a-b;<br>使用异或操作也可以交换变量。第一个方法还可能会引起溢出。抑或方法如下：int a=5,b=10;<br>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br><a href="/blog/2019/08/27/原地交换两个变量的值/" target="_blank"> &gt;&gt;更多</a></p>
</blockquote>
<h3 id="49-什么是数据的封装？"><a href="#49-什么是数据的封装？" class="headerlink" title="49.什么是数据的封装？"></a>49.什么是数据的封装？</h3><blockquote>
<p>数据的封装一种方式是在类中创建set和get方法来访问对象的数据变量。一般来说变量是private的，而get和set方法是public的。封装还可以用来在存储数据时进行数据验证，或者对数据进行计算，或者用作自省（比如在struts中使用javabean）。把数据和功能封装到一个独立的结构中称为数据封装。封装其实就是把数据和关联的操作方法封装到一个独立的单元中，这样使用关联的这些方法才能对数据进行访问操作。封装提供的是数据安全性，他其实就是一种隐藏数据的方式。  </p>
</blockquote>
<h3 id="50-什么是反射API？他是如何实现的？"><a href="#50-什么是反射API？他是如何实现的？" class="headerlink" title="50.什么是反射API？他是如何实现的？"></a>50.什么是反射API？他是如何实现的？</h3><blockquote>
<p>反射是指在运行时能查看一个类的状态及特征，并能进行动态管理。这些功能是通过一些内建类的反射API提供的，比如Class，Method，Field，Constructors等。使用的例子：java反射API的getName方法可以获取到类名。  </p>
</blockquote>
<pre><code>public static void main(String[] args) { 
    try {
        Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.String&quot;);
        Constructor&lt;?&gt; c=clazz.getConstructor(String.class);
        Object obj = c.newInstance(&quot;123&quot;);
        Method method = obj.getClass().getDeclaredMethod(&quot;toString&quot;);
        System.out.println(clazz.getName());
        System.out.println(method.invoke(obj));
    } catch (Exception e) {
        e.printStackTrace();
    }
} </code></pre><h3 id="51-JVM自身会维护缓存吗，是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理的堆？为什么？"><a href="#51-JVM自身会维护缓存吗，是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理的堆？为什么？" class="headerlink" title="51.JVM自身会维护缓存吗，是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理的堆？为什么？"></a>51.JVM自身会维护缓存吗，是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理的堆？为什么？</h3><blockquote>
<p>是的，JVM会自身管理缓存，它在堆中创建对象，然后在栈中引用这些对象。  </p>
</blockquote>
<h3 id="52-虚拟内存是什么？"><a href="#52-虚拟内存是什么？" class="headerlink" title="52.虚拟内存是什么？"></a>52.虚拟内存是什么？</h3><blockquote>
<p>虚拟内存又叫延伸内存，实际上并不存在真实的物理内存。  </p>
</blockquote>
<h3 id="53-方法可以同时即是static又是synchronized的吗"><a href="#53-方法可以同时即是static又是synchronized的吗" class="headerlink" title="53.方法可以同时即是static又是synchronized的吗?"></a>53.方法可以同时即是static又是synchronized的吗?</h3><blockquote>
<p>可以。如果这样的话，JVM会获取和这个对象关联的java.lang.Class实例上的锁。这样做等于：<br>synchronized(XYZ.class){}<br><a href="/blog/2019/08/27/synchronized修饰static方法与非static方法的区别/" target="_blank"> &gt;&gt;更多</a>  </p>
</blockquote>
<h3 id="54-String和StringTokenizer的区别是什么"><a href="#54-String和StringTokenizer的区别是什么" class="headerlink" title="54.String和StringTokenizer的区别是什么?"></a>54.String和StringTokenizer的区别是什么?</h3><blockquote>
<p>StringTokenizer是一个用来分割字符串的工具类。<a href="/blog/2019/08/27/StringTokenizer/" target="_blank"> &gt;&gt;更多</a>   </p>
</blockquote>
<h3 id="55-transient变量有什么特点？"><a href="#55-transient变量有什么特点？" class="headerlink" title="55.transient变量有什么特点？"></a>55.transient变量有什么特点？</h3><blockquote>
<p>transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。<br><a href="/blog/2019/08/28/transient关键字/" target="_blank"> &gt;&gt;更多</a>  </p>
</blockquote>
<h3 id="56-哪些容器使用Border布局作为它们的默认布局"><a href="#56-哪些容器使用Border布局作为它们的默认布局" class="headerlink" title="56.哪些容器使用Border布局作为它们的默认布局?"></a>56.哪些容器使用Border布局作为它们的默认布局?</h3><blockquote>
<p>Window、Frame、Dialog</p>
</blockquote>
<h3 id="57-怎么理解什么是同步？"><a href="#57-怎么理解什么是同步？" class="headerlink" title="57.怎么理解什么是同步？"></a>57.怎么理解什么是同步？</h3><blockquote>
<p>同步用来控制共享资源再多个线程间的访问，以保证同一时间内只有一个线程能访问到这个资源。<br>在非同步保护的多线程程序里面，一个线程正在修改一个共享变量的时候，可能有另外一个线程也在使用或者更新它的值，同步避免了脏数据的产生。<br>对方法进行同步：<br>public synchronized void Method1(){<br>&nbsp;&nbsp;&nbsp;&nbsp;//Appropriate method-related code.<br>}   </p>
<p>对方法内部代码进行同步：<br>public void myFunction(){<br>&nbsp;&nbsp;&nbsp;&nbsp;synchronized (this){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Synchronized code here.<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}  </p>
</blockquote>
<h3 id="58-给一整型变量a，写两段代码，第一个设置a的bit3-为1，其他bit不变，怎么实现呢？"><a href="#58-给一整型变量a，写两段代码，第一个设置a的bit3-为1，其他bit不变，怎么实现呢？" class="headerlink" title="58.给一整型变量a，写两段代码，第一个设置a的bit3 为1，其他bit不变，怎么实现呢？"></a>58.给一整型变量a，写两段代码，第一个设置a的bit3 为1，其他bit不变，怎么实现呢？</h3><pre><code>public class Test {
   public static void main(String[] args) {
       //给一整型变量a，写两段代码，第一个设置a的bit3 为1，其他bit不变，怎么实现呢？
       int a = 4;
       //打印二进制
       System.out.println(Integer.toBinaryString(a));//输出  0100
       System.out.println(Integer.toBinaryString(a | 8));//输出 1100
   }
}</code></pre><p><a href="/blog/2019/08/28/给一整型变量，写两段代码，第一个设置a的bit3为1，其他bit不变，怎么实现/" target="_blank"> &gt;&gt;更多</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>Dockerfile常用指令</title>
    <url>/blog/2019/06/13/Dockerfile%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="1-ADD复制文件"><a href="#1-ADD复制文件" class="headerlink" title="1.ADD复制文件"></a>1.ADD复制文件</h3><pre><code>格式：
ADD &lt;src&gt;... &lt;dest&gt;  
ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]
从src目录复制文件到容器的dest。其中src可以是Dockerfile所在目录的相对路径，也可以是一个URL，还可以是一个压缩包
注意：
    1.src必须在构建的上下文内，不能使用例如：ADD ../something /something这样的命令，因为docker build命令会首先将上下文路径和其子目录发送到docker daemon。
    2.如果src是一个URL，同时dest不以斜杆结尾，dest将会被视为文件，src对应内容文件将会被下载到dest。
    3.如果src是一个URL，同时dest以斜杆结尾，dest将被视为目录，src对应内容将会被下载到dest目录。
    4.如果src是一个URL，那么整个目录下的内容将会被复制，包括文件系统元数据。
    5.如果文件是可识别的压缩包格式，则docker会自动解压。
示例：
ADD microservice-discovery-eureka-0.0.1-SNAPSHOT.jar app.jar</code></pre><a id="more"></a>
<h3 id="2-ARG设置构建参数"><a href="#2-ARG设置构建参数" class="headerlink" title="2.ARG设置构建参数"></a>2.ARG设置构建参数</h3><pre><code>ARG指令用于设置构建参数，类似于ENV。和ENV不同的是，ARG设置的是构建时的环境变量，在容器运行时是不会存在这些变量的。
格式：    
ARG &lt;name&gt;[=&lt;default value&gt;]
示例：
ARG user1=someuser</code></pre><h3 id="3-CMD容器启动命令"><a href="#3-CMD容器启动命令" class="headerlink" title="3.CMD容器启动命令"></a>3.CMD容器启动命令</h3><pre><code>CMD指令用于为执行容器提供默认值。每个Dockerfile只有一个CMD命令，如果指定了多个CMD命令，那么只有最后一条会被执行，如果启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令
格式：    
CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;](推荐使用)
CMD [&quot;param1&quot;,&quot;param2&quot;](为ENTRYPOINT指令提供预设参数)
CMD command param1 param2(在shell中执行)
示例：
CMD echo &quot;This is a test.&quot; | wc -</code></pre><h3 id="4-COPY复制文件"><a href="#4-COPY复制文件" class="headerlink" title="4.COPY复制文件"></a>4.COPY复制文件</h3><pre><code>格式：
COPY &lt;src&gt;... &lt;dest&gt;  
COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]
从src目录复制文件到容器的dest。COPY指令与ADD指令类似，COPY不支持URL和压缩包。</code></pre><h3 id="5-ENTRYPOINT入口点"><a href="#5-ENTRYPOINT入口点" class="headerlink" title="5.ENTRYPOINT入口点"></a>5.ENTRYPOINT入口点</h3><pre><code>格式：
CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]
CMD command param1 param2
ENTRYPOINT和CMD指令的目的一样，都是指定Docker容器启动时执行的命令，可多次设置，但只有最后一个有效。</code></pre><h3 id="6-ENV设置环境变量"><a href="#6-ENV设置环境变量" class="headerlink" title="6.ENV设置环境变量"></a>6.ENV设置环境变量</h3><pre><code>ENV指令用于设置环境变量。
格式：
ENV &lt;key&gt; &lt;value&gt;
ENV &lt;key&gt;=&lt;value&gt; ...
示例：
ENV JAVA_HOME /path/to/java</code></pre><h3 id="7-EXPOSE声明暴露的端口"><a href="#7-EXPOSE声明暴露的端口" class="headerlink" title="7.EXPOSE声明暴露的端口"></a>7.EXPOSE声明暴露的端口</h3><pre><code>EXPOSE指令用于声明在运行时容器提供服务的端口.
格式：
EXPOSE &lt;port&gt; [&lt;port&gt;...]
注意：
    这只是一个声明，运行时并不会因为该声明就打开相应端口。该指令的作用主要是帮助镜像使用者理解该镜像服务的守护端口；其次是当运行时使用随机映射时，会自动映射EXPOSE端口。
示例：
#声明暴露一个端口示例
EXPOSE port1
#相应的运行容器使用的命令
docker run -p port1 image
#也可以使用-P选项启动
docker run -P image

#声明暴露多个端口示例
EXPOSE port1 port2 port3
#相应的运行容器使用的命令
docker run -p port1 -p port2 -p port3 image
#也可以指定需要映射到宿主机器上的端口号
docker run -p host_port1:port1 -p host_port2:port2 -p host_port3:port3 image</code></pre><h3 id="8-FROM指定基础镜像"><a href="#8-FROM指定基础镜像" class="headerlink" title="8.FROM指定基础镜像"></a>8.FROM指定基础镜像</h3><pre><code>使用FROM指令指定基础镜像，FROM指令有点像Java里面的extends关键字。需要注意的是，FROM指令必须指定且需要写在其他指令之前。FROM指令之后的所有指令都依赖于该指令所指定的镜像。
格式：
FROM &lt;image&gt;
FROM &lt;image&gt;:&lt;tag&gt;
FROM &lt;image&gt;@&lt;digest&gt;</code></pre><h3 id="9-LABEL为镜像添加元数据"><a href="#9-LABEL为镜像添加元数据" class="headerlink" title="9.LABEL为镜像添加元数据"></a>9.LABEL为镜像添加元数据</h3><pre><code>格式：
LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...
使用 “&quot;” 和 “\” 转换命令行
示例：
LABEL &quot;com.example.vender&quot;=&quot;ACME Incorporated&quot;
LABEL com.example.label-with-value=&quot;foo&quot;
LABEL version=&quot;1.0&quot;
LABEL description=&quot;This text illustrate \
that label-values can span multiple lines.&quot;</code></pre><h3 id="10-MAINTAINER指定维护者的信息"><a href="#10-MAINTAINER指定维护者的信息" class="headerlink" title="10.MAINTAINER指定维护者的信息"></a>10.MAINTAINER指定维护者的信息</h3><pre><code>MAINTAINER指令用于指定维护者的信息，用于为Dockerfile署名
格式：
MAINTAINER &lt;name&gt;
示例：
MAINTAINER 张三&lt;eacdy000@126.com&gt;</code></pre><h3 id="11-RUN执行命令"><a href="#11-RUN执行命令" class="headerlink" title="11.RUN执行命令"></a>11.RUN执行命令</h3><pre><code>格式：
RUN &lt;command&gt;
RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]
RUN &lt;command&gt;在shell终端中运行，在Linux中默认是/bin/sh -c，在Windows中是cmd /s /c，使用这种格式，就像直接在命令行中输入命令一样。
RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]使用exec执行，这种方式类似于函数调用。指定其他终端可以通过该方式操作，例如： RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]，该方式必须使用双引号`&quot;`而不能使用单引号`&apos;`，因为该方式会被转换成一个JSON数组。</code></pre><h3 id="12-USER设置用户"><a href="#12-USER设置用户" class="headerlink" title="12.USER设置用户"></a>12.USER设置用户</h3><pre><code>该指令用于设置启动镜像时的用户或者UID，写在该指令后的RUN、CMD以及ENTRYPOINT指令都将使用该用户执行命令
格式：
USER 用户名
示例：
USER daemon</code></pre><h3 id="13-VALUME指定挂载点"><a href="#13-VALUME指定挂载点" class="headerlink" title="13.VALUME指定挂载点"></a>13.VALUME指定挂载点</h3><pre><code>该指令使容器中的一个目录具有持久化存储的功能，该目录可被容器本身使用，也可以共享给其他容器。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。
格式：
VALUME [&quot;/data&quot;]
示例：
VALUME /data</code></pre><h3 id="14-WORKDIR指定工作目录"><a href="#14-WORKDIR指定工作目录" class="headerlink" title="14.WORKDIR指定工作目录"></a>14.WORKDIR指定工作目录</h3><pre><code>格式：
WORKDIR /path/to/workdir
切换目录指令，类似于cd命令，写在该指令后的RUN，CMD以及ENTRYPOINT指令都将该目录作为当前目录，并执行相应的命令。</code></pre><h3 id="15-其他"><a href="#15-其他" class="headerlink" title="15.其他"></a>15.其他</h3><pre><code>前往`https://docs.docker.com/engine/reference/builder/`进行扩展阅读</code></pre>]]></content>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/blog/2019/06/13/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="1-Dcoker镜像常用命令"><a href="#1-Dcoker镜像常用命令" class="headerlink" title="1.Dcoker镜像常用命令"></a>1.Dcoker镜像常用命令</h3><ul>
<li><p>搜索镜像<br>  例如搜索包含java关键词的镜像：</p>
<blockquote>
<p>docker search java</p>
</blockquote>
<a id="more"></a></li>
<li><p>下载镜像<br>  从Docker Register上下载最新版本的镜像：</p>
<blockquote>
<p>docker pull java</p>
</blockquote>
<p>  指定想要下载的镜像标签以及Docker Register地址：</p>
<blockquote>
<p>docker pull reg.itmuch.com/java:7</p>
</blockquote>
</li>
<li><p>镜像列表<br>  列出已下载的镜像命令：</p>
<blockquote>
<p>docker images</p>
</blockquote>
</li>
<li><p>删除本地镜像<br>  删除指定名称镜像，例如删除hello-world这个镜像:</p>
<blockquote>
<p>docker rmi hello-world</p>
</blockquote>
<p>  删除所有镜像：</p>
<blockquote>
<p>docker rmi -f $(docker images)</p>
</blockquote>
</li>
</ul>
<h3 id="2-Dcoker容器常用命令"><a href="#2-Dcoker容器常用命令" class="headerlink" title="2.Dcoker容器常用命令"></a>2.Dcoker容器常用命令</h3><ul>
<li><p>新建并启动容器<br>  使用以下docker run命令即可新建并启动一个容器。<br>  -d选项：表示后台运行<br>  -P选项：随机端口映射<br>  -p选项：指定端口映射，有以下四种形式：<br>  &#8195;&#8195;- ip:hostPort:containerPort<br>  &#8195;&#8195;- ip::containerPort<br>  &#8195;&#8195;- hostPort:containerPort<br>  &#8195;&#8195;- containerPort  </p>
<p>  –network选项：指定网络模式，该选项有以下可选参数：<br>  &#8195;&#8195;- –network=bridge：默认选项，表示连接到默认的网桥。<br>  &#8195;&#8195;- –network=host：容器使用宿主机的网络。<br>  &#8195;&#8195;- –network=container：NAME_or_ID：告诉Docker让新建的容器使用已有容器的网络配置。<br>  &#8195;&#8195;- –network=none：不配置该容器的网络，用户可自定义网络配置。  </p>
<p>  示例1：</p>
<blockquote>
<p>docker run java /bin/echo ‘Hello World’</p>
</blockquote>
<p>  示例2(-p 宿主机端口：容器端口==&gt;开放容器端口到宿主机端口,访问<code>http://Docker宿主机IP:91/</code>,就能看到nginx首页了)：  </p>
<blockquote>
<p>docker run -d -p 91:80 nginx  </p>
</blockquote>
</li>
<li><p>列出容器<br>  列出运行中的容器：</p>
<blockquote>
<p>docker ps</p>
</blockquote>
<p>  列出所有容器：</p>
<blockquote>
<p>docker ps -a</p>
</blockquote>
</li>
<li><p>停止容器<br>  通过容器ID来停止容器，例如停止ID为be2ec13ed1f0的容器：</p>
<blockquote>
<p>docker stop be2ec13ed1f0</p>
</blockquote>
<p>  通过容器名称来停止容器，例如停止名称为nginx的容器：</p>
<blockquote>
<p>docker stop nginx</p>
</blockquote>
</li>
<li><p>强制停止容器</p>
<blockquote>
<p>docker kill be2ec13ed1f0</p>
</blockquote>
</li>
<li><p>启动已停止容器</p>
<blockquote>
<p>docker start be2ec13ed1f0</p>
</blockquote>
</li>
<li><p>重启容器</p>
<blockquote>
<p>docker restart be2ec13ed1f0</p>
</blockquote>
</li>
<li><p>进入容器<br>  使用docker attach命令进入容器：</p>
<blockquote>
<p>docker attach be2ec13ed1f0</p>
</blockquote>
<p>  使用nsenter进入容器(nsenter工具包含在util-linux2.23或更高的版本中)：<br>  首先需要找到容器第一个进程的PID，可通过以下命令获取：</p>
<blockquote>
<p>docker inspect –format “&#123;&#123;.State.Pid&#125;&#125;” be2ec13ed1f0<br>  获得PID后，例如返回的PID为<code>4709</code>，就可以使用nsenter命令进入容器了：<br>  nsenter –target 4709 –mount –uts –ipc –net –pid</p>
</blockquote>
</li>
<li><p>删除容器<br>  删除指定的容器(只能删除已停止的容器)：  </p>
<blockquote>
<p>docker rm be2ec13ed1f0</p>
</blockquote>
<p>  删除正在运行的容器:</p>
<blockquote>
<p>docker rm -f be2ec13ed1f0</p>
</blockquote>
<p>  删除所有的容器：  </p>
<blockquote>
<p>docker rm -f $(docker ps -a -q)</p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>hibernate hql插入语句</title>
    <url>/blog/2019/06/04/hibernate-hql%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>1.在hibernate中执行insert插入语句时需要注意的是,使用下面的方法会出现<code>antlr.NoViableAltException: unexpected token: values</code>异常：</p>
<blockquote>
<p>Session session = sessionFactory.openSession();<br>String hql = “insert into User(name,age)values(?,?)”;<br>session.createQuery(hql).setParameter(0,”xxxx”).setParameter(1,20).executeUpdate();</p>
</blockquote>
<p>2.解决办法,使用createSQLQuery方法执行insert语句：</p>
<blockquote>
<p>session.createSQLQuery(hql).setParameter(0,”xxxx”).setParameter(1,20).executeUpdate();</p>
</blockquote>
]]></content>
  </entry>
</search>
