
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>volatile关键字的作用 - xiyou</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xiyou,"> 
    <meta name="description" content="volatile在java并发编程中常用于保持内存可见性(但不保证原子性)和防止指令重排。  
  
在 Java 多线程中如何保证线程的安全性？那我们可以使用 Synchronized 同步锁来给,"> 
    <meta name="author" content="xiyou"> 
    <link rel="alternative" href="atom.xml" title="xiyou" type="application/atom+xml"> 
    <link rel="icon" href="/blog/img/favicon.png"> 
    
    <link rel="stylesheet" href="/blog/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">xiyou</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xiyou13921.gitee.io/blog"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">volatile关键字的作用</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">volatile关键字的作用</h1>
        <div class="stuff">
            <span>三月 28, 2020</span>
            

        </div>
        <div class="content markdown">
            <p>volatile在java并发编程中常用于保持内存可见性(但不保证原子性)和防止指令重排。  </p>
<a id="more"></a>  
<p>在 Java 多线程中如何保证线程的安全性？那我们可以使用 Synchronized 同步锁来给需要多个线程访问的代码块加锁以保证线程安全性。使用 synchronized 虽然可以解决多线程安全问题，但弊端也很明显：加锁后多个线程需要判断锁，较为消耗资源。所以就引出我们今天的主角——volatile 关键字，一种轻量级的解决方案。  </p>
<p>在了解volatile之前，首先我们得先了解：多线程和JMM（Java内存模型）以及并发编程的3个概念。  </p>
<h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h2><h3 id="（1）进程和线程"><a href="#（1）进程和线程" class="headerlink" title="（1）进程和线程"></a>（1）进程和线程</h3><p>进程：一个正在执行中的程序，动态的，是系统进行资源分配和调度的独立单位。<br>线程：进程中一个独立的控制单元，线程控制着进程的执行。一个进程中至少有一个线程。  </p>
<h3 id="（2）创建线程的两种基本方式"><a href="#（2）创建线程的两种基本方式" class="headerlink" title="（2）创建线程的两种基本方式"></a>（2）创建线程的两种基本方式</h3><p>继承Thread类或者实现Runnable接口，然后重写run方法，调用线程的start方法。  </p>
<h3 id="（3）线程的生命周期"><a href="#（3）线程的生命周期" class="headerlink" title="（3）线程的生命周期"></a>（3）线程的生命周期</h3><p>就绪状态（线程 new 后）、可执行状态（start 方法启动线程，调用 run 方法）、阻塞状态（sleep 方法 和 wait 方法）、死亡状态（stop 方法）  </p>
<h2 id="2-Java-内存模型"><a href="#2-Java-内存模型" class="headerlink" title="2.Java 内存模型"></a>2.Java 内存模型</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。  </p>
<h3 id="（2）组成结构（类比-CPU、高速缓存-、内存-间的关系）"><a href="#（2）组成结构（类比-CPU、高速缓存-、内存-间的关系）" class="headerlink" title="（2）组成结构（类比 CPU、高速缓存 、内存 间的关系）"></a>（2）组成结构（类比 CPU、高速缓存 、内存 间的关系）</h3><p><img src="/blog/img/2020/03/28/java内存模型结构图.png"><br><br>主内存：所有线程共享；共享变量在主内存中存储的是其“<strong>本身</strong>”；<br>工作内存：每个线程有自己的工作空间；共享变量在主内存中存储的是其“<strong>副本</strong>”；<br>线程对共享变量的所有操作全在工作内存中进行；每个线程只能访问自己的工作内存；变量值的传递只能通过主内存完成。  </p>
<h2 id="3-并发编程的3个基本概念"><a href="#3-并发编程的3个基本概念" class="headerlink" title="3.并发编程的3个基本概念"></a>3.并发编程的3个基本概念</h2><h3 id="（1）原子性"><a href="#（1）原子性" class="headerlink" title="（1）原子性"></a>（1）原子性</h3><p>定义： <strong>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</strong><br>原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。例如 a=1是原子性操作，但是a++和a +=1就不是原子性操作。Java中的原子性操作包括：<br>a. 基本类型的读取和赋值操作，且赋值必须是数字赋值给变量，变量之间的相互赋值不是原子性操作。<br>b.所有引用reference的赋值操作<br>c.java.concurrent.Atomic.* 包中所有类的一切操作    </p>
<h3 id="（2）可见性"><a href="#（2）可见性" class="headerlink" title="（2）可见性"></a>（2）可见性</h3><p>定义：<strong>指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</strong><br>在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。  </p>
<h3 id="（3）有序性"><a href="#（3）有序性" class="headerlink" title="（3）有序性"></a>（3）有序性</h3><p>定义：<strong>即程序执行的顺序按照代码的先后顺序执行。</strong><br>Java内存模型中的有序性可以总结为：<strong>如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。</strong>前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p>
<p>在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。  </p>
<h2 id="4-volatile关键字-用来修饰被不同线程访问和修改的变量"><a href="#4-volatile关键字-用来修饰被不同线程访问和修改的变量" class="headerlink" title="4.volatile关键字(用来修饰被不同线程访问和修改的变量)"></a>4.volatile关键字(用来修饰被不同线程访问和修改的变量)</h2><h3 id="（1）内存可见性"><a href="#（1）内存可见性" class="headerlink" title="（1）内存可见性"></a>（1）内存可见性</h3><p>请看代码：  </p>
<pre><code>public class VolatileTest extends Thread {

    boolean flag = false;
    int i = 0;

    public void run() {
        while (!flag) {
            i++;
        }
        System.out.println(&quot;end......&quot;);
    }

    @Override
    public String toString() {
        return &quot;VolatileTest [flag=&quot; + flag + &quot;, i=&quot; + i + &quot;]&quot;;
    }



    public static void main(String[] args) throws Exception {
        VolatileTest vt = new VolatileTest();
        vt.start();
        Thread.sleep(2000);
        vt.flag = true;
        System.out.println(&quot;stop  &quot; + vt.i);
    }
}</code></pre><p>输出结果  </p>
<pre><code>stop  1070955768</code></pre><p>上面的代码是通过标记flag来控制VolatileTest线程while循环退出的例子!  
下面让我用伪代码来描述一下我们的程序：  </p>
<ul>
<li>首先创建 VolatileTest vt = new VolatileTest();</li>
<li>然后启动线程 vt.start();</li>
<li>暂停主线程2秒（Main） Thread.sleep(2000);</li>
<li>这时的vt线程已经开始执行，进行i++;</li>
<li>主线程暂停2秒结束以后将 vt.flag = true;</li>
<li>打印语句 System.out.println(“stop “ + vt.i); 在此同时由于vt.flag被设置为true,所以vt线程在进行下一次while判断 while (!flag) 返回假 结束循环 vt线程方法结束退出；然后打印语句System.out.println(“end……”)！  </li>
<li>主线程结束</li>
</ul>
<p>上面的叙述看似并没有什么问题，“似乎”完全正确。那就让我们把程序运行起来看看效果吧，执行mian方法。2秒钟以后控制台打印stop  202753974。<br>可是奇怪的事情发生了 程序并没有退出。vt线程仍然在运行，控制台也没有打印end……，也就是说我们在主线程设置的 vt.flag = true;没有起作用。  </p>
<p><strong>问题出现了，为什么我在主线程（main）中设置了vt.flag = true; 而vt线程在进行判断flag的时候拿到的仍然是false?</strong><br>那么按照我们上面所讲的 “JVM在运行时候的内存分配过程” 就很好解释上面的问题了。  </p>
<p>首先 vt线程在运行的时候会把 变量 flag 与 i (代码3,4行)从“主内存”  拷贝到 线程栈内存（上图的线程工作内存）  </p>
<p>然后 vt线程开始执行while循环   </p>
<pre><code>while (!flag) {
  i++;
}</code></pre><p>while (!flag)进行判断的flag 是在线程工作内存当中获取，而不是从 “主内存”中获取。<br>i++; 将线程内存中的i++; 加完以后将结果写回至 “主内存”，如此重复。  </p>
<p>然后再说说主线程的执行过程。 我只说明关键的地方<br>vt.flag = true;<br>主线程将vt.flag的值同样 从主内存中拷贝到自己的线程工作内存 然后修改flag=true. 然后再将新值回到主内存。  </p>
<p>这就解释了为什么在主线程（main）中设置了vt.flag = true; 而vt线程在进行判断flag的时候拿到的仍然是false。那就是因为vt线程每次判断flag标记的时候是从它自己的“工作内存中”取值，而并非从主内存中取值！  </p>
<p>这也是JVM为了提供性能而做的优化。那我们如何能让vt线程每次判断flag的时候都强制它去主内存中取值呢。这就是volatile关键字的作用。  </p>
<p>再次修改我们的代码:  </p>
<pre><code>public class VolatileTest extends Thread {

    volatile boolean flag = false;
    int i = 0;

    public void run() {
        while (!flag) {
            i++;
        }
        System.out.println(&quot;end......&quot;);
    }

    @Override
    public String toString() {
        return &quot;VolatileTest [flag=&quot; + flag + &quot;, i=&quot; + i + &quot;]&quot;;
    }



    public static void main(String[] args) throws Exception {
        VolatileTest vt = new VolatileTest();
        vt.start();
        Thread.sleep(2000);
        vt.flag = true;
        System.out.println(&quot;stop  &quot; + vt.i);
    }
}</code></pre><p>输出结果  </p>
<pre><code>stop  973794258
end......</code></pre><p>在flag前面加上volatile关键字，强制线程每次读取该值的时候都去“主内存”中取值(也就是让缓存失效了)。在试试我们的程序吧，已经正常退出了,并且控制台打印出了end……。  </p>
<h3 id="（2）禁止指令重排"><a href="#（2）禁止指令重排" class="headerlink" title="（2）禁止指令重排"></a>（2）禁止指令重排</h3><p>指令重排：JVM 在编译 Java 代码时或 CPU 在执行 JVM 字节码时，对现有指令顺序进行重新排序，优化程序的运行效率。（在不改变程序执行结果的前提下）   </p>
<p>指令重排虽说可以优化程序的执行效率，但在多线程问题上会影响结果。那么有什么解决办法呢？答案是<strong>内存屏障。</strong> 内存屏障是一种屏障指令，使 CPU 或编译器对屏障指令之前和之后发出的内存操作执行一个排序的约束。  </p>
<p>四种类型：<strong>LoadLoad 屏障、StoreStore 屏障、LoadStore 屏障、StoreLoad 屏障。（Load 代表读取指令、Store 代表写入操作）</strong>   </p>
<p><strong>在 volatile 变量上的体现：（JVM 执行操作）</strong>  </p>
<ul>
<li>在每个 volatile 写入操作前插入 StoreStore 屏障；</li>
<li>在写操作后插入 StoreLoad 屏障；</li>
<li>在读操作前插入 LoadLoad 屏障；</li>
<li>在读操作后插入 LoadStore 屏障；</li>
</ul>
<p>具体请看例子<br><strong>单例模式的双重锁为什么要加volatile</strong>    </p>
<pre><code>public class Singleton {

    private volatile static Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){//1
        if(instance==null){//2
            synchronized(Singleton.class){//3
                if(instance==null){//4
                    instance = new Singleton();//5
                }
            }
        }
        return instance;//6
    }
}</code></pre><p>需要关键字的原因是，在并发情况下，如果没有volatile关键字，在第5行会出现问题。<br>instance = new Singleton();可以分解为3行伪代码  </p>
<p>a.memory = allocate()//分配内存  </p>
<p>b.ctorlnstanc(memory)//初始化对象  </p>
<p>c.instance = memory//设置instance指向刚分配的地址  </p>
<p>上面的代码在编译运行时，可能会出现重排序从a-b-c排序为a-c-b。在多线程的情况下会出现以下问题。当线程A在执行第5行代码时，B线程进来执行到第2行代码。假设此时A执行的过程中发生了指令重排序，即先执行了a和c，没有执行b。那么由于A线程执行了c导致instance指向了一段地址，所以B线程判断instance不为null，会直接调到第6行并返回一个未初始化的对象。  </p>
<h3 id="（3）不保证原子性"><a href="#（3）不保证原子性" class="headerlink" title="（3）不保证原子性"></a>（3）不保证原子性</h3><p>需要重点说明的一点是，<strong>尽管volatile关键字可以保证内存可见性和有序性，但不能保证原子性。</strong>也就是说，对volatile修饰的变量进行的操作，不保证多线程安全。请看以下的例子：    </p>
<pre><code>public class Test {
    /** 处理main线程阻塞（等待所有子线程） */
    private static CountDownLatch countDownLatch = new CountDownLatch(1000);
    private volatile static int num = 0;

    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) {
            executor.execute(()-&gt;{
                try {
                    num++;
                } catch (Exception e) {
                    e.printStackTrace();
                }finally{
                    // 每个独立子线程执行完后,countDownLatch值减1
                    countDownLatch.countDown();
                }
            });
        }
        try {
            //使得主线程（main）阻塞直到countDownLatch.countDown()为零才继续执行
            //也就是保证前面的线程都执行完成
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        executor.shutdown();
        System.out.println(num);
    }
}</code></pre><p>静态变量num被volatile所修饰，并且同时开启1000个线程对其进行累加的操作，按道理来说，其结果应该为1000，但实际的情况是，每次运行结果都是一个小于1000的数字，并且不固定。那么这是为什么呢？原因是因为“num++;”这行代码并不是原子操作，尽管它被volatile所修饰了也依然如此。++操作的执行过程如下面所示：  </p>
<ul>
<li>首先获取变量num的值</li>
<li>将该变量的值+1</li>
<li>将该变量的值写回到对应的主内存中</li>
</ul>
<p>虽然每次获取num值的时候，也就是执行上述第一步的时候，都拿到的是主内存的最新变量值，但是在进行第二步num+1的时候，可能其他线程在此期间已经对num做了多次修改，这时再进行第二三步操作之后就会覆盖了一个旧值，发生了错误。比如说：线程A在执行第一步的时候读取到此时num的值为3，然后在执行第二步之前，其他多个线程已经对该值进行了多次修改，使得num值变为了10。而线程A此时执行第二步，将原先的num值为3的结果+1变为了4，最后再将4写回到主内存中（实际此时num应该为11）。所以这也就是最后的执行结果为什么都会是一个小于1000的值的原因，内存可见性只能保证在第一步操作上的内存可见性而已。  </p>
<p>所以如果要解决上面代码的多线程安全问题，可以采取加锁synchronized的方式，或者采用lock，也可以使用JUC包下的原子类AtomicInteger，原子操作类是通过CAS循环的方式来保证其原子性的，以下的代码演示了使用AtomicInteger来包装num变量的方式：  </p>
<pre><code>import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

public class Test {
    /** 处理main线程阻塞（等待所有子线程） */
    private static CountDownLatch countDownLatch = new CountDownLatch(1000);
    private static AtomicInteger num = new AtomicInteger();

    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) {
            executor.execute(()-&gt;{
                try {
                    num.getAndIncrement();
                } catch (Exception e) {
                    e.printStackTrace();
                }finally{
                    // 每个独立子线程执行完后,countDownLatch值减1
                    countDownLatch.countDown();
                }
            });
        }
        try {
            //使得主线程（main）阻塞直到countDownLatch.countDown()为零才继续执行
            //也就是保证前面的线程都执行完成
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        executor.shutdown();
        System.out.println(num);
    }
}</code></pre><p>多次运行上面的代码，结果都为1000。  </p>
<h2 id="5-volatile不适用的场景"><a href="#5-volatile不适用的场景" class="headerlink" title="5.volatile不适用的场景"></a>5.volatile不适用的场景</h2><p><strong>volatile不适合复合操作</strong><br>比如上面那个例子中的num++<br>解决方案除了上面那种之外，还有其他两种方式，这里展示一下代码。<br>（1）采用synchronized  </p>
<pre><code>public class Test2 {
    /** 处理main线程阻塞（等待所有子线程） */
    private static CountDownLatch countDownLatch = new CountDownLatch(1000);
    private static int num = 0;

    public synchronized void increase(){
        num++;
    }

    public static void main(String[] args) {
        final  Test2 test = new Test2();
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) {
            executor.execute(()-&gt;{
                try {
                    test.increase();
                } catch (Exception e) {
                    e.printStackTrace();
                }finally{
                    // 每个独立子线程执行完后,countDownLatch值减1
                    countDownLatch.countDown();
                }
            });
        }
        try {
            //使得主线程（main）阻塞直到countDownLatch.countDown()为零才继续执行
            //也就是保证前面的线程都执行完成
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        executor.shutdown();
        System.out.println(num);
    }
}</code></pre><p>(2) 采用Lock  </p>
<pre><code>public class Test2 {
    /** 处理main线程阻塞（等待所有子线程） */
    private static CountDownLatch countDownLatch = new CountDownLatch(1000);
    private static int num = 0;
    private Lock lock = new ReentrantLock();

    public void increase(){
        lock.lock();
        try {
            num++;
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }

    }

    public static void main(String[] args) {
        final  Test2 test = new Test2();
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) {
            executor.execute(()-&gt;{
                try {
                    test.increase();
                } catch (Exception e) {
                    e.printStackTrace();
                }finally{
                    // 每个独立子线程执行完后,countDownLatch值减1
                    countDownLatch.countDown();
                }
            });
        }
        try {
            //使得主线程（main）阻塞直到countDownLatch.countDown()为零才继续执行
            //也就是保证前面的线程都执行完成
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        executor.shutdown();
        System.out.println(num);
    }
}</code></pre><h2 id="6-参考文章"><a href="#6-参考文章" class="headerlink" title="6.参考文章"></a>6.参考文章</h2><p><a href="https://blog.csdn.net/qq_38190057/article/details/80813516" target="_blank" rel="noopener">https://blog.csdn.net/qq_38190057/article/details/80813516</a><br><a href="https://blog.csdn.net/u012723673/article/details/80682208" target="_blank" rel="noopener">https://blog.csdn.net/u012723673/article/details/80682208</a><br><a href="https://www.cnblogs.com/xd502djj/p/9873067.html" target="_blank" rel="noopener">https://www.cnblogs.com/xd502djj/p/9873067.html</a><br><a href="https://www.cnblogs.com/moxiaotao/p/10857139.html" target="_blank" rel="noopener">https://www.cnblogs.com/moxiaotao/p/10857139.html</a>  </p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src>
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-enable="false" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/blog/js/plugin.js"></script>
<script src="/blog/js/typed.js"></script>
<script src="/blog/js/diaspora.js"></script>
<link rel="stylesheet" href="/blog/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/blog/photoswipe/default-skin/default-skin.css">
<script src="/blog/photoswipe/photoswipe.min.js"></script>
<script src="/blog/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
