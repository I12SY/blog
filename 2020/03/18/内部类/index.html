
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>内部类 - xiyou</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xiyou,"> 
    <meta name="description" content="将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。  
  
1.内部类的分类
成员内部类
局部内部类
静态内部类
匿名内部类

1.1 成员内部类成员内部类——就是位于外部类成员位置,"> 
    <meta name="author" content="xiyou"> 
    <link rel="alternative" href="atom.xml" title="xiyou" type="application/atom+xml"> 
    <link rel="icon" href="/blog/img/favicon.png"> 
    
    <link rel="stylesheet" href="/blog/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">xiyou</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xiyou13921.gitee.io/blog"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">内部类</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">内部类</h1>
        <div class="stuff">
            <span>三月 18, 2020</span>
            

        </div>
        <div class="content markdown">
            <p>将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。  </p>
<a id="more"></a>  
<h2 id="1-内部类的分类"><a href="#1-内部类的分类" class="headerlink" title="1.内部类的分类"></a>1.内部类的分类</h2><ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>静态内部类</li>
<li>匿名内部类</li>
</ul>
<h3 id="1-1-成员内部类"><a href="#1-1-成员内部类" class="headerlink" title="1.1 成员内部类"></a>1.1 成员内部类</h3><p>成员内部类——就是位于外部类成员位置的类<br>特点：可以使用外部类中所有的成员变量和成员方法（包括private的）  </p>
<pre><code>class Outer {
    private int age=20;
    //成员位置
    class Inner{
        public void show(){
            System.out.println(age);
        }
    }
}

public class Test{
    public static void main(String[] args) {
        Outer.Inner oi = new Outer().new Inner();
        oi.show();
    }
}</code></pre><p>使用private修饰成员内部类  </p>
<pre><code>class Outer {
    //private修饰的成员内部类
    private class Inner{
        public void show(){
            System.out.println(&quot;使用private修饰的成员内部类&quot;);
        }
    }
    public Inner getInner(){
        return new Inner();
    }

    public static void main(String[] args) {
        Outer.Inner oi= new Outer().getInner();
        oi.show();
    }
}</code></pre><p>使用static修饰成员内部类，又叫静态内部类，下面会讲。  </p>
<p><strong>成员内部类经典题(填空)</strong><br>请在三个println 后括号中填空使得输出25,20,18  </p>
<pre><code>class Outer {
      public int age = 18;    
      class Inner {
          public int age = 20;    
          public viod showAge() {
              int age  = 25;
              System.out.println(age);//空1
              System.out.println(this.age);//空2
              System.out.println(Outer.this.age);//空3
          }
      }
  }   </code></pre><h3 id="1-2-局部内部类"><a href="#1-2-局部内部类" class="headerlink" title="1.2 局部内部类"></a>1.2 局部内部类</h3><p>局部内部类——就是定义在一个方法或者一个作用域里面的类<br>特点：主要是作用域发生了变化，只能在自身所在方法和属性中被使用   </p>
<pre><code>//在局部位置，可以创建内部类对象，通过对象调用和内部类方法
class Outer {
    private int age=20;

    public void method(){
        final int age2=30;
        class Inner{
            public void show(){
                System.out.println(age);
                //从内部类中访问方法内变量age2，需要将变量声明为最终类型。
                System.out.println(age2);
            }
        }

        Inner i = new Inner();
        i.show();
    }
}

public class Test {
    public static void main(String[] args) {
        Outer o = new Outer();
        o.method();
    }
}</code></pre><p><strong>为什么局部内部类访问局部变量必须加final修饰呢？</strong><br>因为<strong>局部变量是随着方法的调用而调用，使用完毕就消失，而堆内存的数据并不会立即消失。</strong><br>所以，堆内存还是用该变量，而该变量已经没有了。<strong>为了让该值还存在，就加final修饰。</strong><br>原因是，当我们使用final修饰变量后，堆内存直接存储的是值，而<strong>不是变量名。</strong><br>（即上例 age2 的位置存储着常量30 而不是 age2 这个变量名）  </p>
<h3 id="1-3-静态内部类"><a href="#1-3-静态内部类" class="headerlink" title="1.3 静态内部类"></a>1.3 静态内部类</h3><p>我们所知道static是不能用来修饰类的,但是成员内部类可以看做外部类中的一个成员,所以可以用static修饰,这种用static修饰的内部类我们称作静态内部类,也称作嵌套内部类.<br>特点：不能使用外部类的非static成员变量和成员方法  </p>
<pre><code>class Outer {
    int age=10;
    static int age2 = 20;

    static class Inner{
        public void show(){
            //System.out.println(age);错误
            System.out.println(age2);//正确
        }
    }

}

public class Test {
    public static void main(String[] args) {
        Outer.Inner oi = new Outer.Inner();
        oi.show();
    }
}</code></pre><h3 id="1-4-匿名内部类"><a href="#1-4-匿名内部类" class="headerlink" title="1.4 匿名内部类"></a>1.4 匿名内部类</h3><p>一个没有名字的类，是内部类的简化写法  </p>
<pre><code>new 类名或者接口名() {
      重写方法();
}</code></pre><p>本质：其实是继承该类或者实现接口的子类匿名对象<br>这也就是下例中，可以直接使用 new Inner() {}.show(); 的原因 == 子类对象.show();  </p>
<pre><code>interface Inner{
    public void show();
}

class Outer{
    public void method(){
        new Inner() {
            @Override
            public void show() {
                System.out.println(&quot;HelloWorld&quot;);
            }
        }.show();
    }
}

public class Test {
    public static void main(String[] args) {
        Outer o = new Outer();
        o.method();
    }
}</code></pre><p>如果匿名内部类中有多个方法又该如何调用呢？  </p>
<pre><code>class Outer{
    public void method(){
        Inner i = new Inner() {//多态，因为new Inner(){}代表的是接口的子类对象
            @Override
            public void show() {
                System.out.println(&quot;HelloWorld&quot;);
            }
        };
        i.show();
    }
}</code></pre><p><strong>匿名内部类在开发中的使用</strong><br>我们在开发的时候，会看到抽象类，或者接口作为参数。<br>而这个时候，实际需要的是一个子类对象。<br>如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。  </p>
<h2 id="2-内部类的作用"><a href="#2-内部类的作用" class="headerlink" title="2.内部类的作用"></a>2.内部类的作用</h2><h3 id="2-1-实现隐藏（封装性）"><a href="#2-1-实现隐藏（封装性）" class="headerlink" title="2.1 实现隐藏（封装性）"></a>2.1 实现隐藏（封装性）</h3><p>平时我们对类的访问权限，都是通过类前面的访问修饰符来限制的，一般的非内部类，是不允许有 private 与protected权限的，但内部类可以，所以我们能通过内部类来隐藏我们的信息。可以看下面的例子  </p>
<pre><code>public interface Demo{
    void show();
}

class Outer{

    private class Test implements Demo{
        @Override
        public void show() {
            System.out.println(&quot;密码备份文件&quot;);
        }
    }
    public Demo getInner(){
        return new Test();
    }
}</code></pre><p>测试代码  </p>
<pre><code>public class Test {
    public static void main(String[] args) {
        Outer o = new Outer();
        Demo demo=o.getInner();
        demo.show();
    }
}</code></pre><p>运行结果  </p>
<pre><code>密码备份文件</code></pre><p>这样做的好处之一就是，我们可以在这个public方法中增加一些判断语句，起到数据安全的作用。<br>其次呢，我们的对外可见的只是getInner()这个方法，它返回了一个Demo接口的一个实例，如果不看源代码的话，我们真正的内部类的名称就被隐藏起来了。  </p>
<h3 id="2-2-实现多继承-※"><a href="#2-2-实现多继承-※" class="headerlink" title="2.2 实现多继承 ※"></a>2.2 实现多继承 ※</h3><p>我们之前的学习知道，java是不可以实现多继承的，一次只能继承一个类，我们学习接口的时候，有提到可以用接口来实现多继承的效果，即一个接口有多个实现，但是这里也是有一点弊端的，那就是，一旦实现一个接口就必须实现里面的所有方法，有时候就会出现一些累赘，但是使用内部类可以很好的解决这些问题。  </p>
<pre><code>class Demo1{
    public String name(){
        return &quot;BWH_Steven&quot;;
    }
}

class Demo2{
    public String email(){
        return &quot;xxx.@163.com&quot;;
    }
}

public class Test {

    private class test1 extends Demo1{
        public String name() {
            return super.name();
        }
    }
    private class test2 extends Demo2{
        public String email() {
            return super.email();
        }
    }
    public String name(){
        return new test1().name();
    }

    public String email() {
        return new test2().email();
    }

    public static void main(String args[]) {
        Test t = new Test();
        System.out.println(&quot;我的姓名:&quot; + t.name());
        System.out.println(&quot;我的邮箱:&quot; + t.email());
    }
}</code></pre><h3 id="2-3-内部类拥有外围类的所有元素的访问权限-可以实现回调功能"><a href="#2-3-内部类拥有外围类的所有元素的访问权限-可以实现回调功能" class="headerlink" title="2.3 内部类拥有外围类的所有元素的访问权限(可以实现回调功能)"></a>2.3 内部类拥有外围类的所有元素的访问权限(可以实现回调功能)</h3><p>一个类，因为不方便直接修改内部的属性，所以可以通过回调的方式来进行。  </p>
<pre><code>public class Animal {

    private int weight; 

    public int getWeight() {
        return weight;
    }

    public void setWeight(int weight) {
        this.weight = weight;
    }

    public class WeightAdjust{
        public void adjust(int weight){
            setWeight(weight);
        }
    }

    public WeightAdjust getWeightAdjust(){
        return new WeightAdjust();
    }

    public Animal(int weight) {
        this.weight = weight;
    }
}</code></pre><p>下面是回调方法  </p>
<pre><code>public static void main(String[] args) {
    Animal animal = new Animal(15);
    animal.getWeightAdjust().adjust(19);
    System.out.println(animal.getWeight());
}</code></pre><p>上面的代码中，通过利用成员内部类可以持有所寄生的外部类的特性，利用内部类来完成了回调的功能，这种方式在很多代码中都被使用，比如线程，比如集合的比较器。   </p>
<h3 id="2-4-解决继承及实现接口出现同名方法的问题"><a href="#2-4-解决继承及实现接口出现同名方法的问题" class="headerlink" title="2.4 解决继承及实现接口出现同名方法的问题"></a>2.4 解决继承及实现接口出现同名方法的问题</h3><p>大家假想一下如果，你的类要继承一个类，还要实现一个接口，可是你发觉你继承的类和接口里面有两个同名的方法怎么办？你怎么区分它们？？这就需要我们的内部类了。看下面的代码   </p>
<pre><code>public interface Demo {
   public void test();
}

public class MyDemo{
    public void test(){
        System.out.println(&quot;父类的test方法&quot;);
    }
}

public class Test extends MyDemo implements Demo{
     public void test() {

     }
}</code></pre><p>这样的话我就有点懵了，这样如何区分这个方法是接口的还是继承的，所以我们使用内部类解决这个问题  </p>
<pre><code>public interface Demo {
   public void test();
}

public class MyDemo{
    public void test(){
        System.out.println(&quot;父类的test方法&quot;);
    }
}

public class Test extends MyDemo{

    private class Inner implements Demo{
        @Override
        public void test() {
            System.out.println(&quot;接口的test方法&quot;);
        }
    }

    public Inner getInner(){
        return new Inner();
    }

    public static void main(String[] args) {
        //调用接口而来的test()方法
        Test t = new Test();
        Demo d = t.getInner();
        d.test();

        //调用继承而来的test()方法
        t.test();
    }
}</code></pre><p>运行结果  </p>
<pre><code>接口的test方法
父类的test方法</code></pre><h2 id="3-参考文章"><a href="#3-参考文章" class="headerlink" title="3.参考文章"></a>3.参考文章</h2><p><a href="https://www.cnblogs.com/HHR-SUN/p/11699273.html" target="_blank" rel="noopener">https://www.cnblogs.com/HHR-SUN/p/11699273.html</a><br><a href="https://www.cnblogs.com/uu5666/p/8185061.html" target="_blank" rel="noopener">https://www.cnblogs.com/uu5666/p/8185061.html</a><br><a href="https://blog.csdn.net/ziwen00/article/details/8838841" target="_blank" rel="noopener">https://blog.csdn.net/ziwen00/article/details/8838841</a>    </p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src>
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-enable="false" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/blog/js/plugin.js"></script>
<script src="/blog/js/typed.js"></script>
<script src="/blog/js/diaspora.js"></script>
<link rel="stylesheet" href="/blog/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/blog/photoswipe/default-skin/default-skin.css">
<script src="/blog/photoswipe/photoswipe.min.js"></script>
<script src="/blog/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
