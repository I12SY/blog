
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>排序算法之计数排序 - xiyou</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xiyou,"> 
    <meta name="description" content="无论是冒泡排序还是快速排序，都是基于元素之间的比较来进行排序的。但是有一些特殊的排序并不基于元素比较，如计数排序、桶排序、基数排序。这里我们要讲的就是计数排序，以计数排序来说，这种排序算法是利用数组,"> 
    <meta name="author" content="xiyou"> 
    <link rel="alternative" href="atom.xml" title="xiyou" type="application/atom+xml"> 
    <link rel="icon" href="/blog/img/favicon.png"> 
    
    <link rel="stylesheet" href="/blog/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">xiyou</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xiyou13921.gitee.io/blog"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">排序算法之计数排序</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">排序算法之计数排序</h1>
        <div class="stuff">
            <span>二月 22, 2020</span>
            

        </div>
        <div class="content markdown">
            <p>无论是冒泡排序还是快速排序，都是基于<strong>元素之间的比较</strong>来进行排序的。但是有一些特殊的排序并不基于元素比较，如<strong>计数排序、桶排序、基数排序。</strong><br>这里我们要讲的就是计数排序，以计数排序来说，这种排序算法是利用数组下标来确定元素的正确位置的。  </p>
<a id="more"></a>  
<p>假设数组中有20个随机整数，取值范围为0~10，要求用最快的速度把这20个整数从小到大进行排序。<br>考虑到只能从0、1、2、3、4、5、6、7、8、9、10这11个数中取值，取值范围有限。所以，可以根据有限的范围，建立一个长度为11的数组，数组下标从0到10，元素初始值全为0。<br><img src="/blog/img/2020/02/22/计数排序1.png"><br><br>假设这20个随机整数的值如下所示。<br>9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9，7，9<br>下面就开始遍历这个无序的随机序列，每一个整数按照基本其值对号入座，同时，对应数组下标整数是9，那么数组下标为9的元素加1。<br>例如第一个整数是9，那么对应的数组下标为9的元素加1。<br><img src="/blog/img/2020/02/22/计数排序2.png"><br><br>第2个整数是3，那么数组下标为3的元素加1。<br><img src="/blog/img/2020/02/22/计数排序3.png"><br><br>继续遍历数列并修改数组…..<br>最终，当数列遍历完毕时，数组的状态如下。<br><img src="/blog/img/2020/02/22/计数排序4.png"><br><br>该数组每一个下标位置的值代表数列中对应整数出现的次数。<br>有了这个统计结果，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次。<br>0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10<br>显然，现在输出的数列已经有序的了。  </p>
<p><strong>实现代码</strong>  </p>
<pre><code>public class CountSort {

    public static int[] sort(int[] arr){
        //1.得到数组的最大值
        int max = arr[0];
        for (int i = 0; i &lt; arr.length; i++) {
            if(max&lt;arr[i]){
                max = arr[i];
            }
        }
        //2.根据最大值确定统计数组的长度
        int[] tmp = new int[max+1];
        //3.遍历数列，填充统计数组
        for (int i = 0; i &lt; arr.length; i++) {
            tmp[arr[i]]++;
        }
        //4.遍历统计数组，输出结果
        arr = new int[arr.length];
        int index = 0;
        for (int i = 0; i &lt; tmp.length; i++) {
            for (int j = 0; j &lt; tmp[i]; j++) {
                arr[index++] = i;
            }
        }
        return arr;
    }

    public static void main(String[] args) {
        int[] arr=new int[]{9,3,5,4,9,1,2,7,8,1,3,6,5,3,4,0,10,9,7,9};
        arr = sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}</code></pre><p>这段代码在开头有一个步骤，就是求数列的最大整数max。后面创建的统计数组tmp，长度是max+1，以此来保证数组的最后一个下标是max。  </p>
<p><strong>计数排序优化</strong><br>上面的例子中我们以数列中的最大值来决定统计数组的长度，其实并不严谨。例如下面的数列。<br>95，94，91，98，99，90，99，93，91，92<br>这个数列的最大值是99，最小值是90，如果创建长度为100的数组，那么前面从0到89的空间位置就都浪费了！<br>这个时候就不再是以<strong>输入数列的最大值+1</strong>作为统计数组的长度，而是以<strong>数列最大值-数列最小值+1</strong>作为统计数组的长度。同时，数列的最小值作为一个偏移量，用于统计数组中的下标。<br>以刚才的数列为例，统计数组的长度为99-90+1=10，偏移量等于数列的最小值90。<br>对于第1个整数95，对应的统计数组下标是95-90=5，如图所示。<br><img src="/blog/img/2020/02/22/计数排序5.png"><br><br><strong>代码示例</strong>  </p>
<pre><code>public static int[] sort(int[] arr){
    //1.得到数组的最大值和最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 0; i &lt; arr.length; i++) {
        if(max&lt;arr[i]){
            max = arr[i];
        }
        if(min&gt;arr[i]){
            min = arr[i];
        }
    }
    //2.根据最大值确定统计数组的长度
    int[] tmp = new int[max-min+1];
    //3.遍历数列，填充统计数组
    for (int i = 0; i &lt; arr.length; i++) {
        tmp[arr[i]-min]++;
    }
    //4.遍历统计数组，输出结果
    arr = new int[arr.length];
    int index = 0;
    for (int i = 0; i &lt; tmp.length; i++) {
        for (int j = 0; j &lt; tmp[i]; j++) {
            arr[index++] = min+i;
        }
    }
    return arr;
}</code></pre><p><strong>计数排序再优化</strong><br>是的，上面的例子确实对计数排序进行了优化。此外，朴素版的计数排序只是简单的按照数组的下标输出元素值，并没有真正给原始数列进行排序。<br>如果只是单纯的给整数排序，这样做并没有问题。但如果在现实业务里，例如给学生的考试分数进行排序，遇到相同的分数就会分不清谁是谁。<br>什么意思？看下面这个例子。<br><img src="/blog/img/2020/02/22/分数.png"><br><br>给出一个学生表，要求按成绩从高到低进行排序，如果成绩相同，则遵循表固有顺序。<br>那么，当我们填充统计数组以后，只知道有两个成绩并列为95分的同学，却不知道哪一个是小红，哪一个是小绿。<br><img src="/blog/img/2020/02/22/分数2.png"><br><br>怎么办？<br>仍然以刚才的学生成绩表为例，将之前的统计数组变形成下面的样子。<br><img src="/blog/img/2020/02/22/分数3.png"><br><br>这样加的目的，是让统计数组存储元素的元素值，等于相应整数的最终排序位置的序号。例如下标是9的元素值为5，代表原始数列的整数9，最终的排序在第5位。<br>接下来，创建输出数组sortedArray，长度和输入数列一致。然后从后向前遍历输入数列。<br>第1步，遍历成绩表最后一行的小绿同学的成绩。<br>小绿的成绩是95分，找到sortedArray下标是5的元素，值是4，代表小绿的成绩排名位置在第4位。<br>同时，给countArray下标是5的元素值减1，从4变成3，代表下次再遇到95分的成绩时，最终排名是第3。<br><img src="/blog/img/2020/02/22/分数4.png"><br><br>第2步，遍历成绩表倒数第2行的小白同学的成绩。<br>小白的成绩是94分，找到sortedArray下标是4的元素，值是2，代表小绿的成绩排名位置在第2位。<br>同时，给countArray下标是4的元素值减1，从2变成1，代表下次再遇到94分的成绩时(实际上已经遇不到了)，最终排名是第1。<br><img src="/blog/img/2020/02/22/分数5.png"><br><br>第3步，遍历成绩表倒数第3行的小红同学的成绩。<br>小白的成绩是95分，找到sortedArray下标是5的元素，值是3，代表小红的成绩排名位置在第3位(最初是4，减1变成了3)，代表小红的成绩排名位置在第3位。<br>同时，给countArray下标是5的元素值减1，从3变成2，代表下次再遇到95分的成绩时(实际上已经遇不到了)，最终排名是第2。<br><img src="/blog/img/2020/02/22/分数6.png"><br><br>这样一来，同样是95分的小红和小绿就能够清楚地排出顺序了，也正因为此，优化版本的计数排序属于<strong>稳定排序</strong>。  
后面的推理过程以此类推。<br><strong>代码示例</strong>  </p>
<pre><code>public static int[] sort(int[] arr){
    //1.得到数组的最大值和最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 0; i &lt; arr.length; i++) {
        if(max&lt;arr[i]){
            max = arr[i];
        }
        if(min&gt;arr[i]){
            min = arr[i];
        }
    }
    //2.创建统计数组并统计对应元素的个数
    int[] countArray = new int[max-min+1];
    for (int i = 0; i &lt; arr.length; i++) {
        countArray[arr[i]-min]++;
    }
    //3.统计数组变形
    for (int i = 0; i &lt; countArray.length-1; i++) {
        countArray[i+1] = countArray[i+1]+countArray[i];
    }
    //4.倒序遍历原始数组，从统计数组找到正确的位置，输出到结果数组
    int[] srotedArray = new int[arr.length];
    for (int i = arr.length-1; i &gt;=0; i--) {
        srotedArray[countArray[arr[i]-min]-1] = arr[i];
        countArray[arr[i]-min]--;
    }
    return srotedArray;
}</code></pre><p>代码第1、2、4步都涉及遍历原始数列，运算量都是n，第3步遍历统计数组，运算量是m，所以总体运算量是3n+m，去掉系数，时间复杂度是O（n+m）。<br>至于空间复杂度，如果不考虑结果数组，只考虑统计数组大小的话，空间复杂度是O(m)。  </p>
<p>虽然统计数组很强大，但是有局限性。<br><strong>1.当数列最大值和最小值差距过大时，并不适合计数排序。</strong><br>例如给你20个随机整数，范围在0到1亿之间。<br><strong>2.当数列元素不是整数时，也不适合用计数排序。</strong><br>例如25.213或0.000001这样的数字，无法创建对应的统计数组。<br>对于折现局限性，另一种线性时间排序算法做出了弥补，这种排序算法叫做<strong><a href="/blog/2020/02/22/排序算法之桶排序/" target="_blank">桶排序</a></strong>。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src>
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-enable="false" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/blog/js/plugin.js"></script>
<script src="/blog/js/typed.js"></script>
<script src="/blog/js/diaspora.js"></script>
<link rel="stylesheet" href="/blog/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/blog/photoswipe/default-skin/default-skin.css">
<script src="/blog/photoswipe/photoswipe.min.js"></script>
<script src="/blog/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
