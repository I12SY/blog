
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>排序算法之基数排序 - xiyou</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xiyou,"> 
    <meta name="description" content="基数排序（radix sort）属于”分配式排序”（distribution sort），又称”桶子法”（bucket sort或bin sort），顾名思义，它是透过键值的部分资讯，将要排序的元素,"> 
    <meta name="author" content="xiyou"> 
    <link rel="alternative" href="atom.xml" title="xiyou" type="application/atom+xml"> 
    <link rel="icon" href="/blog/img/favicon.png"> 
    
    <link rel="stylesheet" href="/blog/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">xiyou</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xiyou13921.gitee.io/blog"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">排序算法之基数排序</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">排序算法之基数排序</h1>
        <div class="stuff">
            <span>二月 22, 2020</span>
            

        </div>
        <div class="content markdown">
            <p>基数排序（radix sort）属于”分配式排序”（distribution sort），又称”桶子法”（bucket sort或bin sort），顾名思义，它是透过键值的部分资讯，将要排序的元素分配至某些”桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。  </p>
<a id="more"></a>  
<p><strong>基本解法</strong><br>以LSD为例，假设原来有一串数值如下所示：<br>73, 22, 93, 43, 55, 14, 28, 65, 39, 81<br>第1步：首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：<br><img src="/blog/img/2020/02/24/基数排序1.png"><br><br>第2步：接下来讲这些桶子中的数值重新串接起来，称为以下的数列：<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39<br>接下来在进行分配一次，这次是根据十位数来分配：<br><img src="/blog/img/2020/02/24/基数排序2.png"><br><br>第3步：接下来讲这些桶子中的数值重新串起来，成为一下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至到最高位为止。<br>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式正好与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并到一个数组中，而是在每个”桶子”中建立”子桶”，将每个桶子中的数值按照下一位的值分配到”子桶”中。在进行完最低位数的分配后在合并回单一的数组中。<br><strong>效率分析</strong><br>时间效率：设待排序列为n个记录，d个关键码(也就是最高位数)，关键码的取值范围为radix(可以指桶子数，0~9，一般就是10)，则进行链式基数排序的时间复杂度为O(d(n+radix))，其中，一趟分配时间复杂度为O(n)，一趟收集时间复杂度为O(radix)，共进行d趟分配和收集。<br>空间效率：需要2<em>radix个指向队列的辅助空间，以及用于静态链表的n个指针。<br>*</em>实现方法**  
最高位优先(Most Significant Digit first)法，简称MSD法：先按k1排序分组，同一组中记录，关键码k1相等，再对各组按k2排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有序序列。<br>最低位优先(Least Significant Digit first)法，简称LSD法：先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。    、</p>
<p><strong>LSD代码实现</strong>  </p>
<pre><code>public class RadixSort {

    public static void sort(int[] arr){
        //获取最高位数,也就是需要进行多少轮的收集排序
        int d = getMaxDigit(arr);
        //控制键值排序依据在哪一位
        int k = 1;
        int n = 1;
        int m = 0;
        //初始化桶子,数组的第一维表示可能的余数0-9
        int[][] tmp = new int[10][arr.length];
        //数组order[i]用来表示该位是i的数的个数
        int[] order = new int[10];
        while(k&lt;=d){
            for (int i = 0; i &lt; arr.length; i++) {
                int lsd = (arr[i]/n)%10;
                tmp[lsd][order[lsd]] = arr[i];
                order[lsd]++;
            }
            for (int i = 0; i &lt; 10; i++) {
                if(order[i]!=0){
                    for (int j = 0; j &lt; order[i]; j++) {
                        arr[m++] = tmp[i][j];
                    }
                    order[i]=0;
                }
            }
            m = 0;
            k++;
            n *=10;
        }
    }

    //获取最高位数
    public static int getMaxDigit(int[] arr){
        int max = arr[0];
        for (int i = 0; i &lt; arr.length; i++) {
            max = Math.max(max, arr[i]);
        }
        int d = 1;
        while(max/10&gt;0){
            d++;
            max/=10;
        }
        return d;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{73, 22, 93, 43, 55, 14, 28, 65, 39, 81};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}</code></pre><p><strong>MSD法</strong><br>以序列：15 ,  225,  105,  378,  334,   921,  32,  31为例，从最高位百位依次入桶，只有105有百位，其他百位按0算；检测每个桶中的数据。当桶中的元素个数多于1个的时候，要对这个桶递归进行下一位的分组。<br><img src="/blog/img/2020/02/25/基数排序MSD法图解.png"><br>  </p>
<p><strong>代码示例（略复杂）</strong>  </p>
<pre><code>/**
 * MSD法
 * @param arr 原始数组
 * @param m   原始数组需要被覆盖的起始位置(下标)
 * @param d   控制键值排序依据在哪一位
 * @param newArr 子序列
 * @return    原始数组被覆盖后的结束位置(下标)
 */
public static int msdSort(int[] arr,int m,int d,int[] newArr){
    if(d == 0){//一般来说当d=1时，也就是排序依据在个位时，就已经有序了，当出现了d=0的情况时，说明出现了重复数据
        for (int i = 0; i &lt; newArr.length; i++) {
            arr[m++] = newArr[0];
        }
        return m;
    }
    //获取数组中最长元素长度
    int k = new Double(Math.pow(10, d - 1)).intValue();
    //初始化桶子,数组的第一维表示可能的余数0-9
    int[][] tmp = new int[10][newArr.length];
    //数组order[i]用来表示该位是i的数的个数
    int[] order = new int[10];
    for (int i = 0; i &lt; newArr.length; i++) {
        int msd = (newArr[i]/k)%10;
        tmp[msd][order[msd]]=newArr[i];
        order[msd]++;
    }
    for (int i = 0; i &lt; 10; i++) {
        if(order[i]==1){
            arr[m++] = tmp[i][0];
        }else if(order[i]&gt;1){
            int[] arr2 = new int[order[i]];
            for (int j = 0; j &lt; order[i]; j++) {
                arr2[j] = tmp[i][j];
            }
            //进行递归操作，d-1的意思是告诉方法下一次要进行比较的位置
            m = msdSort(arr,m,d-1,arr2);
        }
    }
    return m;
}

//获取最高位数
public static int getMaxDigit(int[] arr){
    int max = arr[0];
    for (int i = 0; i &lt; arr.length; i++) {
        max = Math.max(max, arr[i]);
    }
    int d = 1;
    while(max/10&gt;0){
        d++;
        max/=10;
    }
    return d;
}

public static void main(String[] args) {
    int[] arr = new int[]{15,225,105,378,334,921,32,31};
    msdSort(arr,0,getMaxDigit(arr),arr);
    System.out.println(Arrays.toString(arr));
    arr = new int[]{15,225,105,378,334,921,32,15};
    msdSort(arr,0,getMaxDigit(arr),arr);
    System.out.println(Arrays.toString(arr));
}</code></pre><p>输出结果  </p>
<pre><code>[15, 31, 32, 105, 225, 334, 378, 921]
[15, 15, 32, 105, 225, 334, 378, 921]</code></pre>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src>
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-enable="false" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/blog/js/plugin.js"></script>
<script src="/blog/js/typed.js"></script>
<script src="/blog/js/diaspora.js"></script>
<link rel="stylesheet" href="/blog/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/blog/photoswipe/default-skin/default-skin.css">
<script src="/blog/photoswipe/photoswipe.min.js"></script>
<script src="/blog/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
