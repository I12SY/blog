
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>排序算法之堆排序 - xiyou</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xiyou,"> 
    <meta name="description" content="&amp;#8195;&amp;#8195;堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它,"> 
    <meta name="author" content="xiyou"> 
    <link rel="alternative" href="atom.xml" title="xiyou" type="application/atom+xml"> 
    <link rel="icon" href="/blog/img/favicon.png"> 
    
    <link rel="stylesheet" href="/blog/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">xiyou</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xiyou13921.gitee.io/blog"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">排序算法之堆排序</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">排序算法之堆排序</h1>
        <div class="stuff">
            <span>二月 21, 2020</span>
            

        </div>
        <div class="content markdown">
            <p>&#8195;&#8195;堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。  </p>
<a id="more"></a>  
<p>&#8195;&#8195;在前面的数据结构中，我们讲过<a href="/blog/2020/01/03/二叉堆/" target="_blank">二叉堆</a>的特性。<br>&#8195;&#8195;<strong>1.最大堆的堆顶是整个堆中的最大元素。</strong><br>&#8195;&#8195;<strong>2.最小堆的堆顶是整个堆中的最小元素。</strong>  </p>
<p>&#8195;&#8195;以最大堆为例，例如删除一个最大堆的堆顶(并不是完全删除，而是根据末尾的节点交换位置)，经过自我调整，第2大的元素就会被交换上来，称为最大堆的新堆顶。<br><img src="/blog/img/2020/02/21/堆排序1.png"><br><br>&#8195;&#8195;正如上图所示，当我们删除值为10的堆顶节点，经过调节，值为9的新节点就会顶替上来；当我们删除值为9的堆顶节点，经过调节，值为8的新节点就会顶替上来…….<br>&#8195;&#8195;由于二叉堆的这个特性，我们每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么我们只要反复删除堆顶，反复调节二叉堆，所得到的集合就成为了一个有序集合，过程如下：<br>&#8195;&#8195;删除节点9，节点8成为新堆顶：<br><img src="/blog/img/2020/02/21/堆排序2.png"><br><br>&#8195;&#8195;删除节点8，节点7成为新堆顶：<br><img src="/blog/img/2020/02/21/堆排序3.png"><br><br>&#8195;&#8195;删除节点7，节点6成为新堆顶：<br><img src="/blog/img/2020/02/21/堆排序4.png"><br><br>&#8195;&#8195;<strong>中间步骤略…..</strong><br>&#8195;&#8195;最后删除节点3，节点2成为新堆顶：<br><img src="/blog/img/2020/02/21/堆排序5.png"><br></p>
<p>&#8195;&#8195;到此为止，我们原本的最大堆已经变成了一个从小到大的有序集合。之前说过二叉堆实际存储在数组当中，数组中的元素排列如下：<br><img src="/blog/img/2020/02/21/堆排序6.png"><br></p>
<p>&#8195;&#8195;由此，可以归纳出堆排序的排序算法。<br>&#8195;&#8195;<strong>1.把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。</strong><br>&#8195;&#8195;<strong>2.循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。</strong>  </p>
<p>&#8195;&#8195;<strong>那么有人会疑惑为什么不使用小堆排升序呢？</strong><br>&#8195;&#8195;我们再想想：首先使用堆排序主要是用堆顶元素，如果使用小堆排升序，此时堆顶的元素是最小的，当我们取出堆顶元素时，此时小根堆的性质就变了，那么下次就找不到第二小的元素了，还要重新建堆。所以不能使用小堆排升序。有兴趣的可以自己来画图走一走。  </p>
<p>&#8195;&#8195;<strong>堆排序代码实现</strong>  </p>
<pre><code>public class HeapSort {

    public static void sort(int[] arr){
        //1.构建最大堆
        for (int i = (arr.length-2)/2; i&gt;=0 ; i--) {
            downAdjust(arr,i,arr.length);
        }
        System.out.println(Arrays.toString(arr));
        //2.循环删除堆顶元素，移到尾部集合，调整产生新的堆顶
        for (int i = arr.length-1; i &gt;0; i--) {
            int top = arr[0];
            arr[0] = arr[i];
            arr[i] = top;
            //下沉调整最大堆
            downAdjust(arr,0,i);
        }


    }

    /**
     * 下沉节点 （构建最大堆）
     * @param arr 待调整的堆
     * @param parentIndex 要&quot;下沉&quot;的父节点
     * @param length 堆的有效长度
     */
    public static void downAdjust(int[] arr,int parentIndex,int length){
        int childrenIndex = 2*parentIndex+1;
        int tmp = arr[parentIndex];
        while(childrenIndex&lt;length){
            if(childrenIndex+1&lt;length &amp;&amp; arr[childrenIndex]&lt;arr[childrenIndex+1]){
                childrenIndex = childrenIndex+1;
            }
            if(tmp&gt;arr[childrenIndex]){
                break;
            }
            arr[parentIndex] = arr[childrenIndex];
            parentIndex = childrenIndex;
            childrenIndex = 2*parentIndex+1;
        }
        arr[parentIndex] = tmp;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{1,3,2,6,5,7,8,9,10,0};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}</code></pre><p>&#8195;&#8195;<strong>时间复杂度</strong><br>&#8195;&#8195;二叉堆的节点下沉调整（downAdjust方法）是堆排序算法的基础，这个调节操作的时间复杂度是O(logn)。<br>&#8195;&#8195;再来回顾一下堆排序的算法步骤：<br>&#8195;&#8195;1.把无序数组构成二叉堆。这一步的的时间复杂度是<strong>O(n)。（<a href="/blog/2020/02/22/建堆的时间复杂度/" target="_blank">为什么建堆的时间复杂度是O(n)?</a>）</strong><br>&#8195;&#8195;2.循环删除堆顶元素，并将该元素移动到集合尾部，调整堆产生新的堆顶。这一步需要进行n-1次循环，每次循环调用一次downAdjust方法，所以第2步的计算规模是（n-1）x logn，时间复杂度为<strong>O(nlogn)。</strong><br>&#8195;&#8195;两个步骤是并列的关系，所以整体时间复杂度是<strong>O(nlogn)。</strong>  </p>
<p>&#8195;&#8195;<strong>与快速排序相比有什么区别和联系？</strong><br>&#8195;&#8195;首先相同点是，快速排序和堆排序的平均时间复杂度都是O(nlogn)，并且都是不稳定排序。至于不同点，快速排序的最坏时间复杂度是O(n²)，而堆排序的最坏时间复杂度是稳定在O(nlogn)。<br>&#8195;&#8195;快速排序的递归和非递归方法的平均空间复杂度都是O(logn),而堆排序的空间复杂度是O(1)。  </p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src>
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-enable="false" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/blog/js/plugin.js"></script>
<script src="/blog/js/typed.js"></script>
<script src="/blog/js/diaspora.js"></script>
<link rel="stylesheet" href="/blog/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/blog/photoswipe/default-skin/default-skin.css">
<script src="/blog/photoswipe/photoswipe.min.js"></script>
<script src="/blog/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
