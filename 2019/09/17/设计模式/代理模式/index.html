
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>代理模式 - xiyou</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xiyou,"> 
    <meta name="description" content="在代理模式(Proxy Pattern)中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 

1.介绍意图：为其它对,"> 
    <meta name="author" content="xiyou"> 
    <link rel="alternative" href="atom.xml" title="xiyou" type="application/atom+xml"> 
    <link rel="icon" href="/blog/img/favicon.png"> 
    
    <link rel="stylesheet" href="/blog/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">xiyou</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xiyou13921.gitee.io/blog"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">代理模式</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">代理模式</h1>
        <div class="stuff">
            <span>九月 17, 2019</span>
            

        </div>
        <div class="content markdown">
            <p>在代理模式(Proxy Pattern)中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 </p>
<a id="more"></a>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>意图：</strong>为其它对象提供一种代理以控制对这个对象的访问。<br><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因(比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问)，直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。<br><strong>何时使用：</strong>想访问一个类时做一些控制。<br><strong>如何解决：</strong>增加中间层。<br><strong>关键代码：</strong>实现与被代理组合。<br><strong>应用实例：</strong>1、windows里面的快捷方式。2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。3、买火车票不一定在火车站买，也可以去代售点。4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。5、spring aop<br><strong>优点：</strong>1、职责清晰。2、高扩展性 。3、智能化。<br><strong>缺点：</strong>1、由于客户端和真实主题之间增加了代理对象，因此某些类型的代理模式可能会造成请求的处理速度变慢。2、实现代理需要额外的工作，有些代理模式的实现非常复杂。<br><strong>使用场景：</strong>按职责来划分，通常有以下使用场景：1、远程代理。2、虚拟代理。3、Copy-on-Writer代理。4、保护(Protect or Access)代理。5、Cache代理。6、防火墙(Firewall)代理。7、同步化(Synchronization)代理。8、智能引用(Smart Reference)代理。<br><strong>注意事项：</strong>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。2、和装饰器模式的区别：装饰器模式是为了增强功能，而代理模式为了加以控制。   </p>
<h2 id="2-模式原理"><a href="#2-模式原理" class="headerlink" title="2.模式原理"></a>2.模式原理</h2><h3 id="2-1-UML类图"><a href="#2-1-UML类图" class="headerlink" title="2.1 UML类图"></a>2.1 UML类图</h3><img src="/blog/img/2019/09/17/2.png"> 

<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>Subject类，定义了RealSubject和Proxy的公用接口，这样就在任何使用RealSubject的地方都可以使用Proxy  </p>
<pre><code>public abstract class Subject {
    public abstract void request();
}</code></pre><p>RealSubject类，定义Proxy所代表的的真实实体</p>
<pre><code>public class RealSubject extends Subject {
    @Override
    public void request() {
        System.out.println(&quot;真实的请求&quot;);
    }
}</code></pre><p>Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口，这样代理可以用来替代实体。  </p>
<pre><code>public class Proxy extends Subject {
    private RealSubject realSubject;

    @Override
    public void request() {
        if(realSubject == null){
            realSubject = new RealSubject();
        }
        realSubject.request();
    }
}</code></pre><p>客户端代码</p>
<pre><code>public class Client {
    public static void main(String[] args) {
        Proxy proxy = new Proxy();
        proxy.request();
    }
}</code></pre><h2 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h2><p>从上面的例子可以看出静态代理模式的一个优点：扩展原功能，不侵入源代码。<br>再看看这种代理模式的缺点：假如有这样一个需求，有十个不同的RealSubject，同时我们要去代理的方法是不同的，比如要代理方法：request、request1、request2，添加代理前，源代码可能是这样的：</p>
<blockquote>
<p>realSubject.request();<br>realSubject1.request1();<br>realSubject2.request2();</p>
</blockquote>
<p>为了解决这个问题，我们有方案一：<br>为这些方法创建不同的代理类，代理后的代码是这样的：  </p>
<blockquote>
<p>proxy.request();<br>proxy1.request1();<br>proxy2.request2();</p>
</blockquote>
<p>当然，也有方案二：<br>通过创建一个proxy，持有不同的realSubject，实现Subject、Subject1、Subject2接口，让代码变成这样：  </p>
<blockquote>
<p>proxy.request();<br>proxy.request1();<br>proxy.request2();</p>
</blockquote>
<p>于是你的代理模型会变成这样：<br><img src="/blog/img/2019/09/17/3.png">  </p>
<p>毫无疑问，仅仅为了扩展同样的功能，在方案一中，我们会重复创建多个逻辑相同，仅仅RealSubject引用不同的Proxy。  </p>
<p>而在方案二中，会导致proxy的膨胀，而且这种膨胀往往是无意义的。此外，假如方法签名是相同的，更需要在调用的时候引入额外的判断逻辑。</p>
<p><strong>java 动态代理</strong><br>搞清楚静态代理的缺点十分重要，因为动态代理的目的就是为了解决静态代理的缺点。通过使用动态代理，我们可以通过在运行时，动态生成一个持有RealSubject、并实现代理接口的Proxy，同时注入我们相同的扩展逻辑。哪怕你要代理的RealSubject是不同的对象，甚至代理不同的方法，都可以动过动态代理，来扩展功能。<br>简单理解，动态代理就是我们上面提到的方案一，只不过这些proxy的创建都是自动的并且是在运行期生成的。</p>
<h3 id="4-1-JDK-自带的动态代理"><a href="#4-1-JDK-自带的动态代理" class="headerlink" title="4.1 JDK 自带的动态代理"></a>4.1 JDK 自带的动态代理</h3><p>java.lang.reflect.Proxy：生成动态代理类和对象；<br>java.lang.reflect.InvocationHandler(处理器接口)：可以通过invoke方法实现对真实角色的代理访问。<br>每次通过Proxy生成的代理类对象都要指定对应的处理器对象。<br>代码：<br>a)接口：Subject.java</p>
<pre><code>public interface Subject {
    public int sellBooks();
    public String speak();
}</code></pre><p>b)真实对象：RealSubject.java  </p>
<pre><code>public class RealSubject implements Subject{
    @Override
    public int sellBooks() {
        System.out.println(&quot;卖书&quot;);
        return 1;
    }
    @Override
    public String speak() {
        System.out.println(&quot;说话&quot;);
        return &quot;张三&quot;;
    }
}</code></pre><p>c)处理器对象：MyInvocationHandler.java</p>
<pre><code>//定义一个处理器
public class MyInvocationHandler implements InvocationHandler{

    //因为需要处理真实角色，所以要把真实角色传进来
    Object realSubject;

    public MyInvocationHandler(Object realSubject){
        this.realSubject=realSubject;
    }

    /**
    * @param proxy    代理类
    * @param method    正在调用的方法
    * @param args      方法的参数
    * @return
    * @throws Throwable
    */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //代理扩展逻辑            
        System.out.println(&quot;调用代理类&quot;);
        if(method.getName().equals(&quot;sellBooks&quot;)){
            int invoke = (int)method.invoke(realSubject, args);
            return invoke;
        }else{
            String string = (String)method.invoke(realSubject, args);
            System.out.println(&quot;调用的是说话的方法&quot;);
            return string;
        }
    }

}</code></pre><p>d)调用端：Client.java</p>
<pre><code>public class Client {
    public static void main(String[] args) {
        //真实对象
        Subject realSubject = new RealSubject();

        MyInvocationHandler myInvocationHandler = new MyInvocationHandler(realSubject);

        //代理对象
        Subject proxyClass = (Subject)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), 
                new Class[]{Subject.class}, myInvocationHandler);
        proxyClass.sellBooks();
        proxyClass.speak();
    }
}</code></pre><p>Proxy.newProxyInstance传入的是一个ClassLoader，一个代理接口，和我们定义的handler，返回的是一个Proxy实例。  </p>
<pre><code>public static void main(String[] args) {
    //Proxy proxy = new Proxy();
    //proxy.request();
    Proxy proxy = new Proxy();
    Subject proxyClass = proxy;
    proxyClass.request();
}</code></pre><p>仔细体会这个过程，其实有点类似我们在静态代理中提到的方案一，生成了一个包含我们扩展功能，持有RealSubject引用，实现Subject接口的代理实例Proxy。只不过这个Proxy不是我们自己写的，而是java帮我们生成，有没有一点动态的味道。  </p>
<p>让我们回顾一下代理三要素：真实对象：RealSubject，代理接口：Subject，代理实例：Proxy  </p>
<p>上面的代码含义也就是，输入RealSubject、Subject，返回一个Proxy。妥妥的代理模式。  </p>
<p>综上，动态生成+代理模式，也就是动态代理。  </p>
<p><strong>看一下源码</strong><br>道理讲清楚了，但是我们还不清楚这个Proxy是如何自动被生成的。入口就在newProxyInstance方法，核心代码如下：  </p>
<pre><code>private static final Class&lt;?&gt;[] constructorParams = { InvocationHandler.class };

public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)throws IllegalArgumentException
{
    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);
    ...
    final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);

    if (!Modifier.isPublic(cl.getModifiers())) {
        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
             public Void run() {
                cons.setAccessible(true);
                return null;
            }
        });
    }
    return cons.newInstance(new Object[]{h});
}</code></pre><p>整体流程就是：<br>&nbsp;&nbsp;1、生成代理类Proxy的Class对象。<br>&nbsp;&nbsp;2、如果Class作用域为私有，通过setAccessible支持访问。<br>&nbsp;&nbsp;3、获取Proxy Class构造函数，创建Proxy代理实例。  </p>
<p>生成Proxy的Class文件<br>&nbsp;&nbsp;生成Class对象的方法中，先是通过传进来的ClassLoader参数和Class[]数组对象作为组成键，维护了一个对于Proxy的Class对象的缓存。这样需要相同Proxy的Class对象时，只需要创建一次。<br>&nbsp;&nbsp;第一次创建该Class文件时，为了线程安全，方法进行了大量的处理，最后会来到ProxyClassFactory的apply方法中，经过以下流程：<br>&nbsp;&nbsp;1、检验传入的接口是否由传入的ClassLoader加载的。<br>&nbsp;&nbsp;2、校验传入是否是接口的Class对象。<br>&nbsp;&nbsp;3、检验是否传入重复的接口。<br>&nbsp;&nbsp;4、拼装代理类包名和类名，生成class文件的字节码。<br>&nbsp;&nbsp;5、调用native方法，传入字节码，生成Class对象。  </p>
<pre><code>private static final class ProxyClassFactory
    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;
{
    // prefix for all proxy class names
    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;

    // next number to use for generation of unique proxy class names
    private static final AtomicLong nextUniqueNumber = new AtomicLong();

    @Override
    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {

        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);
        for (Class&lt;?&gt; intf : interfaces) {
            /*
             * Verify that the class loader resolves the name of this
             * interface to the same Class object.
             */
            Class&lt;?&gt; interfaceClass = null;
            try {
                interfaceClass = Class.forName(intf.getName(), false, loader);
            } catch (ClassNotFoundException e) {
            }
            //1、检验传入的接口是否由传入的ClassLoader加载的
            if (interfaceClass != intf) {
                throw new IllegalArgumentException(
                    intf + &quot; is not visible from class loader&quot;);
            }
            /*
             * Verify that the Class object actually represents an
             * interface.
             */
            //2、校验传入是否是接口的Class对象。
            if (!interfaceClass.isInterface()) {
                throw new IllegalArgumentException(
                    interfaceClass.getName() + &quot; is not an interface&quot;);
            }
            /*
             * Verify that this interface is not a duplicate.
             */
            //3、检验是否传入重复的接口
            if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
                throw new IllegalArgumentException(
                    &quot;repeated interface: &quot; + interfaceClass.getName());
            }
        }

        String proxyPkg = null;     // package to define proxy class in
        int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

        /*
         * Record the package of a non-public proxy interface so that the
         * proxy class will be defined in the same package.  Verify that
         * all non-public proxy interfaces are in the same package.
         */
        for (Class&lt;?&gt; intf : interfaces) {
            int flags = intf.getModifiers();
            if (!Modifier.isPublic(flags)) {
                accessFlags = Modifier.FINAL;
                String name = intf.getName();
                int n = name.lastIndexOf(&apos;.&apos;);
                String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));
                if (proxyPkg == null) {
                    proxyPkg = pkg;
                } else if (!pkg.equals(proxyPkg)) {
                    throw new IllegalArgumentException(
                        &quot;non-public interfaces from different packages&quot;);
                }
            }
        }

        if (proxyPkg == null) {
            // if no non-public proxy interfaces, use com.sun.proxy package
            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;
        }

        /*
         * Choose a name for the proxy class to generate.
         */
        //4、拼装代理类包名和类名，生成class文件的字节码
        long num = nextUniqueNumber.getAndIncrement();
        String proxyName = proxyPkg + proxyClassNamePrefix + num;

        /*
         * Generate the specified proxy class.
         */
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces, accessFlags);
        try {
            //5、调用native方法，传入字节码，生成Class对象
            return defineClass0(loader, proxyName,
                                proxyClassFile, 0, proxyClassFile.length);
        } catch (ClassFormatError e) {
            /*
             * A ClassFormatError here means that (barring bugs in the
             * proxy class generation code) there was some other
             * invalid aspect of the arguments supplied to the proxy
             * class creation (such as virtual machine limitations
             * exceeded).
             */
            throw new IllegalArgumentException(e.toString());
        }
    }
}</code></pre><p>&nbsp;&nbsp;看一下第四步生成class文件字节码的过程，主要分为两个阶段：  </p>
<pre><code>addProxyMethod(hashCodeMethod, Object.class);
addProxyMethod(equalsMethod, Object.class);
addProxyMethod(toStringMethod, Object.class);

for (int i = 0; i &lt; interfaces.length; i++) {
    Method[] methods = interfaces[i].getMethods();
    for (int j = 0; j &lt; methods.length; j++) {
         addProxyMethod(methods[j], interfaces[i]);
    }
}
methods.add(this.generateConstructor());

 for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {
    for (ProxyMethod pm : sigmethods) { 
        fields.add(new FieldInfo(pm.methodFieldName,
                                   &quot;Ljava/lang/reflect/Method;&quot;, ACC_PRIVATE | ACC_STATIC));
        methods.add(pm.generateMethod());
    }
 }
methods.add(generateStaticInitializer());</code></pre><p>&nbsp;&nbsp;第一个阶段的代码比较清晰，主要就是添加各种Method，比如toString()、equals，以及传入的代理接口中的方法。再添加一下构造方法以及静态初始化方法。这样构成了一个对象，存储生成Proxy的Class的一些信息。  </p>
<p>&nbsp;&nbsp;到了这里，已经把要构造的Proxy的方法基本定义完成了，接下来就是要生成这个Class文件了。  </p>
<pre><code>ByteArrayOutputStream bout = new ByteArrayOutputStream();
 DataOutputStream dout = new DataOutputStream(bout);
 dout.writeInt(0xCAFEBABE);
 ...
 dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);
 ...
 return bout.toByteArray();</code></pre><p>&nbsp;&nbsp;看到这个CAFEBABE，就清楚第二阶段的内容了。CAFEBABE是Class文件的魔数，关于Class文件这个咖啡宝贝的魔数，相信做java的人都知道。没错，第二阶段就是生成字节码文件。按JVM规范，写入Class文件中包括权限控制、方法表、字段表等内容，生成符合规定的Class文件。最后返回对应的字节码。  </p>
<p>&nbsp;&nbsp;字节码生成以后，通过调用native方法defineClass解析字节码，就生成了Proxy的Class对象。  </p>
<p>Proxy构造方法<br>&nbsp;&nbsp;看一下Proxy的构造方法字节码生成部分：  </p>
<pre><code>MethodInfo minfo = new MethodInfo(&quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;,ACC_PUBLIC);
DataOutputStream out = new DataOutputStream(minfo.code);
code_aload(0, out);
code_aload(1, out);
out.writeByte(opc_invokespecial);
out.writeShort(cp.getMethodRef(superclassName,&quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;));
...</code></pre><p>&nbsp;&nbsp;关键在于，生成了一个参数为InvocationHandler的构造方法，code加载的是jvm方法区中的代码，然后通过invokespecial指令调用了父类构造方法。</p>
<p>查看生成的Class文件<br>&nbsp;&nbsp;上面利用字节码生成技术产生Class文件的过程，看起来可能比较晦涩，其实我们可以查看这个产生的Proxy到底是个什么样子。<br>&nbsp;&nbsp;注意ProxyGenerator中有这样一段代码：  </p>
<pre><code>if(saveGeneratedFiles) {
    ...
    FileOutputStream file = new FileOutputStream(dotToSlash(name) + &quot;.class&quot;);
    file.write(classFile);
    ...
 }</code></pre><p>&nbsp;&nbsp;再看一下saveGenerateFiles这个变量：  </p>
<pre><code>private final static boolean saveGeneratedFiles =
    java.security.AccessController.doPrivileged( 
    new GetBooleanAction(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;))
    .booleanValue();</code></pre><p>&nbsp;&nbsp;这是一个final类型的变量，通过GetBooleanAction方法读取系统变量，获取系统设置。默认这个值是false，稍微看一下System这个类的源码，发现有可以设置系统变量的API，然后在程序中的main函数设置一下这个变量：  </p>
<pre><code>System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code></pre><p>这个时候在跑一遍程序，就可以看到生成的Proxy的Class文件了，直接双击利用idea反编译。  </p>
<pre><code>package com.sun.proxy;

import JAVA基础.设计模式.代理模式.动态代理.Subject;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy0 extends Proxy implements Subject {
    private static Method m1;
    private static Method m2;
    private static Method m4;
    private static Method m3;
    private static Method m0;

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    ...

    public final String speak() throws  {
        try {
            return (String)super.h.invoke(this, m4, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int sellBooks() throws  {
        try {
            return (Integer)super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    ...

    static {
        try {
            ...
            m4 = Class.forName(&quot;JAVA基础.设计模式.代理模式.动态代理.Subject&quot;).getMethod(&quot;speak&quot;);
            m3 = Class.forName(&quot;JAVA基础.设计模式.代理模式.动态代理.Subject&quot;).getMethod(&quot;sellBooks&quot;);
            ...
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}</code></pre><p>&nbsp;&nbsp;省略几个无关重要的方法，可以看到三个重要的方法。<br>&nbsp;&nbsp;其中两个是我们的代理方法speak和sellBooks，另外一个就是构造方法。<br>&nbsp;&nbsp;这个$Proxy继承Proxy并调用了父类的构造方法，回忆一下上文提到的invokeSpecial，怎么样，对上了吧。  </p>
<p>&nbsp;&nbsp;看一下Proxy中这个构造方法：  </p>
<pre><code>protected Proxy(InvocationHandler h) {
    Objects.requireNonNull(h);
    this.h = h;
}</code></pre><p>&nbsp;&nbsp;再看一下$Proxy的代理方法：  </p>
<pre><code>super.h.invoke(this, m3, (Object[])null);</code></pre><p>&nbsp;&nbsp;再来回顾一下生成Proxy实例的过程：  </p>
<pre><code>private static final Class&lt;?&gt;[] constructorParams =
        { InvocationHandler.class };
...
final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
...
return cons.newInstance(new Object[]{h}); </code></pre><p>其实newInstance生成Proxy实例时，通过$Proxy0的Class对象，选择了这个InvocationHandler为参数的构造方法，传入我们定义的InvocationHnadler并生成了一个Proxy0的实例！InvocationHandler里有realSubject的逻辑以及我们的扩展逻辑，当我们调用Proxy0的speak和sellBooks方法时，就会调用我们InvocationHandler里实现的invoke方法。  </p>
<p>对上面这个过程，做一张图总结一下：<br><img src="/blog/img/2019/09/18/1.png">  </p>
<h3 id="4-2-Cglib动态代理"><a href="#4-2-Cglib动态代理" class="headerlink" title="4.2 Cglib动态代理"></a>4.2 Cglib动态代理</h3><p>Cglib动态代理是针对代理的类，动态生成一个子类，然后子类覆盖代理类中的方法，如果是private或是final类修饰的方法，则不会被重写。<br>CGLIB是一个功能强大，高性能的代码生成包。它没为有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。<br>CGLIB作为一个开源项目，其代码托管在github，地址为：<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">https://github.com/cglib/cglib</a>  </p>
<p>需要代理的类：  </p>
<pre><code>package cn.cpf.pattern.structure.proxy.cglib;
public class Engineer {
    // 可以被代理
    public void eat() {
        System.out.println(&quot;工程师正在吃饭&quot;);
    }

    // final 方法不会被生成的子类覆盖
    public final void work() {
        System.out.println(&quot;工程师正在工作&quot;);
    }

    // private 方法不会被生成的字类覆盖
    private void play() {
        System.out.println(&quot;this engineer is playing game&quot;);
    }
}</code></pre><p>CGLIB 代理类:  </p>
<pre><code>package cn.cpf.pattern.structure.proxy.cglib;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;

public class CglibProxy implements MethodInterceptor {
    private Object target;

    public CglibProxy(Object target) {
        this.target = target;
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println(&quot;###   before invocation&quot;);
        Object result = method.invoke(target, objects);
        System.out.println(&quot;###   end invocation&quot;);
        return result;
    }

    public static Object getProxy(Object target) {
        Enhancer enhancer = new Enhancer();
        // 设置需要代理的对象
        enhancer.setSuperclass(target.getClass());
        // 设置代理人
        enhancer.setCallback(new CglibProxy(target));
        return enhancer.create();
    }
}</code></pre><p>测试方法:  </p>
<pre><code>import java.lang.reflect.Method;
import java.util.Arrays;

public class CglibMainTest {
    public static void main(String[] args) {
        // 生成 Cglib 代理类
        Engineer engineerProxy = (Engineer) CglibProxy.getProxy(new Engineer());
        // 调用相关方法
        engineerProxy.eat();
    }
}</code></pre><p>运行结果:  </p>
<pre><code>###   before invocation
工程师正在吃饭
###   end invocation</code></pre><p>相关jar包下载：<br><a href="/blog/attachs/cglib-3.2.6.jar" target="blank">cglib-3.2.6.jar</a><br><a href="/blog/attachs/asm-all-6.0_BETA.jar" target="blank">asm-all-6.0_BETA.jar</a> </p>
<p><strong>jdk动态代理和cglib动态代理的区别：</strong><br>1）jdk动态代理只能对实现了接口的类生成代理，而不能针对类<br>2）CGLIB动态代理是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法</p>
<h2 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5.参考文章"></a>5.参考文章</h2><p><a href="https://www.runoob.com/design-pattern/proxy-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/proxy-pattern.html</a><br><a href="https://blog.csdn.net/WangQYoho/article/details/77584832" target="_blank" rel="noopener">https://blog.csdn.net/WangQYoho/article/details/77584832</a><br><a href="/blog/attachs/大话设计模式.pdf" target="blank">大话设计模式</a>  </p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src>
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-enable="false" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/blog/js/plugin.js"></script>
<script src="/blog/js/typed.js"></script>
<script src="/blog/js/diaspora.js"></script>
<link rel="stylesheet" href="/blog/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/blog/photoswipe/default-skin/default-skin.css">
<script src="/blog/photoswipe/photoswipe.min.js"></script>
<script src="/blog/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
