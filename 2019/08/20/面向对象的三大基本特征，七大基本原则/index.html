
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>面向对象的三大基本特征，七大基本原则 - xiyou</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xiyou,"> 
    <meta name="description" content="1)三大基本特征
1、封装
2、继承
3、多态

2）六大基本原则(设计模式的七大基本原则)
1、单一职责原则（SRP）  
2、开放封闭原则（OCP）  
3、里氏替换原则（LSP）  
4、依赖,"> 
    <meta name="author" content="xiyou"> 
    <link rel="alternative" href="atom.xml" title="xiyou" type="application/atom+xml"> 
    <link rel="icon" href="/blog/img/favicon.png"> 
    
    <link rel="stylesheet" href="/blog/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">xiyou</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xiyou13921.gitee.io/blog"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">面向对象的三大基本特征，七大基本原则</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">面向对象的三大基本特征，七大基本原则</h1>
        <div class="stuff">
            <span>八月 20, 2019</span>
            

        </div>
        <div class="content markdown">
            <h3 id="1-三大基本特征"><a href="#1-三大基本特征" class="headerlink" title="1)三大基本特征"></a>1)三大基本特征</h3><ul>
<li>1、<a href="#package" title="#package">封装</a></li>
<li>2、<a href="#extends" title="#extends">继承</a></li>
<li>3、<a href="#polymorphism" title="#polymorphism">多态</a></li>
</ul>
<h3 id="2）六大基本原则-设计模式的七大基本原则"><a href="#2）六大基本原则-设计模式的七大基本原则" class="headerlink" title="2）六大基本原则(设计模式的七大基本原则)"></a>2）六大基本原则(设计模式的七大基本原则)</h3><ul>
<li>1、<a href="#SRP" title="#SRP">单一职责原则（SRP）</a>  </li>
<li>2、<a href="#OCP" title="#OCP">开放封闭原则（OCP）</a>  </li>
<li>3、<a href="#LSP" title="#LSP">里氏替换原则（LSP）</a>  </li>
<li>4、<a href="#DIP" title="#DIP">依赖倒置原则（DIP）</a>  </li>
<li>5、<a href="#ISP" title="#ISP">接口隔离原则（ISP）</a></li>
<li>6、<a href="#LKP" title="#LKP">迪米特|最少知道原则（LKP）</a></li>
<li>7、<a href="#CAPP" title="#CAPP">合成复用原则（CAPP）</a><a id="more"></a>

</li>
</ul>
<h1 id="一、三大基本特征：封装、继承、多态"><a href="#一、三大基本特征：封装、继承、多态" class="headerlink" title="一、三大基本特征：封装、继承、多态"></a>一、三大基本特征：封装、继承、多态</h1><h2 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a><span id="package">1、封装</span></h2><p style="text-indent:2em">封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改数据的访问级别，将抽象得到的数据和行为(或功能)相结合，<b>形成一个有机的整体</b>，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。</p>
<p style="text-indent:2em">封装的目的是为了增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。(打个比方：例如我们使用String类的equals()方法，我们不需要知道equals()方法的具体内部实现，它是如何进行比较内容然后得到结果，我们只需要调用这个方法接口并传入另一个字符串(a.equals(b))，就能得到我们想要的结果)。</p>
<p style="text-indent:2em">面向对象的不就是使用程序处理事情时以对象为中心去分析吗，与面向过程不同，面向过程关心处理的逻辑、流程等问题，而不关心事件的主体。而面向对象即面向主体，所以我们在解决问题时应该先进性对象的封装(对象是封装类的实例，比如张三是人，人是一个封装类，张三只是对象中的一个实例、一个对象)。比如我们日常生活中的小兔子、小绵羊都可以封装成为一个类。</p>
<p style="text-indent:2em">比如兔子的属性有两只耳朵、四条腿、一双眼睛、三瓣嘴等；行为(功能)有跑、跳、吃素等。</p>  

<h2 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a><span id="extends">2、继承</span></h2><p style="text-indent:2em">继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。<b>继承就是子类继承父类的特征和行为</b>，使得子类对象(实例)具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。类似于下面这个图：</p>
<img src="/blog/img/2019/08/20/1.png">
<p style="text-indent:2em">我们在上面已经封装了兔子这个类，其他动物也一样可以进行封装。在封装过程中我们发现兔子、绵羊这两个类具有相似的功能或特性如吃草，所以我们可以<b>抽取共有特征和方法形成高一层的类</b>，如这里的草食动物、食肉动物。继承之间是子父类的关系。继承的机制可以很好的描述一个类的生态，也提高了代码的复用率，在java中的Object类是所有类的超类，常称作上帝类。</p>

<h2 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a><span id="polymorphism">3、多态</span></h2><p style="text-indent:2em">多态是指同一个行为具有多个不同表现形式或形态的能力。是指一个类实例(对象)的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这就意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们(那些操作)可以通过相同的方式给予调用。</p>
<p style="text-indent:2em"><b>多态的优点：</b></p>
<li>1.消除类型之间的耦合关系</li>
<li>2.可替换性</li>
<li>3.可扩充性</li>
<li>4.接口性</li>
<li>5.灵活性</li>
<li>6.简化性</li>
<p style="text-indent:2em"><b>多态存在的三个必要条件：</b></p>
<li>继承(接口)</li>
<li>重写(子类继承父类后对父类方法进行重新定义)</li>
<li>父类引用指向子类对象</li>
<p style="text-indent:2em">简言之，<b>多态其实是在继承的基础上的</b>。比如说今天我们要去动物园参观动物，那么你说我们去参观兔子、参观绵羊、参观狮子、参观豹子都是对的，但你不能说我们去参观汽车。在这个例子中，子类具有多态性：除了使用自己的身份，还能充当父类。</p>

<p>下面来看一个例子（接口也能间接达到继承的效果，这里以继承的方式为例）：</p>
<pre><code>//汽车类
abstract class Car { 
    // 汽车名称 
    abstract String getName(); 

    // 获得汽车售价 
    abstract int getPrice(); 
} 

// 宝马 
class BMW extends Car { 
    public String getName() { 
      return &quot;BMW&quot;; 
    } 

    public int getPrice() { 
      return 300000; 
    } 
} 

// 奇瑞QQ 
class CheryQQ extends Car { 
    public String getName() { 
      return &quot;CheryQQ&quot;; 
    } 

    public int getPrice() { 
      return 20000; 
    } 
} 

// 汽车出售店 
public class CarShop { 
    // 售车收入 
    private int money = 0; 

    // 卖出一部车 
    public void sellCar(Car car) { 
       System.out.println(&quot;车型：&quot; + car.getName() + &quot; 单价：&quot; + car.getPrice()); 
       // 增加卖出车售价的收入 
       money += car.getPrice(); 
    } 

    // 售车总收入 
    public int getMoney() { 
      return money; 
    } 

    public static void main(String[] args) { 
        CarShop aShop = new CarShop(); 
        // 卖出一辆宝马 
        aShop.sellCar(new BMW()); 
        // 卖出一辆奇瑞QQ 
        aShop.sellCar(new CheryQQ()); 
        System.out.println(&quot;总收入：&quot; + aShop.getMoney()); 
    } 
} </code></pre><p>运行结果：</p>
<pre><code>车型：BMW  单价：300000
车型：CheryQQ  单价：20000
总收入：320000</code></pre><p>继承是多态得以实现的基础。从字面上理解，多态就是一种类型（都是Car类型）表现出多种状态（宝马汽车的名称是BMW，售价是300000；奇瑞汽车的名称是CheryQQ，售价是2000）。将一个方法调用同这个方法所属的主体（也就是对象或类）关联起来叫做绑定，分前期绑定和后期绑定两种。下面解释一下它们的定义：</p>
<p>前期绑定：在程序运行之前进行绑定，由编译器和连接程序实现，又叫做静态绑定。比如static方法和final方法，注意，这里也包括private方法，因为它是隐式final的。<br>后期绑定：在运行时根据对象的类型进行绑定，由方法调用机制实现，因此又叫做动态绑定，或者运行时绑定。除了前期绑定外的所有方法都属于后期绑定。</p>
<p>多态就是在后期绑定这种机制上实现的。多态给我们带来的好处是消除了类之间的耦合关系，使程序更容易扩展。比如在上例中，新增加一种类型汽车的销售，只需要让新定义的类继承Car类并实现它的所有方法，而无需对原有代码做任何修改，CarShop类的sellCar(Car car)方法就可以处理新的车型了。新增代码如下：</p>
<pre><code>// 桑塔纳汽车 
class Santana extends Car { 
  public String getName() { 
    return &quot;Santana&quot;; 
  } 

  public int getPrice() { 
    return 80000; 
  } 
}</code></pre><h1 id="二、六大基本原则"><a href="#二、六大基本原则" class="headerlink" title="二、六大基本原则"></a>二、六大基本原则</h1><h2 id="1、单一职责原则（SRP）"><a href="#1、单一职责原则（SRP）" class="headerlink" title="1、单一职责原则（SRP）"></a><span id="SRP">1、单一职责原则（SRP）</span></h2><p style="text-indent:2em"><b>一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作。</b></p>
<p style="text-indent:2em">比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要if else判断是哪种情况，从类结构上来说将会是分臃肿。</p>  

<h2 id="2、开放封闭原则（OCP）"><a href="#2、开放封闭原则（OCP）" class="headerlink" title="2、开放封闭原则（OCP）"></a><span id="OCP">2、开放封闭原则（OCP）</span></h2><p style="text-indent:2em"><b>对象或实体应该对扩展开放，对修改封闭。</b></p>
<p style="text-indent:2em">更改封闭即是在我们对模块进行扩展时勿需对原有代码和DLL进行修改或重新编译文件！这个原则对我们设计类的时候很有帮助，坚持这个原则就必须尽量考虑接口封装，抽象机制和多态技术。</p>  

<h2 id="3、里氏替换原则（LSP）"><a href="#3、里氏替换原则（LSP）" class="headerlink" title="3、里氏替换原则（LSP）"></a><span id="LSP">3、里氏替换原则（LSP）</span></h2><p style="text-indent:2em"><b>在对象x为类型T时q(x)成立，那么当S是T的子类时，对象y为类型S时q(y)也应成立(即对父类的调用同样适用于子类)。</b></p> 
<p style="text-indent:2em"><b>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。 </b></p>  
这里来看个例子（举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。）：  

<pre><code>class A {
    public int func1(int a, int b) {
        return a - b;
    }
}

public class Client {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(&quot;100-50=&quot; + a.func1(100, 50));
        System.out.println(&quot;100-80=&quot; + a.func1(100, 80));
    }
}</code></pre><p>运行结果：  </p>
<pre><code>100-50=50
100-80=20</code></pre><p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：<br>两数相减。<br>两数相加，然后再加100。</p>
<p>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：  </p>
<pre><code>class B extends A {
    public int func1(int a, int b) {
        return a + b;
    }

    public int func2(int a, int b) {
        return func1(a, b) + 100;
    }
}

public class Client {
    public static void main(String[] args) {
        B b = new B();
        System.out.println(&quot;100-50=&quot; + b.func1(100, 50));
        System.out.println(&quot;100-80=&quot; + b.func1(100, 80));
        System.out.println(&quot;100+20+100=&quot; + b.func2(100, 20));
    }
}</code></pre><p>运行结果：  </p>
<pre><code>100-50=150
100-80=180
100+20+100=220</code></pre><p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。<br>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。<br>它包含以下4层含义：  </p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件(即方法的形参)要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件(即方法的返回值)要比父类更严格。</li>
</ul>
<p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？<br>后果就是：你写的代码出问题的几率将会大大增加。</p>
<h2 id="4、依赖倒置原则（DIP）"><a href="#4、依赖倒置原则（DIP）" class="headerlink" title="4、依赖倒置原则（DIP）"></a><span id="DIP">4、依赖倒置原则（DIP）</span></h2><p style="text-indent:2em"><b>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。具体实现应该依赖于抽象，而不是抽象依赖于实现。</b></p>
<p style="text-indent:2em">可以这样理解，上面我举例子的时候先说了兔子和绵羊，然后才推出草食动物。但是我们继续认识了牛、马等草食动物，我们会发现我们需要不断调整草食动物的描述，这样程序会变得僵化，所以我们不应该让子类依赖于实体，不应该让父类模块依赖于子类模块。所以我们需要将草食动物设计为抽象类，即<b>抽象类或接口</b>。这样下层只需要实现相应的细节而不会影响父类。</p>  

<h2 id="5、接口隔离原则（ISP）"><a href="#5、接口隔离原则（ISP）" class="headerlink" title="5、接口隔离原则（ISP）"></a><span id="ISP">5、接口隔离原则（ISP）</span></h2><p style="text-indent:2em"><b>不应强迫客户端实现它一个用不上的接口，或是说客户端不应该被强迫依赖他们不使用的方法，使用多个专门的接口比使用单个接口要好得多！</b></p>
<p style="text-indent:2em">比如，为了减少接口的定义，将许多类似的方法都放在一个接口中，最后会发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，这种承诺当然是越少越好，越精炼越好，过多的承诺带来的就是你的大量精力和时间去维护！</p> 

<h2 id="6、迪米特-最少知道原则（LKP）"><a href="#6、迪米特-最少知道原则（LKP）" class="headerlink" title="6、迪米特|最少知道原则（LKP）"></a><span id="LKP">6、迪米特|最少知道原则（LKP）</span></h2><p style="text-indent:2em"><b>一个类应该对其他对象有最少的了解；一个类应该对自己需要耦合或调用的类知道的最少，类的内部如何实现、如何复杂都与调用者或依赖者没关系，调用者或依赖者只需要知道他需要的方法即可，其他的一概不关心。</b></p>
<p style="text-indent:2em">类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也大。只与直接的朋友通信。每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。</p>  
例子：一般在使用框架的时候，框架的开发者会抽象出一个类供外部调用，而这个主要的类像是一个中介一样去调用框架里面的其他类，恰恰框架里面其他类一般都是不可访问(调用)的，这个框架就遵循了迪米特原则(Law of Demeter)，其他开发人员只关心调用的方法，并不需要关心功能具体如何实现。  
这里我们来看个例子：  
<img src="/blog/img/2019/08/21/1.jpg">  

<p>如果Lily和Jack自己做hamburg那么就会与Vegetable、Meat、Bread产生千丝万缕关系。上图，则由KFC来做，这样Lily和Jack就只与Hamburg有关关联，与材料就没有关联了。  </p>
<h2 id="7、合成复用原则（CAPP）"><a href="#7、合成复用原则（CAPP）" class="headerlink" title="7、合成复用原则（CAPP）"></a><span id="CAPP">7、合成复用原则（CAPP）</span></h2><p style="text-indent:2em"><b>尽量使用聚合、组合的方式，而不是使用继承。</b></p>
<p style="text-indent:2em">其实大部分人刚开始学会用面向对象的继承时，感觉它既新颖又功能强大，所以只要可以用，就都用上继承。这就好比是’有了新锤子，所有的东西看上去都成了钉子’。但事实上，很多情况用继承会带来麻烦。比如，<b>对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须被重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</b></p>
<p style="text-indent:2em">合成/聚合复用原则的好处是，<b>优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</b></p>


<h1 id="三、参考文章"><a href="#三、参考文章" class="headerlink" title="三、参考文章"></a>三、参考文章</h1><p><a href="https://www.cnblogs.com/fzz9/p/8973315.html" target="_blank" rel="noopener">https://www.cnblogs.com/fzz9/p/8973315.html</a><br><a href="https://www.jianshu.com/p/068b2d0ce4e6" target="_blank" rel="noopener">https://www.jianshu.com/p/068b2d0ce4e6</a><br><a href="https://my.oschina.net/u/3198904/blog/1633355?from=timeline" target="_blank" rel="noopener">https://my.oschina.net/u/3198904/blog/1633355?from=timeline</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src>
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-enable="false" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/blog/js/plugin.js"></script>
<script src="/blog/js/typed.js"></script>
<script src="/blog/js/diaspora.js"></script>
<link rel="stylesheet" href="/blog/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/blog/photoswipe/default-skin/default-skin.css">
<script src="/blog/photoswipe/photoswipe.min.js"></script>
<script src="/blog/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
