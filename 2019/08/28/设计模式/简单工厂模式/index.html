
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>简单工厂模式 - xiyou</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xiyou,"> 
    <meta name="description" content="1.定义简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例,"> 
    <meta name="author" content="xiyou"> 
    <link rel="alternative" href="atom.xml" title="xiyou" type="application/atom+xml"> 
    <link rel="icon" href="/blog/img/favicon.png"> 
    
    <link rel="stylesheet" href="/blog/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">xiyou</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xiyou13921.gitee.io/blog"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">简单工厂模式</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">简单工厂模式</h1>
        <div class="stuff">
            <span>八月 28, 2019</span>
            

        </div>
        <div class="content markdown">
            <h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。  </p>
<a id="more"></a>
<h2 id="2-基本简介"><a href="#2-基本简介" class="headerlink" title="2.基本简介"></a>2.基本简介</h2><p><strong>实现方式(附图)</strong><br>简单工厂模式的UML类图<br><img src="/blog/img/2019/08/28/1.jpg"><br>简单工厂模式的实质就是由一个工厂类根据传入的参数，动态决定哪一个产品类（这些产品类继承自一个父类或者接口）的实例。  </p>
<p>该模式中包含的角色及其职责  </p>
<p><strong>工厂(Creator)角色</strong><br>简单工厂模式的核心，他负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。  </p>
<p><strong>抽象产品(Product)角色</strong><br>简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。  </p>
<p><strong>具体产品(Concrete Product)角色</strong><br>是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。  </p>
<h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3.优缺点"></a>3.优缺点</h2><p><strong>优点</strong><br>工厂类是整个模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责”消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的，明确了各自的职责和权力，有利于整个软件体系结构的优化。 </p>
<p><strong>缺点</strong><br>由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部的创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则需要改变工厂类了。  </p>
<p>当系统中的具体产品类不断增多时，可能会出现要求工厂类根据不同条件创建不同实例的需求。这种条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利。  </p>
<p>这些缺点在<a href="/blog/2019/08/28/设计模式/工厂方法模式/">工厂方法模式</a>中得到了一定的克服。  </p>
<p><strong>使用场景</strong><br>工厂类负责创建的对象比较少；  </p>
<p>客户只知道传入工厂类的参数，对于如何创建对象(逻辑)不关心；  </p>
<p>由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。  </p>
<p><strong>c++代码：</strong>  </p>
<pre><code>//算法的父类，抽象出返回结果的接口
class Operation
{
public:
    virtual int GetResult() =0;
public:
    double m_Num1;
    double m_Num2;
};
//工厂类，用于生产相应的算法子类
class OperationFactry
{
public:
    OperationFactry(void);
    ~OperationFactry(void);
public:
    static Operation* CreateOperate(int n )
    {
        switch(n)
        {
        case 1:
            return new OperationAdd;
            break;
        }
    }
};
//算法子类，由工厂类创建，重写父类中的虚函数
class OperationAdd：Public Operation
{
public:
    int GetResult();
};</code></pre><h2 id="4-例子"><a href="#4-例子" class="headerlink" title="4.例子"></a>4.例子</h2><p>请用C++、Java、C#或VB.NET任意一种面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。 </p>
<p>1.创建运算类(抽象产品类)：  </p>
<pre><code>public abstract class Operation {

    private double number1 = 0;
    private double number2 = 0;

    public double getNumber1() {
        return number1;
    }
    public void setNumber1(double number1) {
        this.number1 = number1;
    }
    public double getNumber2() {
        return number2;
    }
    public void setNumber2(double number2) {
        this.number2 = number2;
    }

    public double getResult() throws Exception{
        return 0;
    }
}</code></pre><p>2.加减乘除类继承运算类(具体产品类)，重写getResult方法：  </p>
<pre><code>/**
 *加法类 
 */
class OperationAdd extends Operation{
    @Override
    public double getResult() throws Exception{
        return getNumber1()+getNumber2();
    }
}
/**
 *减法类 
 */
class OperationSub extends Operation{
    @Override
    public double getResult() throws Exception{
        return getNumber1()-getNumber2();
    }
}
/**
 *乘法类 
 */
class OperationMul extends Operation{
    @Override
    public double getResult() throws Exception{
        return getNumber1()*getNumber2();
    }
}
/**
 *除法类 
 */
class OperationDiv extends Operation{
    @Override
    public double getResult() throws Exception{
        if(getNumber2()==0){
            throw new Exception(&quot;除数不能为：0&quot;);
        }
        return getNumber1()/getNumber2();
    }
}</code></pre><p>3.创建简单工厂类：  </p>
<pre><code>public class OperationFactory {

    public static Operation createOperate(String operate){
        Operation oper = null;
        switch (operate) {
            case &quot;+&quot;:
                oper = new OperationAdd();
                break;
            case &quot;-&quot;:
                oper = new OperationSub();
                break;
            case &quot;*&quot;:
                oper = new OperationMul();
                break;
            case &quot;/&quot;:
                oper = new OperationDiv();
                break;
        }
        return oper;
    }
}</code></pre><p>4.客户端测试：  </p>
<pre><code>public class Test {
    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        System.out.println(&quot;请输入第一个数：&quot;);
        double number1 = scanner.nextDouble();
        System.out.println(&quot;请输入第二个数：&quot;);
        double number2 = scanner.nextDouble();
        System.out.println(&quot;请输入运算符：&quot;);
        String operate = scanner.next();
        Operation oper = OperationFactory.createOperate(operate);
        oper.setNumber1(number1);
        oper.setNumber2(number2);
        double result = oper.getResult();
        System.out.println(&quot;运算结果：&quot;+result);
        scanner.close();
    }
}</code></pre><p>运行结果：  </p>
<pre><code>请输入第一个数：
5
请输入第二个数：
2.5
请输入运算符：
/
运算结果：2.0</code></pre>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src>
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-enable="false" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/blog/js/plugin.js"></script>
<script src="/blog/js/typed.js"></script>
<script src="/blog/js/diaspora.js"></script>
<link rel="stylesheet" href="/blog/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/blog/photoswipe/default-skin/default-skin.css">
<script src="/blog/photoswipe/photoswipe.min.js"></script>
<script src="/blog/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
