
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>二叉树的遍历 - xiyou</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xiyou,"> 
    <meta name="description" content="在计算机中，遍历本身是一个线性操作。所以遍历同样具有线性结构的数组或链表，是一件轻而易举的事情。反观二叉树，是典型的非线性数据结构，遍历时需要把非线性关联的节点转化成一个线性序列，以不同的方式来遍历,"> 
    <meta name="author" content="xiyou"> 
    <link rel="alternative" href="atom.xml" title="xiyou" type="application/atom+xml"> 
    <link rel="icon" href="/blog/img/favicon.png"> 
    
    <link rel="stylesheet" href="/blog/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">xiyou</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xiyou13921.gitee.io/blog"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">二叉树的遍历</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">二叉树的遍历</h1>
        <div class="stuff">
            <span>十二月 31, 2019</span>
            

        </div>
        <div class="content markdown">
            <p>在计算机中，遍历本身是一个线性操作。所以遍历同样具有线性结构的数组或链表，是一件轻而易举的事情。反观二叉树，是典型的非线性数据结构，遍历时需要把非线性关联的节点转化成一个线性序列，以不同的方式来遍历，遍历出的序列顺序也不同。  </p>
<a id="more"></a>
<p>从节点之间的位置关系的角度来看，二叉树的遍历分为4种。<br><strong>1.前序遍历</strong><br><strong>2.中序遍历</strong><br><strong>3.后序遍历</strong><br><strong>4.层序遍历</strong><br>从更宏观的角度来看，二叉树的遍历归结为两大类。<br><strong>1.深度优先遍历（前序遍历、中序遍历、后序遍历）</strong><br><strong>1.广度优先遍历（层序遍历）</strong>  </p>
<h2 id="1-深度优先遍历"><a href="#1-深度优先遍历" class="headerlink" title="1.深度优先遍历"></a>1.深度优先遍历</h2><p>深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或其他一些复杂数据结构时，这两个概念经常被用到。<br>所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底”的访问方式。可能这些说法有些抽象，下面通过二叉树的<strong>前序遍历、中序遍历、后续遍历</strong>，来看一看深度优先是怎么回事吧。  </p>
<ul>
<li><strong>前序遍历</strong></li>
</ul>
<p>二叉树的前序遍历，输出顺序是根节点、左子树、右子树。<br><img src="/blog/img/2020/01/02/前序遍历.png"><br><br>上图就是一个二叉树的前序遍历，每个节点左侧的序号代表该节点的顺序，详细步骤如下。<br>1.首先输出的是根节点1。<br>2.由于根节点1存在左孩子，输出左孩子节点2。<br>3.由于节点2也存在左孩子，输出左孩子节点4。<br>4.节点4既没有左孩子，也没有右孩子，那么回到节点2，输出节点2的右孩子节点5。<br>5.节点5既没有左孩子也没有右孩子，那么回到节点1，输出节点1的右孩子节点3。<br>6.节点3没有左孩子但是有右孩子，因此输出节点3的右孩子节点6。   </p>
<ul>
<li><strong>中序遍历</strong></li>
</ul>
<p>二叉树的前序遍历，输出顺序是左子树、根节点、右子树。<br><img src="/blog/img/2020/01/02/中序遍历.png"><br><br>上图就是一个二叉树的中序遍历，每个节点左侧的序号代表该节点的顺序，详细步骤如下。<br>1.首先访问根节点的左孩子，如果这个左孩子还拥有左孩子，则继续深入访问下去，一直找到不再有左孩子的节点，并输出该节点。显然，第一个没有左孩子的节点是4。<br>2.依照中序遍历的次序，接下来输出节点4的父节点2。<br>3.在输出节点2的右孩子节点5。<br>4.以节点2为根的右子树已经输出完毕，这时在输出整个二叉树的根节点1。<br>5.由于节点3没有左孩子，所以直接输出根节点1的右孩子节点3。<br>6.最后输出节点3的右孩子节点6。   </p>
<ul>
<li><strong>后序遍历</strong></li>
</ul>
<p>二叉树的前序遍历，输出顺序是左子树、右子树、根节点。<br><img src="/blog/img/2020/01/02/后序遍历.png"><br><br>上图就是一个二叉树的后序遍历，每个节点左侧的序号代表该节点的顺序，详细步骤略。  </p>
<p><strong>前序遍历、中序遍历、后序遍历的代码展示，二叉树的这3种遍历方式，用递归的思路可以非常简单的实现出来。</strong>  </p>
<pre><code>import java.util.Arrays;
import java.util.LinkedList;

public class Traversal {

    /**
     * 构建二叉树
     * @param inputList 输入序列
     */
    public static TreeNode createBinary(LinkedList&lt;Integer&gt; inputList){
        TreeNode node = null;
        if(inputList == null || inputList.isEmpty()){
            return null;
        }
        Integer data = inputList.removeFirst();
        if(data!=null){
            node = new TreeNode(data);
            node.leftChild = createBinary(inputList);
            node.rightChild = createBinary(inputList);
        }
        return node; 
    }

    /**
     * 前序遍历
     * @param node 二叉树节点
     */
    public static void preOrderTraversal(TreeNode node){
        if(node == null){
            return;
        }
        System.out.print(node.data+&quot; &quot;);
        preOrderTraversal(node.leftChild);
        preOrderTraversal(node.rightChild);
    }

    /**
     * 中序遍历
     * @param node
     */
    public static void inOrderTraversal(TreeNode node){
        if(node == null){
            return;
        }
        inOrderTraversal(node.leftChild);
        System.out.print(node.data+&quot; &quot;);
        inOrderTraversal(node.rightChild);
    }

    /**
     * 后序遍历
     * @param node
     */
    public static void postOrderTraversal(TreeNode node){
        if(node == null){
            return;
        }
        postOrderTraversal(node.leftChild);
        postOrderTraversal(node.rightChild);
        System.out.print(node.data+&quot; &quot;);
    }

    /**
     * 二叉树节点
     */
    private static class TreeNode{
        int data;
        TreeNode leftChild;
        TreeNode rightChild;

        TreeNode(int data){
            this.data = data;
        }
    }

    public static void main(String[] args) {
        LinkedList&lt;Integer&gt; inputList = new LinkedList&lt;&gt;(Arrays.
                asList(new Integer[]{3,2,9,null,null,10,null,
                        null,8,null,4}));
        TreeNode treeNode = createBinary(inputList);
        System.out.print(&quot;前序遍历:&quot;);
        preOrderTraversal(treeNode);
        System.out.println();
        System.out.print(&quot;中序遍历:&quot;);
        inOrderTraversal(treeNode);
        System.out.println();
        System.out.print(&quot;后序遍历:&quot;);
        postOrderTraversal(treeNode);
    }
}</code></pre><p>输出结果  </p>
<pre><code>前序遍历:3 2 9 10 8 4 
中序遍历:9 2 10 3 8 4 
后序遍历:9 10 2 4 8 3 </code></pre><p>二叉树构建的方式有很多种，次例在代码的main函数中，通过{3,2,9,null,null,10,null,null,8,null,4}这样一个线性序列，构建的二叉树如下。<br><img src="/blog/img/2020/01/02/代码示例.png"><br>  </p>
<p><strong>非递归实现遍历（用数据结构 栈 实现），以前序遍历为例。</strong><br>1.首先遍历二叉树的节点1，放入栈中。<br><img src="/blog/img/2020/01/02/栈实现1.png"><br><br>2.遍历根节点1的左孩子节点2，放入栈中。<br><img src="/blog/img/2020/01/02/栈实现2.png"><br><br>3.遍历节点2的左孩子节点4，放入栈中。<br><img src="/blog/img/2020/01/02/栈实现3.png"><br><br>4.节点4既没有左孩子，也没有右孩子，我们需要回溯到上一个节点2。让旧的栈顶元素4出栈，就可以重新访问节点2，得到节点2的右孩子节点5。<br>此时节点2已经没有利用价值（已经访问过左孩子和右孩子），节点2出栈，节点5入栈。<br><img src="/blog/img/2020/01/02/栈实现4.png"><br><br>5.节点5既没有左孩子，也没有右孩子，再次回溯，一直回溯到节点1。所以让节点5出栈。<br>根节点1的右孩子是3，节点1出栈，节点3入栈。<br><img src="/blog/img/2020/01/02/栈实现5.png"><br><br>6.节点3的右孩子是节点6，节点3出栈，节点6入栈。<br><img src="/blog/img/2020/01/02/栈实现6.png"><br><br>7.节点6既没有左孩子，也没有右孩子，所以节点6出栈。此时栈为空，遍历结束。<br><img src="/blog/img/2020/01/02/栈实现7.png"><br> </p>
<p>代码实例  </p>
<pre><code>/**
 * 二叉树非递归前序遍历
 * @param root 根节点
 */
public static void preOrderTraversalStack(TreeNode root){
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode treeNode = root;
    while(treeNode != null || !stack.isEmpty()){
        //迭代访问节点的左孩子，并入栈
        while(treeNode != null){
            System.out.print(treeNode.data+&quot; &quot;);
            stack.push(treeNode);
            treeNode = treeNode.leftChild;
        }
        //如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子
        if(!stack.isEmpty()){
            treeNode = stack.pop();
            treeNode = treeNode.rightChild;
        }

    }
}</code></pre><p>中序遍历代码：  </p>
<pre><code>/**
 * 二叉树非递归中序遍历
 * @param root 根节点
 */
public static void inOrderTraversalStack(TreeNode root){
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode treeNode = root;
    while(treeNode != null || !stack.isEmpty()){
        //迭代访问节点的左孩子，并入栈
        while(treeNode != null){
            stack.push(treeNode);
            treeNode = treeNode.leftChild;
        }
        //如果节点没有左孩子，则弹出栈顶节点，输出栈顶，访问节点右孩子
        if(!stack.isEmpty()){
            treeNode = stack.pop();
            System.out.print(treeNode.data+&quot; &quot;);
            treeNode = treeNode.rightChild;
        }

    }
}</code></pre><p>后序遍历代码（略复杂）：<br>我的基本思路是这样的：<br>1.先把左孩子节点全部压入栈内；<br>2.弹出栈顶，判断是否有右孩子；<br>3.不存在的话，直接输出当前节点，有的话，则把当前被弹出节点再次压入栈顶，因为后续遍历是先输出左子树右子树，最后才是根节点，同时还需要保存记录起来，后续再次回到该节点时，直接输出即可，避免重复查找右子树操作。   </p>
<pre><code>/**
 * 二叉树非递归后序遍历
 * @param root 根节点
 */
public static void postOrderTraversalStack(TreeNode root){
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode treeNode = root;
    List&lt;TreeNode&gt; history = new ArrayList&lt;&gt;();//记录访问过并被重新压入进栈的节点
    while(treeNode != null || !stack.isEmpty()){
        //迭代访问节点的左孩子，并入栈
        while(treeNode != null){
            stack.push(treeNode);
            treeNode = treeNode.leftChild;
        }
        //如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子
        if(!stack.isEmpty()){
            TreeNode popTreeNode = stack.pop();
            if(history.size()&gt;0 &amp;&amp; history.contains(popTreeNode)){//判断当前弹出节点是否被第二次弹出，是的话直接输出结果
                System.out.print(popTreeNode.data+&quot; &quot;);
            }else{
                treeNode = popTreeNode.rightChild;
                if(treeNode != null){//判断被弹出节点是否存在右孩子，存在的话，把被弹出节点再次压入栈顶
                    stack.push(popTreeNode);
                    history.add(popTreeNode);
                }else{//被弹出节点不存在右孩子，输出结果
                    System.out.print(popTreeNode.data+&quot; &quot;);
                }
            }
        }

    }
}</code></pre><h2 id="2-广度优先遍历"><a href="#2-广度优先遍历" class="headerlink" title="2.广度优先遍历"></a>2.广度优先遍历</h2><p>如果说深度优先遍历是在一个方向上“一头扎到底”，那么广度优先遍历则恰恰相反；先在各个方向上走出1步，再在各个方向上走出第2步、第3步……一直到各个方向全部走完。听起来有些抽象，下面我们通过二叉树的<strong>层序遍历</strong>，来看一看广度优先是怎么回事。<br>层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。<br><img src="/blog/img/2020/01/03/层序遍历.png"><br><br>上图就是一个二叉树的层序遍历，每个节点左侧的序号代表该节点的输出顺序。<br>可是，二叉树同一层次的节点之间是没有直接关联的，如何实现层序遍历？<br>使用<strong>队列</strong>，详细遍历步骤如下：<br>1.根节点1进入队列。<br><img src="/blog/img/2020/01/03/步骤1.png"><br><br>2.节点1出队，输出节点1，并得到节点1的左孩子节点2、右孩子节点3。让节点2和3进入队列。<br><img src="/blog/img/2020/01/03/步骤2.png"><br><br>3.节点2出队，输出节点2，并得到节点2的左孩子节点4、右孩子节点5。让节点4和节点5入队。<br><img src="/blog/img/2020/01/03/步骤3.png"><br><br>4.同理，节点3出队，输出节点3，并得到节点3的右孩子节点6，让节点6入队。<br><img src="/blog/img/2020/01/03/步骤4.png"><br><br>5.节点4出队，输出节点4，由于节点4没有孩子节点，所以没有新节点入队。<br><img src="/blog/img/2020/01/03/步骤5.png"><br><br>6.结点5的操作同节点4操作。<br><img src="/blog/img/2020/01/03/步骤6.png"><br><br>7.结点6的操作同节点4操作。<br><img src="/blog/img/2020/01/03/步骤7.png"><br><br>到此为止所有的节点都遍历输出完毕。  </p>
<p>示例代码：  </p>
<pre><code>/**
 * 队列实现 层序遍历
 * @param root 根节点
 */
public static void levalOrderTraversal(TreeNode root){
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.offer(root);
    while(!queue.isEmpty()){
        TreeNode treeNode = queue.poll();
        System.out.print(treeNode.data+&quot; &quot;);
        if(treeNode.leftChild!=null){
            queue.offer(treeNode.leftChild);
        }
        if(treeNode.rightChild!=null){
            queue.offer(treeNode.rightChild);
        }
    }

}</code></pre><p>层序遍历也可以通过递归实现，下面是我个人的一段实现，借用了数组（可能有更好的方法，后续补充）。<br>大致思路：<br>1.二叉树有个特点，左孩子的下标=父节点下标x2+1，右孩子下标=父节点下标x2+2。<br>2.这样的话，我们只需要把每个节点存储在数组对应的下标里，就行了，然后输出数组就行了。</p>
<pre><code>/**
 * 递归实现  层序遍历
 * @param root 根节点
 */
static String[] arr = new String[10];//这里没有用int[],考虑到节点如果包含0元素，输出数组时可能会被过滤掉。
public static void levalOrderTraversal2(TreeNode node,int i){
    if(i&gt;=arr.length){//如果数组容量不够，扩容
        String[] newArr = new String[arr.length*2];
        System.arraycopy(arr, 0, newArr, 0, arr.length);//复制数据
    }
    arr[i] = String.valueOf(node.data);
    if(node.leftChild!=null){
        levalOrderTraversal2(node.leftChild,i*2+1);
    }
    if(node.rightChild!=null){
        levalOrderTraversal2(node.rightChild,i*2+2);
    }
}
/**
 * 输出
 */
public static void output(){
    for (int i = 0; i &lt; arr.length; i++) {
        if(arr[i]!=null){//过滤null
            System.out.print(arr[i]+&quot; &quot;);
        }
    }
}</code></pre><p>mian方法代码：</p>
<pre><code>System.out.print(&quot;递归，层序遍历:&quot;);
levalOrderTraversal2(treeNode,0);
Traversal.output();</code></pre>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src>
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-enable="false" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/blog/js/plugin.js"></script>
<script src="/blog/js/typed.js"></script>
<script src="/blog/js/diaspora.js"></script>
<link rel="stylesheet" href="/blog/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/blog/photoswipe/default-skin/default-skin.css">
<script src="/blog/photoswipe/photoswipe.min.js"></script>
<script src="/blog/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
